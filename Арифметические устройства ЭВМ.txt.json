[
[{"tag":"","text":"Г. Н. Соловьев\n\nАрифметические устройства ЭВМ\n\nМосква «Энергия» 1978"},{"tag":"","text":"ББК 32.972 С60 УДК 681.325.5"},{"tag":"","text":"Соловьев Г. Н. Арифметические устройства ЭВМ.— М.: Энергия, 1978.— 176 с., ил.\n\n70 к."},{"tag":"содержание книги","text":"В книге рассмотрены вопросы проектирования арифметических устройств, которые нашли применение как в существующих, так и во вновь проектируемых ЭВМ. Изложены системы счисления и способы представления чисел, большое внимание уделено методикам выполнения арифметических действий с фиксированной и плавающей запятой. Вопросы проектирования в книге представлены изложением сведений о регистрах, сумматорах, схемах арифметических устройств различного типа, методах контроля передач и арифметических и логических преобразований и т. д."},{"tag":"целевая аудитория","text":"Книга предназначается для широкого круга специалистов, занимающихся вопросами проектирования и эксплуатации ЭВМ, а также студентов, обучающихся проектированию и эксплуатации ЭВМ."},{"tag":"","text":"30502-354 0511011-78\n\n94-78\n\nББК 32.972 60b6"},{"tag":"","text":"ГЕОРГИЙ НИКОЛАЕВИЧ СОЛОВЬЕВ\n\n**Арифметические устройства ЭВМ**\n\nРедактор В. Н. Вагин Редактор издательства Г. В. Лихачева Технический редактор М. П. Осипова Корректор М. Г. Гулина ИБ № 907\n\nСдано в набор 01.02.78. Подписано к печати 23.08.78. Т-15534. Формат 60X90/м. Бумага типографская № 2. Гарн. шрифта литературная. Печать высокая. Усл. печ. п. 11,0. Уч.-изд. л. 10,9. Тираж 15 000 экз. Зак. № 785. Цена 70 коп.\n\nИздательство «Энергия», 113114, Москва, М-114, Шлюзовая наб., 10\n\nЛенинградская типография № 4 «Союзполиграфическая» при Государственном комитете Совета Министров СССР по делам издательств, полиграфии и книжной торговли. Ленинград, Ф-126, ул. Социалистическая, д. 14.\n\n© Издательство «Энергия», 1978 г."},{"tag":"введение","text":"Из всех вопросов, относящихся к теории и проектированию цифровых вычислительных машин за 30 лет их существования, наиболее стабильными и установившимися являются основы теории и проектирования устройств, осуществляющих арифметическое и логическое преобразование двоичной информации. Этой тематике и посвящено данное издание. В нем отражена попытка изложить тот материал, который как бы отфильтрован тридцатилетним периодом существования ЭВМ. Соответственно все содержание книги ориентировано лишь на двоичную систему счисления, в теоретических основах рассматриваются лишь те методики, которые нашли применение в ЭВМ 2-го и 3-го поколений и перспектива применения которых в будущем также не подлежит сомнению. Такой же подход характерен и для схемо- и системотехнических вопросов, рассматриваемых в книге."},{"tag":"введение","text":"Все содержание книги является результатом стремления автора изложить материал с общих позиций, без излишней детализации, особенно в схемах рассматриваемых устройств, а не с позиций конкретной ЭВМ."},{"tag":"введение","text":"При отборе материала автор стремился дать комплексное изложение вопросов, относящихся к рассматриваемой теме. В одном издании наряду с традиционными арифметическими основами, регистрами и сумматорами, методами повышения скорости выполнения операций умножения и деления рассмотрены:"},{"tag":"рассматриваемые темы","text":"основы функционирования арифметических устройств параллельного, последовательного и последовательно-параллельного действия над числами с фиксированной и плавающей запятой; контроль работы арифметических устройств, где основное внимание обращено на сквозной и непрерывный контроль передач, арифметических и логических преобразований по модулю 2; динамические регистры хранения и сдвига;"}],
[{"tag":"аритметика в ЭВМ 3-го поколения","text":"основы представления, арифметические действия над числами в двоично-десятичной системе счисления, основные вопросы реализации табличной арифметики, округление результатов арифметических операций над числами с фиксированной и плавающей запятой и ряд других специфических вопросов арифметических основ, нашедших широкое применение в ЭВМ 3-го поколения."},{"tag":"интегральная схемотехника","text":"Весь материал книги, особенно гл. 4, рассчитан на использование интегральной схемотехники. Основные вопросы интегральной схемотехники, освещенные в гл. 3, а также в гл. 1, в которых даны логические основы в объеме, необходимы для формального описания как алгоритмов арифметических и логических преобразований, так и схем основных узлов АУ, освобождают читателя от обращения к специальной литературе при изучении или ознакомлении с данной книгой."},{"tag":"структура книги","text":"Несомненно, что отражение в книге такого комплекса вопросов при весьма ограниченном ее объеме потребовало краткого и лаконичного изложения ряда тем. Насколько удалось все вышеуказанные идеи реализовать в книге, будет судить читатель."},{"tag":"целевые читатели","text":"По мнению автора, данная книга будет полезна как студентам, обучающимся по специальности «Электронные вычислительные машины», так и специалистам, работающим в области вычислительной техники."},{"text":"Автор выражает благодарность преподавателям кафедры «Электронные вычислительные машины» МИФИ, практические замечания которых способствовали формированию содержания книги, и сотрудникам кафедры за большую помощь в подготовке рукописи к изданию."},{"tag":"глава 1: элементы логических основ","text":"Глава первая\nЭЛЕМЕНТЫ ЛОГИЧЕСКИХ ОСНОВ"},{"tag":"что такое алгебра логики","text":"Логическими основами цифровых вычислительных машин является алгебра логики — одна из основных частей математической логики. Алгебра логики оперирует с так называемыми высказываниями. Под высказыванием понимают любое утверждение, которое либо истинно, либо ложно. Например: снег белый, сегодня 20 марта, сейчас 10 ч утра и т. д. Кроме истинности и ложности, никакие другие признаки (хорошее, плохое высказывание и т. д.) высказываний в алгебре логики не рассматриваются."},{"tag":"логические переменные","text":"В алгебре логики принято отождествлять истинность высказываний с 1, а ложность с 0. Таким образом, высказывание — это двоичная переменная; широко используется и другое название — логическая переменная. Высказывания, или логические переменные, бывают простыми и обозначаются строчными буквами какого-либо алфавита: \\(x, y, z, x_1, x_2, a, b \\ldots\\). Из простых высказываний образуются сложные высказывания, которые являются двоичными функциями логических переменных и которые принято обозначать заглавными буквами: \\(A, B, II, S, P \\ldots\\). Эти сложные высказывания часто называются функциями алгебры логики и сокращенно обозначаются ФАЛ."},{"tag":"представление функций алгебры логики","text":"Алгебра логики занимается представлением и преобразованием функций алгебры логики с помощью элементарных логических функций. Вопросы представления и преобразования ФАЛ широко используются, особенно при проектировании цифровых вычислительных машин. Аппарат алгебры логики используется для формального описания функционирования схем ЭВМ, используется при синтезе схем устройств ЭВМ и в других целях."},{"tag":"элементарные логические функции одной переменной","text":"К числу элементарных логических функций следует прежде всего отнести элементарные функции одной переменной \\(x\\). Эти функции представлены так называемой таблицей истинности (табл. 1-1). Таблица истинности в общем случае отражает значения функции, соответствующие каждому из возможных наборов аргументов (логических переменных)."},{"tag":"таблица истинности 1-1","text":"Таблица 1-1\n\n| \\(x\\) | \\(t_1\\) | \\(t_2\\) | \\(t_3\\) | \\(t_4\\) |\n|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 |\n| 1 | 0 | 1 | 0 |"}],
[
    {
        "tag": "функционально-полные системы",
        "text": "Оказывается, что любую ФАЛ можно описать с помощью ограниченного набора элементарных логических функций. Ограниченный набор связан с понятием: функционально-полная система логических функций \\(f_1 \\ldots f_m\\), которое введено в алгебре логики. В соответствии с этим понятием система элементарных логических функций \\(f_1 \\ldots f_m\\) называется полной, если любую ФАЛ можно изобразить в виде суперпозиции (совокупности) функций \\(f_1 \\ldots f_m\\). В литературе функционально-полная система также называется базисом.\n\nВозможно существование нескольких базисов. Определим одну из функционально-полных систем. Допустим, имеем производную функцию \\(A(x_1 \\ldots x_n)\\) конечного числа двоичных переменных. Если эта функция отлична от тождественного нуля (не является постоянно-ложной), то имеется в наборов аргументов (обозначим их \\(Q_1, Q_2, \\ldots, Q_k\\)), при которых наша функция равна 1. При таких условиях (без доказательства) справедлива следующая формула:\n\n\\[A(x_1 \\ldots x_n) = \\delta_1 \\lor \\delta_2 \\lor \\ldots \\lor \\delta_k,\\]\nгде \\(\\delta_j = y_{j1} \\land y_{j2} \\land \\ldots \\land y_{jn};\\)\n\\[j = 1 \\ldots k,\\]\nа\n\\[y_{ji} = \\begin{cases} x_i, & \\text{если } x_i = 1 \\text{ в наборе аргументов } Q_j; \\\\ \\overline{x_i}, & \\text{если } x_i = 0 \\text{ в наборе аргументов } Q_j. \\end{cases}\\]\n\\[i = 1 \\ldots n\\]"
    },
    {
        "tag": "пример функции в ДНФ",
        "text": "Проиллюстрируем все сказанное примером. Допустим, функция от \\(x_1 x_2 x_3\\) задана таблицей истинности (табл. 1-3).\n\nЗдесь функция \\(A(x_1, x_2, x_3) = 1\\) при трех наборах аргументов. Эти наборы аргументов соответствуют \\(\\delta_1 = \\overline{x_1} \\land \\overline{x_2} \\land x_3, \\delta_2 = \\overline{x_1} \\land x_2 \\land \\overline{x_3}\\) и \\(\\delta_3 = x_1 \\land \\overline{x_2} \\land x_3\\).\n\nПосле этого наша функция имеет следующий вид:\n\n\\[A(x_1 x_2 x_3) = \\overline{x_1} \\land \\overline{x_2} \\land x_3 \\lor \\overline{x_1} \\land x_2 \\land \\overline{x_3} \\lor x_1 \\land \\overline{x_2} \\land x_3.\\]"
    },
    {
        "tag": "другие базисы логических функций",
        "text": "Кроме рассмотренной функционально-полной системы элементарных логических функций (\\(\\lor, \\land, \\overline{}\\)), возможны другие системы. Например, система, состоящая из двух элементарных функций (\\(\\lor, \\overline{}\\)) или (\\(\\land, \\overline{}\\)), также является базисом. Базис или функционально-полную систему образует только одна элементарная функция / (штрих Шеффера) или \\(\\uparrow\\) (стрелка Пирса).\n\nВ ЭВМ первого и частично второго поколения в основном находил применение базис, состоящий из \\(\\lor\\), \\(\\land\\), —. В машинах 3‑го поколения получили распространение функционально‑полные системы, состоящие из одной элементарной функции / или \\(\\uparrow\\)."
    },
    {
        "tag": "элементарные эквивалентности",
        "text": "1-3. Элементарные эквивалентности\n\nОсновными задачами алгебры логики являются представление и преобразование ФАЛ с помощью элементарных логических функций. В разрешении этой задачи большое значение принадлежит так называемым эквивалентным функциям, которые сокращенно называют эквивалентностями. Эквивалентные ФАЛ при любых значениях аргументов имеют одинаковые значения. Эквивалентность двух функций обозначается знаком = ."
    },
    {
        "tag": "законы алгебры логики",
        "text": "Таблица 1-4 Рассмотрим элементарные эквивалентности, широко применяемые в алгебре логики.\n\nДвойное или четное количество отрицаний от \\(x\\) эквивалентно логической переменной \\(x\\), т. е. \\(\\overline{\\overline{x}} = x\\). Доказывается с помощью элементарной таблицы истинности (табл. 1-4). Ряд законов, таких, как сочетательный, переместительный, распределительный, применяемых в обычной алгебре, используется и в алгебре логики:\n\nсочетательные законы конъюнкции и дизъюнкции\n\\[x \\lor (y \\lor z) = (x \\lor y) \\lor z;\\]\n\\[x \\land (y \\land z) = (x \\land y) \\land z;\\]\n\nпереместительные законы конъюнкции и дизъюнкции\n\\[x \\lor y \\lor z = z \\lor x \\lor y;\\]\n\\[x \\land y \\land z = y \\land z \\land x;\\]\n\nраспределительный (дистрибутивный закон 1‑го рода)\n\\[x \\land (y \\lor z) = (x \\land y) \\lor (x \\land z).\\]\n\nТолько в алгебре логики справедлив дистрибутивный закон 2‑го рода:\n\\[x \\lor y \\land z = (x \\lor y) \\land (x \\lor z),\\]\nв обычной алгебре такой закон не имеет смысла, так как \\(a + bc \\neq (a + b) (a + c)\\). Доказательство этого закона (как и ряда последующих эквивалентностей) можно провести с помощью таблицы истинности (табл. 1-5)."
    }
],
[
    {
        "tag": "правило Де-Морама",
        "text": "Правило Де-Морама: \\(\\overline{x \\land y} = \\overline{x} \\lor \\overline{y}\\), \\(\\overline{x \\lor y} = \\overline{x} \\land \\overline{y}\\). Это правило остается в силе и при большем количестве переменных, так, \\(\\overline{x_1 \\land x_2 \\land \\cdots \\land x_n} = \\overline{x_1} \\lor \\overline{x_2} \\lor \\cdots \\lor \\overline{x_n}\\)."
    },
    {
        "tag": "правило идемпотентности",
        "text": "Правило идемпотентности: \\(x \\lor x \\lor \\cdots \\lor x = x\\), \\(y \\land y \\land \\cdots \\land y = y\\)."
    },
    {
        "tag": "основные эквивалентности логики",
        "text": "Широко используются эквивалентности: \\(x \\land \\overline{x} = 0\\) — не могут быть истинными два высказывания, когда одно утверждает, а другое это утверждение отрицает; \\(x \\lor \\overline{x} = 1\\) — из двух противоречивых высказываний одно является истинным. Очевидность эквивалентностей \\(x \\land 1 = x\\), \\(x \\land 0 = 0\\), \\(x \\lor 1 = 1\\), \\(x \\lor 0 = x\\) не вызывает сомнений."
    },
    {
        "tag": "импликация",
        "text": "Из определения импликации следует, что \\(x \\rightarrow y = \\overline{x} \\lor y\\)."
    },
    {
        "tag": "эквивалентность и XOR",
        "text": "С помощью таблицы истинности можно показать, что \\(x \\sim y = (x \\rightarrow y) \\land (\\overline{y} \\rightarrow x) = (\\overline{x} \\lor y) \\land (\\overline{y} \\lor x)\\) и что \\(x \\oplus y = (x \\land \\overline{y}) \\lor (\\overline{x} \\land y)\\)."
    },
    {
        "tag": "законы поглощения",
        "text": "Важное значение при преобразованиях ФАЛ и их минимизации имеют эквивалентности \\(x \\lor (x \\land y) = x\\) и \\(x \\land (x \\lor y) = x\\)."
    },
    {
        "tag": "штрих Шеффера (Sheffer stroke)",
        "text": "Особого внимания заслуживают эквивалентности, связанные с штрихом Шеффера. Из определения этой функции следует, что \\(x/y = \\overline{x} \\lor \\overline{y}\\) и \\(x/x = \\overline{x}\\). Рассмотрим функцию \\((x/x)/(y/y)\\). Если использовать предыдущие эквивалентности, функция \\((x/x)/(y/y) = \\overline{x}/\\overline{y} = \\overline{x} \\lor \\overline{y} = x \\lor y\\). На основе тех же эквивалентностей можно функцию \\(x \\land y\\) выразить через \\(l\\). Так, \\(x \\land y = \\overline{x} \\lor \\overline{y} = \\overline{x}/\\overline{y} = (x/y)/(x/y)\\). Таким образом, элементарные функции \\(\\lor, \\land, \\overline{}\\) выражаются через \\(l\\). Следовательно, штрих Шеффера образует функционально-полную систему логических функций — базис."
    },
    {
        "tag": "стрелка Пирса (Pierce arrow)",
        "text": "Из определения функции стрелка Пирса следует, что \\(x \\uparrow y = \\overline{x} \\land \\overline{y}\\) и \\(x \\uparrow x = \\overline{x}\\). Если использовать эти эквивалентности, функция \\(x \\lor y = \\overline{x} \\land \\overline{y} = x \\uparrow y = (x \\uparrow y) \\uparrow (x \\uparrow y)\\), a \\(x \\land y = \\overline{x} \\land \\overline{y} = x \\uparrow y = (x \\uparrow x) \\uparrow (y \\uparrow y)\\). И в данном случае элементарная логическая функция образует базис."
    },
    {
        "tag": "нормальные формы ДНФ и КНФ",
        "text": "Базис \\(\\lor, \\land, \\overline{}\\). Здесь широко используется методика приведения ФАЛ к так называемым нормальным формам. Существуют две формы: нормальная дизъюнктивная (НДФ) и нормальная конъюнктивная (НКФ). Рассмотрим два понятия: элементарные конъюнкция и дизъюнкция — это те конъюнкции и дизъюнкции, в которых каждая логическая переменная встречается не более 1 раза (в виде основной логической переменной либо её отрицания). Например: \\(x \\land \\overline{y} \\land z\\) или \\(x \\land \\overline{y}\\), \\(x \\lor \\overline{y} \\lor z\\) или \\(x \\lor z\\) являются элементарными конъюнкциями и дизъюнкциями соответственно. НДФ — дизъюнкция элементарных конъюнкций. Например: \\[F(x_1 x_2 x_3) = \\overline{x_1} \\land x_2 \\lor \\overline{x_1} \\land \\overline{x_2} \\land x_3 \\lor x_2 \\land x_3.\\] НКФ — конъюнкция элементарных дизъюнкций. Например: \\[\\Phi(x_1 x_2 x_3) = (\\overline{x_1} \\lor x_2 \\lor x_3) \\land (x_1 \\lor x_2 \\lor \\overline{x_3}) \\land (x_2 \\lor x_3).\\] Справедливо утверждение, что любая ФАЛ может быть представлена в ДНФ или КНФ. Правило преобразования ФАЛ к нормальным формам следующее: вначале исключают \\(\\rightarrow, \\oplus, \\sim, /, \\uparrow\\); затем, пользуясь эквивалентностью Де-Морама, освобождаемся от общих отрицаний; в заключение, применяя дистрибутивные законы 1-го и 2-го рода, получаем НДФ или КНФ."
    },
    {
        "tag": "пример преобразования к ДНФ и КНФ",
        "text": "Пример: \\(F(x, y, z) = (\\overline{x} \\lor y) \\rightarrow z\\) привести к НДФ и НКФ. \\[F(x, y, z) = (\\overline{x} \\lor y) \\rightarrow z = (\\overline{x} \\lor y) \\lor z = (\\overline{x} \\lor y) \\land \\overline{z}\\] — получили НКФ; применяя к НКФ первый дистрибутивный закон, получаем ДНФ: \\[(\\overline{x} \\lor y) \\land \\overline{z} = \\overline{x} \\land \\overline{z} \\lor y \\land \\overline{z}.\\]"
    },
    {
        "tag": "базис И-НЕ (NAND)",
        "text": "Базис И—НЕ. Таблица истинности функции \\(x / y\\) имеет вид: \\[\\begin{array}{ccc} x & y & x/y \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 0 \\\\ \\end{array}\\]. Для неё справедливы следующие элементарные эквивалентности: \\(x/x = \\overline{x}\\) и \\(x/y = \\overline{x} \\lor \\overline{y} = \\overline{x \\land y}\\). В соответствии с последним выражением элемент, реализующий эту функцию, получил название И—НЕ. Для перемежных эта функция запишется следующим образом: ... Справедливы следующие эквивалентные выражения: \\[x/y/z = (x/y)/z = x/(y/z);\\] \\[x/y/z/u = (x/y)/(z/u).\\] При этом сочетательный закон здесь не справедлив, ибо \\[x/y/z \\neq (x/y)/z \\neq x/(y/z).\\]"
    },
    {
        "tag": "представление функции в базе И-НЕ",
        "text": "Представление любой ФАЛ в базе И—НЕ удобно производить, получив вначале ДНФ для преобразуемой ФАЛ. При этом любую элементарную конъюнкцию, входящую в ДНФ, можно представить следующим образом: \\(A_j = (x_1 \\land x_2 \\land \\ldots \\land x_k \\land \\overline{x_{k+1}} \\land \\ldots \\land \\overline{x_n})\\), а саму ДНФ как \\(f = A_1 \\lor A_2 \\lor \\ldots \\lor A_m\\). Возьмем дважды отрицание от левой и правой частей последнего тождества. Получим: \\(\\overline{\\overline{f}} = f = \\overline{\\overline{A_1} \\lor \\overline{A_2} \\lor \\ldots \\lor \\overline{A_m}}\\), и на основании (1-1) можно записать, что \\(f = \\overline{\\overline{A_1}/\\overline{A_2}/\\ldots/\\overline{A_m}}\\). Обратимся теперь к члену \\(\\overline{A_j} = \\overline{x_1 \\land x_2 \\land \\ldots \\land x_k \\land \\overline{x_{k+1}} \\land \\ldots \\land \\overline{x_n}} = \\overline{x_1} \\lor \\overline{x_2} \\lor \\ldots \\lor \\overline{x_k} \\lor x_{k+1} \\lor \\ldots \\lor x_n\\) — это выражение на основании (1-1) можно представить:"
    }
],
[{"tag":"представление ФАЛ в базисе И—НЕ","text":"\\[\\overline{A_j} = x_1/x_2/\\ldots/x_k/\\overline{x_{k+1}}/\\ldots/\\overline{x_n}.\\]\\n\\nТаким образом, правило представления ФАЛ в базисе И—НЕ формулируется следующим образом. Получаем ДНФ от исходной ФАЛ. В полученной ДНФ заменяем все операции дизъюнкции конъюнкция операциями/. После этого группы букв, соответствующие дизъюнктивным членам (элементарным конъюнкциям), заключаем в скобки.\\n\\nПример: \\(f(x, y, z) = y \\land z \\lor x \\land \\overline{y} \\land z \\lor x \\land z \\land y \\lor x \\land \\overline{y} \\land z = (\\overline{y}/z)/(\\overline{x}/\\overline{y}/z)/(x/z/y)/(x/\\overline{y}/z)\\)."},{"tag":"реализация ФАЛ с двухвходовыми элементами","text":"Для реализации такой функции потребуются элементы, выполняющие функцию И—НЕ и имеющие два, три и четыре входа. При использовании только двух входовых элементов необходимо преобразовать функцию на основе выражения \\(x/y/z = (\\overline{x}/\\overline{y})/z\\).\\n\\nТогда \\(\\overline{y} = (\\overline{y}/z)/(\\overline{x}/y/z)/(\\overline{x}/z/y)/(\\overline{x}/y/z)\\), далее, воспользовавшись эквивалентностью \\(x/y/z/u = (x/y)/(z/u)\\), получаем \\(\\overline{y} = (\\overline{y}/z)/(\\overline{x}/y/z)/(\\overline{x}/z/y)/(\\overline{x}/y/z)\\), которая представлена в виде пригодной для реализации двухвходовыми элементами."},{"tag":"базис ИЛИ—НЕ","text":"Базис ИЛИ—НЕ. Таблица истинности \\(x \\uparrow y\\) имеет вид: табл. 1-7. Для нее справедливы следующие элементарные эквивалентности: \\[x \\uparrow y = \\overline{x \\lor y} = \\overline{x} \\land \\overline{y} = x \\lor \\overline{y}.\\] В соответствии с последним выражением элемент, реализующий данную функцию, и соответствующий базис получили название ИЛИ—НЕ."},{"tag":"методика представления ФАЛ в базисе ИЛИ—НЕ","text":"Методика представления любой ФАЛ в базисе ИЛИ—НЕ аналогична методике представления ФАЛ в базисе И—НЕ. Здесь действуют эквивалентности, подобные эквивалентностям функции \\(x/y\\). Можно показать, что для представления любой ФАЛ в рассматриваемом базисе необходимо исходную ФАЛ представить в КНФ. Затем в КНФ необходимо заменить знаки \\(\\lor\\), \\(\\land\\) на \\(\\uparrow\\) и группы букв, соответствующие элементарным дизъюнкциям, заключить в скобки.\\n\\nНапример, \\(\\overline{y}(x,y,z,u) = (x \\lor z) \\land (\\overline{y} \\lor u) \\land (\\overline{x} \\lor \\overline{y})\\) является КНФ, от которой легко получить эквивалентную функцию в базисе ИЛИ—НЕ\\n\\n\\[\\overline{y}(x,y,z) = (x \\uparrow z) \\uparrow (y \\uparrow z \\uparrow u) \\uparrow (x \\uparrow y).\\]"},{"tag":"представление ФАЛ в разных базисах","text":"Рассмотренная методика обеспечивает представление ФАЛ в базисах И и НЕ (И—HE и НЕ) или + и НЕ (ИЛИ—HE и НЕ). Используя эквивалентности вида \\(x = x/x = x \\uparrow x\\), возможно представление ФАЛ в базисе \\(l\\) или \\(\\uparrow\\), но при этом в ФАЛ увеличится количество членов по сравнению с дизъюнктивной и конъюнктивной нормальными формами."},{"tag":"системы счисления","text":"Метод изображения любых чисел с помощью ограниченного количества цифр называется системой счисления. В своей повседневной практике мы встречаемся с двумя системами счисления: десятичной и римской."},{"tag":"десятичная система счисления","text":"В десятичной системе счисления для записи чисел используются десять различных цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9. Эти цифры обозначают десять целых чисел. Число 10 обозначается совокупностью двух цифр и является основанием системы счисления. В общем виде основанием системы счисления \\(p\\) называется количество цифр, используемых для изображения чисел."},{"tag":"позиционная система счис"}],
[{"tag":"значения цифр в разных системах счисления","text":"В выражениях (2-3) и (2-4) \\(x_i\\) может иметь одно из следующих значений: 0, 1, 2, . . . , \\(p-1\\). Соответственно в двоичной системе счисления, т. е. при \\(p = 2\\), возможны лишь две цифры: 0, 1. В случае пятеричной системы счисления (\\(p = 5\\)) используются пять цифр: 0, 1, 2, 3 и 4. В том случае, когда основание системы счисления больше 10, общепринятых цифр уже не хватает и вводятся новые обозначения."},{"tag":"шестнадцатеричная система счисления","text":"Так, в случае использования шестнадцатеричной системы счисления устанавливаются, что \\(10 = \\bar{6}_{16}\\), \\(11 = \\bar{1}_{16}\\), \\(12 = \\bar{2}_{16}\\), \\(13 = \\bar{3}_{16}\\), \\(14 = \\bar{4}_{16}\\) и \\(15 = \\bar{5}_{16}\\), или \\(10 = A\\), \\(11 = B\\), \\(12 = C\\), \\(13 = \\bar{A}\\), \\(14 = E\\), \\(15 = F\\). Последние обозначения приняты в ЕС ЭВМ и большинстве других машин."},{"tag":"пример представления числа в разных системах счисления","text":"\\[B9,4_{16} = 11 \\cdot 16^1 + 9 \\cdot 16^0 + 4 \\cdot 16^{-1};\\]\\[271,2_{8} = 2 \\cdot 8^2 + 7 \\cdot 8^1 + 1 \\cdot 8^0 + 2 \\cdot 8^{-1};\\]\\[2321,1_{4} = 2 \\cdot 4^3 + 3 \\cdot 4^2 + 2 \\cdot 4^1 + 1 \\cdot 4^0 + 1 \\cdot 4^{-1};\\]\\[10111001,01_{2} = 1 \\cdot 2^7 + 1 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^0 + 1 \\cdot 2^{-2}.\\]"},{"tag":"двоично-десятичные системы счисления","text":"Наряду с позиционными системами счисления, где \\(p \\neq 10\\), существуют двоично-десятичные системы счисления. В таких системах каждая десятичная цифра кодируется (изображается) определенной комбинацией четырех цифр двоичной системы. В четырех двоичных разрядах возможно получение шестнадцати различных двоичных комбинаций. В каждой системе кодирования между десятью (из шестнадцати) двоичными комбинациями и десятичными цифрами 0, 1, . . . , 9 устанавливается однозначное соответствие. При этом очевидно большое количество возможных систем кодирования. На практике широко распространены две системы кодирования, сущность которых иллюстрируется табл. 2-1. В этой таблице всего 16 четырехразрядных двоичных комбинаций (16 тетрад). В одной системе кодирования для изображения десятичных цифр используются первые 10 тетрад. При этом 0000 соответствует 0, 0001 — 1, . . . , 1001 — 9. Эта система обозначается, как система 8421, где цифры 8, 4, 2 и 1 являются весами двоичных разрядов тетрад. Эта система иногда называется системой с естественным распределением веса двоичного разряда. В другой широко распространенной системе для изображения десятичных цифр используются тетрады от 0011 до 1100. Эта система получила название — система с избытком 3, так как двоичные эквиваленты десятичных цифр этой системы получены за счет прибавления \\(3 = 0011\\) к соответствующим тетрадам системы 8421. Эта система обозначается как 8421 + 3. В соответствии с изложенным число 270,96 в двоично-десятичной системе 8421 имеет следующий вид: 001001110000, 10010110 и в системе 8421 + 3 — 010110100011, 11001001."},{"tag":"факторы выбора системы счисления","text":"### 2-2. Выбор системы счисления\n\nОсновными определяющими факторами в данном вопросе являются степень сложности выполнения арифметических операций, объем оборудования, необходимый для представления чисел, и условия реализации (создания) оборудования для представления цифр. Каждый из этих факторов существенно зависит от основания системы счисления. Рассмотрим эти зависимости."},{"tag":"сложение в p-ичной системе","text":"**Сложение.** Допустим, требуется сложить два числа в \\(p\\)-ичной системе счисления:\n\n\\[A_p = a_1a_2 \\cdots a_t a_{t+1} \\cdots a_n\\]\n\n\\[B_p = b_1b_2 \\cdots b_t b_{t+1} \\cdots b_n\\]\n\n\\[\\frac{A_p + B_p}{c_1 c_2 \\cdots c_t c_{t+1}} \\cdots c_n\\]\n\nСложение начинается с младших разрядов. В общем виде код суммы каждого разряда \\(c_i\\) получается в результате сложения \\(a_i + b_i + 1\\), где единица соответствует переносу из младшего разряда в старший. Здесь возможны два случая: 1) \\(a_i + b_i + 1 = c_i < p\\), т. е. код суммы не превышает величины, равной основанию системы счисления. Соответственно в старшем разряде в операции сложения участвуют только \\(a_{i-1}\\) и \\(b_{i-1}\\); 2) \\(a_i + b_i + 1 \\geq p\\), т. е. код суммы больше или равен основанию системы счисления. Соответственно сумма \\(i\\)-го разряда \\(a_i + b_i + 1 - p = c_i\\); код суммы в старшем разряде определяется в результате сложения \\(a_{i-1} + b_{i-1} + 1\\).\n\nИз изложенного следует, что правила, методика выполнения сложения остаются такими же, как и в десятичной системе счисления. Но наиболее просто выполнение сложения в двоичной системе счисления, что подтверждается соответствующей таблицей сложения:\n\n\\[0 + 0 = 0 \\\\ 1 + 0 = 1 \\\\ 0 + 1 = 1 \\\\ 1 + 1 = 10\\]"},"tag":"вычитание в p-ичной системе","text":"**Вычитание.** Нахождение разности двух чисел, например,\n\n\\[A_p = a_1a_2 \\cdots a_n \\\\ B_p = b_1b_2 \\cdots b_{n+1}\\]\n\n\\[\\frac{A_p - B_p = r_1r_2 \\cdots r_{i+1} \\cdots r_n}{}\\]\n\nкак и при сложении, начинают с вычитания младших разрядов. В общем виде код разности каждого разряда \\(r_i\\) получается в результате \\(a_i - b_i - 1\\), где единица соответствует займу из старшего разряда в младший. Здесь возможны два случая: 1) \\(a_i - b_i - 1 = r_i \\geq 0\\), т. е. код разности положителен. Соответственно в старшем разряде в операции участвуют только \\(a_{i-1} - b_{i-1}\\); 2) \\(a_i - b_i - 1 < 0\\), при этом \\(r_i = p + a_i - b_i - 1 \\geq 0\\), и код разности в старшем разряде получается в результате \\(a_{i-1} - b_{i-1} - 1\\)."}],
[{"tag":"вычитание в двоичной системе","text":"Так же как и операция сложения, вычитание наиболее просто выполняется в двоичной системе счисления в соответствии с таблицей вычитания\n\n\\[0 - 0 = 0 \\\\ 1 - 0 = 1 \\\\ 1 - 1 = 0 \\\\ 10 - 1 = 1\\]\n\n15\n\nВ последнем примере, выполняя вычитание (0—1), обращаемся к единице займа из старшего разряда."},{"tag":"умножение в двоичной системе","text":"**Умножение.** Для выполнения операции умножения, а также деления необходимо знание таблицы умножения в соответствующей системе счисления.\n\nНаиболее проста таблица умножения в двоичной системе счисления\n\n\\[\\begin{array}{c|cc} a_i & b_i \\\\ \\hline & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 1 & 0 & 1 \\\\ \\end{array}\\]\n\nСоответственно упрощается выполнение операции умножения. Действительно, каждый разряд множителя может принимать значение либо 0, либо 1, поэтому при умножении требуется просуммировать множимое, сдвинутое на соответствующее количество разрядов, столько раз, сколько единиц содержится в множителе."},{"tag":"деление в двоичной системе","text":"**Деление.** Методика выполнения операции деления чисел в любой системе счисления остается такой же, как и в десятичной.\n\nВ двоичной системе счисления операция деления \\(n\\)-разрядных чисел также упрощается. Трудоемкий этап сравнения делителя с \\(n\\) или \\(n + 1\\) разрядами делимого, основанный на использовании операции умножения, можно заменить операцией вычитания. Действительно, цифра частичного при \\(p = 2\\) может принимать только значения 1 или 0, причем значению 1 соответствует неотрицательная разность (делимое больше или равно делителю) и 0 — отрицательная (делимое меньше делителя)."},{"tag":"оценка объёма оборудования по основанию системы счисления","text":"### Оценка объёма оборудования для представления чисел в зависимости от основания системы счисления\n\nДопустим, что имеется \\(n\\) разрядов для изображения числа в \\(p\\)-ичной системе счисления. В этом случае максимальное число \\(M\\) будет отвечать выражению\n\n\\[M = p^n - 1 \\approx p^n.\\]\n\n(2-5)\n\nНаряду с величиной \\(M\\), являющейся мерой максимального количества информации, которое может быть представлено в \\(n\\) разрядах, оценим число элементов \\(N\\), необходимое для изображения числа \\(M\\):\n\n\\[N = pn.\\]\n\n(2-6)\n\nРавенство (2-6) справедливо при условии, что для изображения каждого из допустимых в некотором разряде символов (цифр) требуется один элемент.\n\n16"},{"tag":"оптимальное основание системы счисления","text":"Определим \\(N\\) как функцию от \\(p\\) и \\(M\\). Из равенства (2-5) следует, что \\(n = \\ln M / \\ln p\\); подставляя это выражение в (2-6), получаем \\(N = p \\ln M / \\ln p\\). Используя полученную зависимость, можно найти основание системы счисления, при которой требуется минимум оборудования. Так, определив \\(dN/dp = N'\\) и приравняв ее к нулю, получим экстремум при \\(p = e\\), так как \\(N' = \\ln M \\frac{\\ln p - 1}{\\ln^2 p}\\).\n\nХарактер экстремума соответствует минимуму, так как при \\(p = e N' > 0\\).\n\nТаким образом, система при \\(p = e\\) требует минимума оборудования. Но \\(p = 2, 7 \\ldots\\), т. е. не целое число. Поэтому на практике целесообразно использовать системы с \\(p = 3\\) или \\(p = 2\\). Эти системы согласно приведенной оценке практически равноценны, так как отношение\n\n\\[\\frac{N_2}{N_3} = \\frac{2 \\ln 3}{3 \\ln 2} \\approx 1,056.\\]\n\nПодобное сравнение десятичной и двоичной систем показывает, что десятичная система в 1,5 раза менее экономична двоичной, так как\n\n\\[\\frac{N_{10}}{N_2} = \\frac{10 \\ln 2}{2 \\ln 10} \\approx 1,5.\\]"},{"tag":"условия реализации двоичных цифр в ЭВМ","text":"Условия реализации оборудования для представления цифр в ЭВМ\n\nНаиболее удобны условия реализации двоичных цифр, так как физических процессов, имеющих два устойчивых состояния, гораздо больше, чем процессов с числом четко различимых состояний больше двух. Широко используется в практике построения ЭВМ намагниченное или размагниченное состояние магнитного материала, открытое или закрытое состояние полупроводниковых диодов и триодов. В таких процессах различие между их состояниями носит качественный, а не количественный характер, что обеспечивает надежную реализацию двоичных цифр."},{"tag":"преимущества двоичной системы счисления","text":"Таким образом, простота арифметических действий, минимум используемого оборудования для представления чисел и наиболее удобные условия реализации только двух устойчивых состояний определили применение двоичных систем счисления практически во всех существующих и проектируемых цифровых вычислительных машинах."},{"tag":"двоично‑десятичные системы и их применение","text":"Наряду с широким распространением двоичной системы счисления применяется (особенно в последнее время) и двоично‑десятичная система счисления. Применение этой системы счисления в большинстве случаев не исключает двоичную систему, а дополняет ее. Такой вывод проявляется в том, что в настоящее время серийные вычислительные машины и системы могут работать как в двоичной, так и в двоично‑десятичной системах. Примером являются «Минск-32», модели единой системы электронных вычислительных машин (ЕС ЭВМ). Такие решения оказывают значительное влияние на структуру и параметры арифметических устройств. Частичное применение для представления цифровой информации на тех или иных носителях характерно для восьмеричной, а иногда и шестнадцатеричной систем счисления."}],
[{"tag":"перевод целых чисел","text":"Перевод целых чисел. Допустим, число \\(N_p\\) в \\(p\\)-ичной системе счисления требуется перевести в \\(q\\)-иную систему счисления. Перевод осуществляется по следующему правилу. Путём последовательного деления числа \\(N_p\\) и его частных на \\(q\\) получаем в виде остатков деления \\(p\\)-ичные записи \\(q\\)-ичных цифр (начиная с младшей), необходимых для изображения числа \\(N_q\\). Первое полученное значение частного, меньшее \\(q\\), определяет старшую цифру числа \\(N_q\\), что фиксирует окончание перевода. Деление всегда должно производиться в исходной системе счисления. Пример: число 10000000000\\(_2\\) переводится в десятичную систему счисления (\\(p = 2\\), \\(q = 10 = 1010_2\\)) следующим образом:\n\\[\\begin{array}{ccc} \\text{1000000000} & 1010 \\\\ \\hline 1010 & \\text{1100110} & \\text{1010} \\\\ \\text{1100} & \\text{1010} & \\text{1010} \\\\ \\text{1010} & \\text{1011} & \\text{1010} \\\\ \\text{10000} & \\text{1010} & \\text{0000} \\\\ \\text{1010} & \\text{10 = 2} & \\\\ \\text{1100} & \\text{1010} & \\\\ \\text{1010} & \\text{100 = 4} & \\\\ \\end{array}\\]\n10000000000\\(_2\\) = 1024"},{"tag":"перевод дробей","text":"Перевод дробей. Допустим, правильную дробь \\(D_p\\), представленную в \\(p\\)-ичной системе счисления, требуется перевести в \\(q\\)-иную систему счисления.\nПеревод осуществляется по следующему правилу. Путём последовательного умножения числа \\(D_p\\) и дробных частей получающихся произведений на \\(q\\) получаем в виде целых частей \\(p\\)-ичные записи \\(q\\)-ичных цифр, начиная со старшей. Умножение выполняется в исходной \\(p\\)-ичной системе счисления.\nНиже показан перевод числа 0,31 в двоичную систему счисления (\\(p = 10, q = 2\\)):\n\\[\\begin{array}{c} 0,31 \\\\ \\times 2 \\\\ 0,62 \\\\ \\times 2 \\\\ 1,24 \\\\ \\times 2 \\\\ 0,48 \\\\ \\times 2 \\\\ 0,96 \\\\ \\times 2 \\\\ 1,92 \\\\ \\times 2 \\\\ 1,84 \\\\ \\times 2 \\\\ 1,68 \\quad 0,31_{10} = 0,0100111 \\ldots \\end{array}\\]\nИз этого примера следует, что перевод дробей в общем случае представляет бесконечный процесс, и поэтому он может быть осуществлён лишь приближённо. Число цифр в представлении \\(q\\)-ичного числа необходимо определять из условия, что точность числа в \\(q\\)-ичной системе счисления должна соответствовать точности числа в исходной \\(p\\)-ичной системе счисления. Такое условие может быть записано в виде равенства\n\\[p^{-n_p} = q^{-n_q},\\]\nоткуда\n\\[n_q = \\frac{n_p}{\\log_p q},\\]\nгде \\(n_p\\) и \\(n_q\\) — количество цифр в изображении \\(p\\)-ичного и \\(q\\)-ичного числа.\nНа практике обычно пользуются соотношением\n\\[n_q = E \\frac{n_p}{\\log_p q} + 1,\\]\nгде \\(E\\) — целая часть.\nДля уменьшения погрешности перевода в получаемом \\(q\\)-ичном изображении числа проводят округление по последнему разряду, используя правила, применяемые в десятичной системе счисления.\nВ окончательном результате значение последнего разряда после округления отбрасывается.\nВ соответствии с изложенным при переводе числа 0,31 в двоичную систему счисления необходимо получать \\(n_2 = E \\frac{2}{\\log_{10} 2} + 1 =\\)\n\\[= E \\frac{2}{0,3} + 1 = 7 \\ \\text{двоичных разрядов. Проводя округление по последнему разряду}\\]\n\\[\\begin{array}{c} 0,0100111 \\\\ + \\\\ - \\\\ 1 \\end{array}\\]\n\\[0,0101000,\\]\nполучаем окончательный результат 0,31 = 0,010100\\(_2\\), так как значение разряда, по которому проводится округление, отбрасывается."},{"tag":"перевод произвольных чисел","text":"Перевод произвольных чисел. Перевод чисел, имеющих целую и дробную части, производится в два этапа. Вначале осуществляется перевод целой части, а затем — дробной."},{"tag":"автоматический перевод в ЭВМ","text":"Из вышеизложенного очевидно, что перевод чисел из одной системы счисления в другую является достаточно трудоемким процессом. Но следует заметить, что в современных ЭВМ перевод в основном выполняется автоматически самой машиной по стандартным подпрограммам. К ручному переводу обращаются лишь в крайних случаях: для получения необходимого изображения некоторых специфических констант, контрольных кодов, необходимых для отладки программ, и в других сравнительно редких случаях."},{"tag":"перевод в двоично‑десятичную систему и обратно","text":"Перевод чисел из десятичной системы счисления в двоично‑десятичную и обратно. Этот перевод выполняется без обращения к арифметическим действиям и осуществляется заменой каждой десятичной цифры её двоичным эквивалентом (тетрадой) в соответствии с выбранной системой кодирования. При обратном переводе изображение исходного двоично‑десятичного числа разбивается на группы, состоящие из четырёх разрядов слева и справа от запятой. Затем каждый двоичный четырёхзначный эквивалент заменяется десятичной цифрой.\nДвоично‑десятичная система 8421 широко используется как промежуточная в машинах, оперирующих с числами в двоичной системе счисления. Вначале десятичное число при вводе в машину преобразуется без применения арифметических действий в двоично‑десятичную систему, а затем ЭВМ по стандартным подпрограммам (с применением арифметических операций) переводит полученный код в двоичную систему счисления. Аналогичен и обратный перевод: вначале при помощи машины получают из двоичного кода двоично‑десятичный код, который без арифметических действий преобразуется в обычное десятичное представление."}],
[{"tag":"представление чисел с фиксированной запятой","text":"В ЭВМ применяются два способа (формы) представления чисел: с фиксированной и плавающей запятой. Сущность этих способов иллюстрируется формулой (2-4): \\\\[X_p = \\\\pm p^m \\\\sum_{i=1}^n x_i p^{-i}.\\\\] \\\\[\\\\begin{array}{c|cccc} a) & 3 & z^{-1} & \\\\cdots & z^{-n} \\\\\\\\ \\hline & n+1 & & & \\\\\\\\ b) & 3 & z^{-1} & \\\\cdots & z^{-15} \\\\\\\\ \\end{array}\\\\] \\\\[\\\\begin{array}{c|cccc} a) & 3 & z^{-1} & \\\\cdots & z^{-31} \\\\\\\\ \\hline & 4 & байта (32 разряда) & & \\\\\\\\ c) & 3 & z^{n-1}z^{n-2} & \\\\cdots & z^n \\\\\\\\ \\end{array}\\\\] Фиксированная запятая (или естественная форма представления чисел) характеризуется значением \\\\(m =\\\\) const. В этом случае для всех чисел, с которыми оперирует машина, положение запятой постоянно. В большинстве действующих ЭВМ с естественной формой представления чисел принято \\\\(m = 0\\\\). При этом все числа, с которыми оперирует машина, меньше единицы и представлены в виде правильных дробей. Выражение (2-4) при \\\\(m = 0\\\\) имеет вид: \\\\[X_p = \\\\pm \\\\sum_{i=1}^n x_i p^{-i}.\\\\]"},{"tag":"диапазон значений фиксированной запятой (m=0)","text":"Для фиксированной запятой при \\\\(m = 0\\\\) разрядная сетка или формат числа в двоичной системе счисления имеет вид, изображенный на рис. 2-1, a. Здесь \\\\(n\\\\) разрядов (от \\\\(2^{-1}\\\\) до \\\\(2^{-n}\\\\)) используются для изображения цифровой части числа и один разряд для изображения знака (3). В рассматриваемом случае число \\\\[X = \\\\pm \\\\sum_{i=1}^n x_i \\\\cdot 2^{-i} = \\\\pm (x_1 \\\\cdot 2^{-1} + x_2 \\\\cdot 2^{-2} + \\\\ldots + x_n \\\\cdot 2^{-n}).\\\\] Из этого выражения следует, что \\\\(|X|_{\\\\text{макс}} = 0, 1 \\\\ldots 1 = 1-2^{-n}\\\\), а модуль минимального числа, не равного нулю, \\\\(|X|_{\\\\text{мин}} = 0, 0 \\\\ldots 01 = 2^{-n}\\\\). Соответственно диапазон чисел при \\\\(m = 0\\\\) в двоичной системе счисления определяется неравенством \\\\[0 \\\\leq |X| \\\\leq 1-2^{-n}.\\\\]"},{"tag":"форматы чисел в ЭВМ (байтовые)","text":"Начиная с вычислительных машин второго поколения форматы чисел в ЭВМ представляются кратными байту, восьмиразрядному двоичному коду. Так используется формат, кратный 2 и 4 байтам, которые изображены на рис. 2-1, 6 и 8. Во всех рассмотренных форматах могут изображаться числа, которые по своей абсолютной величине меньше единицы, что упрощает конструкцию, уменьшает объем оборудования арифметического устройства. Недостатком такого представления чисел является необходимость выполнения трудоемкого расчета масштабов в процессе подготовки задачи для решения на ЭВМ. С помощью расчета масштабов обеспечивается значение модулей исходных чисел, промежуточных и окончательных результатов меньше единицы."},{"tag":"представление чисел с фиксированной точкой (m=n)","text":"В ряде ЭВМ фиксированная запятая характеризуется значением \\\\(m = n\\\\). При этом веса разрядов в формате числа, содержащего \\\\(n + 1\\\\) разряд (один знаковый разряд), представлены на рис. 2-1, 8. В этом случае \\\\(|X|_{\\\\text{мин}} = 0, 0 \\\\ldots 01 = 2^0,\\\\) \\\\(|X|_{\\\\text{макс}} = 0, 1 \\\\ldots 1 = 2^n - 1.\\\\) Данный пример иллюстрирует другое широко используемое название рассматриваемого представления чисел с фиксированной точкой. Оно используется в моделях ЕС ЭВМ в форматах, кратных 2 байтам (полуслово) и 4 байтам (слово). При представлении чисел с фиксированной точкой (\\\\(m = n\\\\)) в случае выполнения арифметических действий над произвольными числами программист может принять любое условное положение запятой в пределах формата. Но при разработке программы он должен следить за положением запятя во время вычислений, чтобы не возникло переполнение."},{"tag":"представление чисел с плавающей запятой","text":"Необходимость расчета масштабов, обязанность программиста следить за положением запятя во время вычислений исключаются при втором способе представления чисел с плавающей запятой. Плавающая запятая (иногда называется нормальной формой представления чисел) определяется значением \\\\(m \\\\neq \\\\text{const}\\\\). В этом случае составляющая формула \\\\((2-4) \\\\pm \\\\sum_{i=1}^n x_i p^{-i} = \\\\pm (x_1 p^{-1} + x_2 p^{-2} + \\\\ldots + x_n p^{-n})\\\\) называется мантиссой, а \\\\(p^m\\\\) называется порядком или характеристикой числа. Значение \\\\(m\\\\) может быть как положительным, так и отрицательным. Представление числа с плавающей запятой можно проиллюстрировать на примере десятичной системы счисления. Числа 989,137 и 0,00989137 с плавающей запятой будут иметь следующий вид: \\\\[989,137 = 10^3 \\\\cdot 0,989137;\\\\] \\\\[989,137 = 10^4 \\\\cdot 0,0989137;\\\\] \\\\[0,00989137 = 10^{-2} \\\\cdot 0,989137;\\\\] \\\\[0,00989137 = 10^{-1} \\\\cdot 0,0989137.\\\\]"},{"tag":"форматы чисел с плавающей запятой","text":"Рис. 2-2. Форматы чисел с плавающей запятой. \\\\[\\\\begin{array}{|c|c|c|c|c|c|c|} \\\\hline a) & \\\\sigma_n & 2^n\\\\pi^2 & \\\\cdots & 2^n & \\\\sigma_M & Z^T & \\\\cdots & Z^{n_M} \\\\\\\\ \\hline & n_n & & & & & n_M & \\\\\\\\ \\hline & & & & & & & \\\\\\\\ \\hline \\end{array}\\\\] \\\\[\\\\begin{array}{|c|c|c|c|c|c|c|} \\\\hline b) & \\\\sigma_M & 2^6 & \\\\cdots & 2^0 & Z^T & \\\\cdots & Z^{2n} \\\\\\\\ \\hline & n_n = 7 & & & & 3 \\\\text{бд} \\\\text{пп} a = n_M & \\\\\\\\ \\hline & 1 \\\\text{бд} \\\\text{пп} & & & & & \\\\\\\\ \\hline \\end{array}\\\\] a — изображение порядков положительными и отрицательными числами; b и c — изображение порядков в соответствии с формулой (2-11)."},{"tag":"нормализованное число","text":"В целях однозначного представления любого числа введено понятие «нормализованное число». Нормализованным считается то число, мантисса которого удовлетворяет неравенству вида \\\\[1 > \\\\left| \\\\sum_{i=1}^n x_i p^{-i} \\\\right| \\\\geq p^{-1}.\\\\] (2-7)."}],
[{"tag":"нормализованное число","text":"Другими словами, нормализованным числом является то, у которого \\(x_1 \\neq 0\\). Например, число \\(10^{-2} \\cdot 0,989137\\) является нормализованным. Но это же число в виде \\(10^{-1} \\cdot 0,0989137\\) — ненормализованное, так как мантисса его не удовлетворяет неравенству (2-7), поскольку \\(x_1 = 0\\)."},{"tag":"формат числа с плавающей запятой в двоичной системе","text":"Формат чисел для плавающей запятой в двоичной системе счисления изображен на рис. 2-2. В данном случае \\(n_M\\) разрядов (от \\(2^{-1}\\) до \\(2^{-n_M}\\)) используется для изображения мантиссы и \\(n_n\\) разрядов для изображения порядка числа (один разряд \\(\\sigma_n\\) — знак порядка и разряды с весами от \\(2^0\\) до \\(2^n-2\\)—код порядка). В разрядной сетке предусмотрено наличие разряда для фиксации знака мантиссы, который соответствует знаку числа \\(3м\\)."},{"tag":"диапазон представимых чисел","text":"Оценим диапазон чисел для плавающей запятой. Здесь число\n\\[X_p = \\pm 2^m \\sum_{i=1}^{n_M} x_i \\cdot 2^{-i} = \\pm 2^m (x_1 \\cdot 2^{-1} + x_2 \\cdot 2^{-2} + \\ldots + x_{n_M} \\cdot 2^{-n_M}) \\quad . \\tag{2-8}\\]\nИз выражения (2-8) следует, что\n\\[\\begin{cases} |X|_{макс} = 2^{m_{макс}} \\cdot 0, 1 \\ldots , 1 = 2^{m_{макс}} (1 - 2^{-n_M}) ; \\\\ |X|_{мин} = 2^{-m_{макс}} \\cdot 0, 10 \\ldots , 0 = 2^{-m_{макс}} \\cdot 2^{-1}. \\end{cases} \\tag{2-9}\\]\nПоследнее равенство справедливо для нормализованных чисел. В этих двух равенствах \\(|m_{макс}| = 2^n-1 - 1\\)."},{"tag":"диапазон представимых чисел","text":"Соответственно диапазон чисел при представлении чисел с плавающей запятой определяется неравенством\n\\[2^{2^n-1} > |X_{p=2}| > 2^{-2^n-1} \\quad . \\tag{2-10}\\]"},{"tag":"погрешность представления чисел","text":"Значительные отличия имеют рассматриваемые способы в точности представления чисел. В случае применения фиксированной запятой все числа имеют одинаковую максимальную абсолютную погрешность \\(\\Delta X_{\\Phi.3} = 2^{-n}\\), но равную относительную погрешность \\(\\delta X_{\\Phi.3}\\), предельные значения которой определяются неравенством\n\\[\\frac{2^{-n}}{1 - 2^{-n}} \\approx 2^{-n} < \\delta X_{\\Phi.3} \\leq \\frac{2^{-n}}{2^{-n}} = 1.\\]\nВ случае плавающей запятой абсолютная погрешность чисел непостоянна и равна \\(\\Delta X_{n.3} = 2^{\\pm m} \\cdot 2^{-n_M}\\). Здесь значение максимальной абсолютной погрешности мантиссы, равное \\(2^{-n_M}\\), корректируется значением порядка числа.\nМаксимальное значение относительной погрешности определяется выражением\n\\[\\delta X_{n.3. макс} = \\frac{2^{\\pm m} \\cdot 2^{-n_M}}{2^{\\pm m} \\cdot 0, 1} = 2^{-n_M+1},\\]\nгде \\(2^{\\pm m} \\cdot 2^{-n_M}\\) — абсолютная погрешность; \\(2^{+m} \\cdot 0, 1\\) — минимальное абсолютное значение числа, которое определяется минимальной нормализованной мантиссой, равной \\(0, 10 \\ldots , 0 = 2^{-1}\\).\nМинимальное значение относительной погрешности определяется выражением\n\\[\\delta X_{n.3. мин} = \\frac{2^{\\pm m} \\cdot 2^{-n_M}}{2^{\\pm m} \\cdot 0, 1 \\ldots , 1} \\approx 2^{-n_M}.\\]"},{"tag":"кодирование порядка (экспоненты) в плавающей точке","text":"24\nПри изложенном представлении числа с плавающей запятой код порядка чисел может иметь как отрицательное, так и положительное значение и изменяется от — \\( (2^n n^{-1} - 1) \\) до \\( (2^n n^{-1} - 1) \\). При этом число, равное нулю, имеет код порядка, меньший или равный — \\( 2^n n^{-1} \\) (подробнее см. § 2-6).\nВ ряде ЭВМ кодирование порядка производится несколько отличным образом. Порядок числа \\( m_u \\) в машине изображается в виде\n\\[m_u = m_u + 2^n n^{-1}.\\]\n(2-11)\nВ соответствии с равенством (2-11) все порядки в машине изображаются положительными числами, изменяющимися от 0 ... 0 до 1 ... 1 = \\( 2^n n - 1 \\). При этом машинное изображение порядка \\( m_u = 0 ... 0 \\) соответствует \\( m_u = -2^n n^{-1} \\), \\( m_u = 2^n n^{-1} \\) соответствует \\( m_u = 0 ... 0 \\), а \\( m_u = 2^n n - 1 \\) соответствует \\( m_u = 2^n n^{-1} - 1 \\).\n\\[\\begin{array}{ccc} & & \\\\ -(2^n n^{-1}) = -i0...0 & 00...00 & 2^n n^{-1} = 01...11 \\\\ & & \\\\ 00...00 & 2^n n^{-1} = i0...0 & 2^n n^{-1} = 1...1 \\\\ \\end{array}\\]\nРис. 2-3. Иллюстрация диапазонов изменения порядков чисел и их машинных изображений\nВсе сказанное иллюстрируется изображением порядков чисел и их машинных изображений, показанных на рис. 2-3. Машинное изображение порядка \\( m_u \\) иногда называется характеристикой числа.\nПри таком кодировании число, равное нулю, в разрядной сетке числа как мантиссы, так и порядка имеет код 00 ... 00."},{"tag":"альтернативная форма представления числа с плавающей запятой","text":"В практике построения ЭВМ применяется также несколько изменения форма представления числа с плавающей запятой. Ее можно иллюстрировать следующей формулой, аналогичной формуле (2-4):\n\\[X_{2k} = \\pm (2^k)^m \\sum_{t=1}^l b_t (2^k)^{-t},\\]"}],
[
    {
        "tag": "условие нормализации мантиссы",
        "text": "(2-12) здесь \\( l \\) — количество \\( 2^k \\)-ичных цифр мантиссы, и при \\( k = 2, 3, 4 \\) имеем дело с четверичной, восьмеричной и шестнадцатеричной системами счисления. Значение \\( k > 4 \\) на практике не встречается. Каждая цифра мантиссы \\( b_t \\) изображается соответствующим двух-, трех- или четырехзначным двоичным эквивалентом. При таком представлении чисел нормализованным числом считается то, мантисса которого удовлетворяет следующему неравенству:\n\n\\[1 > \\sum_{t=1}^l b_t (2^k)^{-t} > \\frac{1}{2^k}.\\]\n\n25"
    },
    {
        "tag": "минимальная нормализованная мантисса",
        "text": "В соответствии с этим неравенством минимальная нормализованная мантисса равна \\(2^{-k}\\), т. е. имеет вид:\n\n\\[0,0 \\ldots 010 \\ldots 0.\\]\n\n\\(k\\) разрядов"
    },
    {
        "tag": "диапазон относительных ошибок",
        "text": "В этом представлении числа приблизительно в \\(2^k\\) раз увеличивается диапазон изменения относительных ошибок чисел, увеличивается диапазон чисел, который оценивается следующим неравенством:\n\n\\[(2^k)^{n-1} > X_{2^k} > (2^k)^{-2}\\]\n\n(2-13)"
    },
    {
        "tag": "применение в моделях ЕС ЭВМ",
        "text": "В частности, для моделей ЕС ЭВМ используется рассматриваемое представление чисел и машинное изображение порядков кодами, изменяющимися от \\(0 \\ldots 0\\) до \\(2^n - 1\\). При этом \\(k = 4\\), количество разрядов, отводимых на характеристику (порядок), \\(n_n = 7\\), и диапазон определяется как \\(10^{+76} > X > 10^{-76}\\). При плавающей запятой с двоичной системой счисления (\\(k = 1\\)) и \\(n_n = 7\\) диапазон чисел соответствовал \\(10^{19} > X > 10^{-19}\\)."
    },
    {
        "tag": "преимущество скорости сложения",
        "text": "Одно из преимуществ представ"}],
[{"tag":"обратный код","text":"Обратный код. В этом коде связь между числом \\(х\\) и его изображением в обратном коде — \\([x]_0\\) определяется равенством \\\\[[x]_0 = \\\\begin{cases} x, & \\\\text{если } x \\\\geq 0; \\\\\\\\ 2 - x - 2^{-n}, & \\\\text{если } x \\\\leq 0. \\\\end{cases} \\\\tag{2-15}\\\\] В соответствии с равенством (2-15) положительное число не меняет своего изображения в обратном коде, а получение обратного кода отрицательного числа связано с выполнением операции вычитания. Такая методика нерациональна, так как \\\\[[-0, x_1 \\\\ldots x_n]_0 = 1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n. \\\\tag{2-16}\\\\] Таким образом, для отрицательного числа получение обратного кода заключается в присвоении знаковому разряду кода 1 и замене 0 на 1, а 1 на 0 (выполняется \\\\(\\\\bar{x}_i)\\\\) в цифровой части числа. Справедливость такого преобразования можно показать следующим образом. Подставим значение равенства (2-16) в (2-15): \\\\[[-0, x_1 \\\\ldots x_n]_0 = 1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n = 2 - 0, x_1 \\\\ldots x_n - 2^{-n} \\\\text{ или } 1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n = 1, 11 \\\\ldots 1 - 0, x_1 \\\\ldots x_n = 2 - 2^{-n} - 0, x_1 \\\\ldots x_n.\\\\] Так как \\\\(\\\\bar{x}_i + x_i = 1)\\\\, то \\\\[1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n + 0, x_1 \\\\ldots x_n = 1, 11 \\\\ldots 1 = 2 - 2^{-n}.\\\\] Получение этого равенства является доказательством преобразования в соответствии с равенством (2-16). Обратное преобразование (от обратного к прямому) осуществляется следующим образом: \\\\[[[[-0, x_1 \\\\ldots x_n]_0]_0 = [1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n]_0 = 1, x_1 \\\\ldots x_n,\\\\] т. е. от обратного кода берется обратный код."},{"tag":"дополнительный код","text":"Дополнительный код. Здесь связь между числом \\\\(X\\\\) и его изображением в дополнительном коде \\\\([X]_n\\\\) определяется равенством \\\\[[X]_n = \\\\begin{cases} X, & \\\\text{если } X \\\\geq 0; \\\\\\\\ 2 + X, & \\\\text{если } X < 0. \\\\end{cases}\\\\] Получение дополнительного кода осуществляется в соответствии с равенством \\\\[[-0, x_1 \\\\ldots x_n]_n = 1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n + 2^{-n} = [1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n]_n.\\\\] Справедливость такого преобразования показывается так же, как и для обратного кода. Обратное преобразование (от дополнительного к прямому) выполняется следующим образом: \\\\[[[[-0, x_1 \\\\ldots x_n]_n]_n = [1, \\\\bar{x}_1 \\\\ldots \\\\bar{x}_n + 2^{-n}]_n = 1, x_1 \\\\ldots x_n,\\\\] например \\\\([[-0,1101]_n = [1,0011]_n = 1,1101\\\\), т. е. от дополнительного кода берется дополнительный."},{"tag":"алгебраическое суммирование в обратном и дополнительном кодах","text":"Методика алгебраического суммирования в обратном и дополнительном кодах при представлении исходных чисел и суммы в прямом коде. Для обоснования этой методики разберем четыре случая, исчерпывающие все возможные комбинации, которые могут встретиться при операции сложения. Рассмотрим вначале использование обратного кода.\\n\\n1) \\\\(X>0\\\\) и \\\\(Y>0\\\\), а \\\\(X + Y < 1\\\\). В данном случае обращение к обратному коду не приводит к специфике выполнения операции, так как \\\\([X>0]_0 + [Y>0]_0 = X + Y\\\\).\\n\\n2) \\\\(X > 0\\\\), \\\\(Y < 0\\\\) и \\\\(X + Y > 0\\\\). Здесь в операции сложения участвуют \\\\([X]_0 + [Y]_0 = X + 2 + Y - 2^{-n}\\\\). Назовем этот результат предварительным. Действительный результат равен \\\\(X + Y\\\\) (см. условия данного случая). Для того чтобы от предварительного результата перейти к действительному, необходима коррекция: вычесть 2 и прибавить \\\\(2^{-n}\\\\) к предварительному результату.\\n\\nПример:\\n\\n\\\\[ [X]_n = 0,1101 \\\\quad [X]_0 = 0,1101 \\\\]\\\\n\\\\[ [Y]_n = 1,1001 + [Y]_0 = 1,0110 \\\\]\\\\n\\\\[ \\\\begin{array}{c} 10,0011 - \\\\text{предварительный} \\\\\\\\ \\\\text{результат} \\\\\\\\ + 1 \\rightarrow 1 \\\\quad \\\\text{коррекция} \\\\\\\\ 0,0100 - \\\\text{правильный результат} \\\\end{array} \\\\]Выполнение коррекции: в предварительном результате исключается 1 в разряде с весом 2\\(^1\\), что равноценно вычитанию 2, и эту же единицу направляем в младший разряд предварительного результата, что равноценно прибавлению \\\\(2^{-n}\\\\).\\n\\n3) \\\\(X > 0\\\\), \\\\(Y < 0\\\\) и \\\\(X + Y < 0\\\\). Суммируем \\\\([X]_0 + [Y]_0 = X + +2 + Y - 2^{-n}\\\\). Этот результат соответствует правильному, так как согласно условиям \\\\(X + Y < 0\\\\) и \\\\([X + Y < 0]_0 = 2 + X + + Y - 2^{-n}\\\\).\\n\\nПример:\\n\\n\\\\[ [X]_n = 0,1001 \\\\quad [X]_0 = 0,1001 \\\\]\\\\n\\\\[ [Y]_n = 1,1101 + [Y]_0 = 1,0010 \\\\]\\\\n\\\\[ \\\\begin{array}{c} 1,1011 = [X + Y < 0]_0. \\\\end{array} \\\\]Осуществляя преобразование \\\\([1,1011]_0 = 1,0100\\\\), получаем прямой код результата.\\n\\nПри суммировании чисел разных знаков возможно получение \\\\(X + Y = 0\\\\). Здесь методика суммирования обратных кодов исходных чисел не изменяется, а результат получается в виде 1,1 ...1. Например,\\n\\n\\\\[ [X]_n = 0,1011 \\\\quad [X]_o = 0,1011 \\\\] \\\\[ [Y]_n = 1,1011 \\\\quad + [Y]_o = 1,0100 \\\\]\\n\\\\[ \\\\frac{[X + Y]_o}{1} = 1,111 \\\\]Получили обратный код отрицательного нуля \\\\([-0,0 ...0]_o = 1,1 ...1\\\\). Такой результат согласуется с формулой (2-15), где указано, что \\\\(X = 0\\\\) может иметь двоякое изображение: код положительного нуля и код отрицательного нуля.\\n\\n4) \\\\(X < 0\\\\), \\\\(Y < 0\\\\) и \\\\(|X + Y| < 1\\\\). Результат суммирования \\\\([X]_o + [Y]_o = 2 + X - 2^{-n} + 2 + Y - 2^{-n}\\\\) дает предварительный результат, который отличается от правильного \\\\([(X + + Y) < 0]_o = 2 + X + Y - 2^{-n}\\\\) на \\\\(2 - 2^{-n}\\\\). Это определяет необходимость выполнения коррекции предварительного результата, которая аналогична рассмотренной в случае 2.\\n\\nПример:\\n\\n\\\\[ [X]_n = 1,0101 \\\\quad [X]_o = 1,1010 \\\\] \\\\[ [Y]_n = 1,0111 + [Y]_o = 1,1000 \\\\]\\n\\\\[ \\\\frac{11,0010}{+1 \\rightarrow 1} \\\\]\\n\\\\[ \\\\frac{1,0011}{= [X + Y < 0]_o} \\\\]Прямой код результата \\\\([1,0011]_o = 1,1100\\\\).\\n\\nНетрудно показать, что для любой пары чисел, удовлетворяющих случаям 2 и 4, в предварительном результате суммирования \\\\([X]_o + [Y]_o\\\\) всегда будет 1 в разряде с весом 2\\(^1\\). Это является основой машинной коррекции: 1 с весом 2\\(^1\\) в предварительном результате исключается и передается по так называемой цепи кругового переноса на сложение в младший разряд суммы."}],
[{"tag":"суммирование в обратном коде","text":"Из изложенного также следует, что при суммировании чисел в обратном коде:\nобработка знаковых и цифровых разрядов чисел осуществляется по одинаковым правилам, и при этом автоматически получается правильный знак результата;\nисключена операция прямого вычитания."},{"tag":"алгебраическое суммирование в дополнительном коде","text":"Алгебраическое суммирование чисел в дополнительном коде.\nРассмотрим четыре случая:\n1) \\(X > 0\\), \\(Y > 0\\), а \\(X + Y < 1\\). Как и при обратном коде, суммирование дополнительных кодов не вносит каких-либо изменений в операцию сложения.\n2) \\(X > 0\\), \\(Y < 0\\) и \\(X + Y > 0\\). Суммируются \\([X]_n + [Y]_n = X + 2 + Y\\). Полученный результат отличается от правильного \\(X + Y > 0\\) на 2. Необходима соответствующая коррекция.\nПример: \\([X]_n = 0,1001\\) \\([Y]_n = 1,0001\\) + \\([Y]_n = 1,1111\\)\n10,1000\n— получен предварительный результат. Выполняя коррекцию, равную вычитанию 2 из предварительного результата (исключение в нем 1 с весом 2\\^1), получаем правильный результат 0,1000.\nМетодика выполнения операции не изменяется, когда \\([X]_n + + [Y]_n = 0\\). Например,\n\\([X]_n = 0,1100 + [X]_n = 0,1100\\) \\([Y]_n = 1,1100 + [Y]_n = 1,0100\\)\n0,0000\n3) \\(X > 0\\), \\(Y < 0\\) и \\(X + Y < 0\\). Здесь \\([X]_n + [Y]_n = X + + 2 + Y\\) дает правильный результат, как и при обратном коде, без коррекции.\n4) \\(X < 0\\), \\(Y < 0\\) и \\(|X + Y| < 1\\). Суммируя \\([X]_n + [Y]_n = -2 + X + 2 + Y\\), получаем результат, который отличается от правильного \\([(X + Y) < 0]_n = 2 + X + Y\\) на 2. Необходима и здесь коррекция, рассмотренная в случае 2.\nОтличие методики суммирования чисел в дополнительном коде от методики в обратном заключается лишь в сущности коррекции. В сумме дополнительных кодов исключается только 1 с весом 2\\^1, и цепь кругового переноса здесь исключена. Кроме указанного, все выводы, сделанные для методики суммирования в обратном коде, справедливы и для дополнительного."},{"tag":"недостаток фиксирования переполнения","text":"Для обеих рассмотренных методик характерен общий недостаток — они не позволяют фиксировать переполнение. Это видно из следующего примера, где \\(X < 0\\), \\(Y < 0\\), а \\(|X + Y| > 1\\):\n\\([X]_n = 1,1101 + [X]_n = 1,0011\\) \\([Y]_n = 1,1010 + [Y]_n = 1,0110\\)\n10,1001\nПосле коррекции получаем неправильный результат 0,1001 (суммировали два отрицательных числа, а сумма получилась положительной). Этот недостаток исключается при использовании модифицированных дополнительного и обратного кодов."},{"tag":"модифицированные коды","text":"Модифицированные дополнительный и обратный коды и их использование в операции алгебраического суммирования. Изображение числа \\(X\\) в этих кодах \\([X]_n^M\\) и \\([X]_n^M\\) определяется равенствами\n\\[[X]_n^M = \\begin{cases} X, & \\text{если } X \\geq 0; \\\\ 4 + X, & \\text{если } X < 0; \\end{cases}\\]\n\\[[X]_n^M = \\begin{cases} X, & \\text{если } X \\geq 0; \\\\ 4 + X - 2^{-n}, & \\text{если } X \\leq 0. \\end{cases}\\]\n31\nНетрудно показать, что\n\\[[-0, x_1 \\ldots x_n]^M = 11, \\; x_1 \\ldots x_n\\]\n\\[[-0, x_1 \\ldots x_n]^M = 11, \\; \\bar{x}_1 \\ldots \\bar{x}_n + 2^{-n} = [-0, x_1 \\ldots x_n]^M + 2^{-n}\\]\nИз приведенных равенств очевидно отличие модифицированных кодов от обычных. Они имеют два знаковых разряда. Это своеобразная избыточность, сохраняя все качества обычных дополнительного и обратного кодов, дополняет их способностью фиксировать переполнение.\nПри этом несколько изменяется и коррекция: вместо исключения в предварительном результате 1 с весом \\(2^1\\) здесь будет исключаться 1 с весом \\(2^2\\), что соответствует уменьшению результата \\([X]_R^M \\circ + [Y]_R^M \\circ\\) на \\(100 = 2^2\\)."}],
[{"tag":"фиксация переполнения в знаковых разрядах","text":"Возможность однозначной фиксации переполнения иллюстрируется табл. 2-2, в которой положительное переполнение \\(X + Y > 1\\) фиксируется кодом 01 в знаковых разрядах суммы, а отрицательное переполнение кодом 10. Исключением из этого правило является случай суммирования дополнительных кодов двух отрицательных чисел, когда \\(|X + Y| = 1\\). Здесь \\([X]_R^+ + [Y]_R^- = 11,0 \\ldots 0\\). Во всех остальных случаях, когда \\(|X + Y| < 1\\), коды в знаковых разрядах суммы совпадают. Знак суммы правильно фиксируется старшим знаковым разрядом. Справедливость такого утверждения можно иллюстрировать анализом соответствующих частных случаев."},{"tag":"пример переполнения при X>0, Y>0","text":"Допустим, имеет место случай \\(X>0\\), \\(Y>0\\) и \\(X+Y>1\\). Тогда \\([X]_{x_0}^M + [Y]_{x_0}^M = 01, \\ldots\\). Например: \\[\\[X\\]_n = 0,1011\\] \\[\\[Y\\]_n = 0,1010\\] \\[\\frac{[X]_{x_0}^M}{[Y]_{x_0}^M} = 00,1011\\] \\[\\frac{[Y]_{x_0}^M}{[Y]_{x_0}^M} = 00,1010\\] 01,0101"},{"tag":"пример переполнения при X<0, Y<0","text":"В случае \\(X<0\\), \\(Y<0\\) и \\(|X+Y|>1\\) в результате суммирования \\([X]_{x_0}^M + [Y]_{x_0}^M = 10, \\ldots\\) получаем несовпадающие коды в знаковых разрядах. Например: \\[\\[X\\]_n = 1,1011\\] \\[\\[Y\\]_n = 1,1010\\] \\[\\frac{[X]_{x_0}^M}{[Y]_{x_0}^M} = 11,0100\\] \\[\\frac{[Y]_{x_0}^M}{[Y]_{x_0}^M} = 11,0101\\] 110,1001 \\[+1 \\rightarrow 1\\] 10,1010 Здесь осуществлена коррекция, в предварительном результате суммы исключена 1 в разряде с весом \\(2^2\\) и прибавлено \\(2^{-4}\\). Окончательный результат \\([X+Y<0]_{x_0}^M=10,1010\\), что соответствует \\(-1,0101\\) обычной записи отрицательного двоичного числа."},{"tag":"логическая схема определения знака суммы","text":"В соответствии с таблицей можно составить логическое уравнение \\(A\\), равенство которого единице будет соответствовать передаче кода \\(|Y|\\). Это уравнение имеет вид: \\[A = \\overline{3}_x \\land \\overline{3}_y \\land \\overline{3}_z \\lor 3_x \\land 3_y \\land \\overline{3}_x \\lor 3_z \\land 3_y \\land 3_A\\] Если значение \\(A = 0\\), то осуществляется передача \\([-|Y|]_{A.0}\\). В рассматриваемой методике знак суммы формируется автономно в соответствии со следующими логическими выражениями. Если \\(A = 1\\), то знак суммы \\(3_s = 3_x\\). Если \\(A = 0\\), то \\(3_s = 3_x\\), когда \\(|X| - |Y| = S \\geq 0\\), т. е. \\(3_s = 0\\) (здесь \\(3_s\\) — код знакового разряда суммы, получающийся в результате вычитания или сложения модулей слагаемых), и \\(3_s = \\overline{3}_x\\), когда \\(|X| - |Y| = S < 0\\), т. е. \\(3' = 1\\). Указанные условия описываются элементарной логической функцией \\(3_s = 3_x \\oplus 3'_s\\). Таким образом, \\[3_s = A \\land 3_x \\lor \\overline{A} \\land (3_x \\oplus 3'_s).\\] При данной методике переполнение имеет место тогда, когда \\(\\varphi = A \\land 3'_s = 1\\). Это возможно при условии сложения модулей, когда \\(|X| + |Y| \\geq 1\\). Преобразование дополнительного или обратного кода отрицательного результата \\([(|X| - |Y|) < 0]_{A.0}\\) в прямой должно осуществляться при \\(\\psi = \\overline{A} \\land 3'_s = 1\\). Это равенство выполняется при \\(|X| - |Y| < 0\\)."},{"tag":"пример 1 алгебраического сложения","text":"**Пример 1:** \\[\\[X\\]_n = 1,0110\\] \\[\\[Y\\]_n = 1,0011\\] Так как \\(A = 1\\) (\\(3_x = 3_y = 1\\), \\(3_A = 0\\)), то суммируем модули слагаемых: \\[\\begin{align*} &+ |X| = 0,0110 \\\\ &|Y| = 0,0011 \\end{align*}\\] \\(S = 0,1001\\) Определяем знак суммы \\(3_s = 3_x = 1\\), так как \\(A \\land 3_x = 1\\). Переполнение отсутствует, так как \\(\\varphi = 0\\), поскольку \\(3_s = 0\\). Окончательный результат \\([S]_n = 1,1001\\)."},{"tag":"пример 2 алгебраического сложения","text":"**Пример 2:** \\[ [X]_n = 0,0110, \\] \\[ [Y]_n = 0,1011 \\]"}],
[
    {
        "tag": "пример сложения‑вычитания (пример 2)",
        "text": "Так как \\[ A = 1 \\ (3_x = 3_y = 0, 3_A = 1), \\] то вычитаем модули слагаемых:\\n\\[ |X| = 0,0110 \\] \\[ [-|Y|]_o = 1,0100 \\] \\[ [S < 0]_o = 1,1010 \\]\\nОпределяем знак суммы \\[ -3_s = 1, \\] так как \\[ A \\land (3_x \\oplus 3_s') = 1 \\]\\nПереполнение в данном случае не может быть. Поскольку \\[ \\psi = \\bar{A} \\land 3_s' = 1, \\] то необходимо преобразование обратного кода результата в прямой. Окончательный результат \\[ [S]_n = 1,0101. \\]"
    },
    {
        "tag": "пример сложения‑вычитания (пример 3)",
        "text": "Пршмер 3: \\[ [X]_n = 1,1010, \\] \\[ [Y]_n = 0,1101 \\]\\nТак как \\[ A = 1 \\ (3_x = 1, 3_y = 0, 3_A = 1), \\] то суммируем модули слагаемых:\\n\\[ |X| = 0,1010 \\] \\[ + |Y| = 0,1101 \\] \\[ S = 1,0111 \\]\\nОпределяем знак суммы \\[ 3_s = 1, \\] так как \\[ A \\land 3_x = 1. \\] В данном случае имеет место переполнение, так как \\[ \\varphi = A \\land 3_s' = 1, \\] поскольку \\[ 3_s' = 1. \\]"
    },
    {
        "tag": "методика выполнения сложения‑вычитания",
        "text": "Рассмотренная методика позволяет выполнить операцию сложения—вычитания без обращения к модифицированным дополнительному или обратному кодам.\\nМетодика выполнения сложения—вычитания при представлении слагаемых и суммы в дополнительном и обратном кодах. В этом случае операция сложения будет выполняться как сложение исходных дополнительных или обратных кодов слагаемых без какого-либо преобразования, т. е.\\n\\[ [X]_n^M + [Y]_n^M = [S]_n^M. \\]\\nОперация вычитания будет выполняться как сложение, но второе слагаемое будет участвовать в операции в преобразованном виде, т. е.\\n\\[ [X]_n^M. o + [-|Y]_n. o]_n^M. o = [S]_n^M. o. \\]\\nПреобразование второго слагаемого заключается в изменении его знака на обратный и преобразовании кода цифровых разрядов из прямого кода в дополнительный или обратный для исходного \\[ Y \\geq 0 \\] или из дополнительного или обратного кода в прямой для исходного \\[ Y < 0. \\] В этой методике исключено преобразование дополнительного или обратного кода отрицательного результата в прямой."
    },
    {
        "tag": "условия переполнения при сложении",
        "text": "Если при \\([X]_{x_0} \\pm [Y]_{x_0} > 0\\) возникает сигнал переноса из старшего разряда суммы (перенос из разряда с весом \\(2^{-1} - P_{2^{-1}}\\)), то переполнение 1, . . . , так как \\(3_x + 3_y + P_{2^{-1}} = 0 + 0 + 1 = 1\\).\\nЭтому случаю соответствует логическое условие \\(3_x \\wedge 3_y \\wedge P_{2^{-1}} = 1\\).\\nЕсли при \\([X]_{x_0} + [Y]_{x_0} < 0\\) не возникает \\(P_{2^{-1}}\\), то переполнение 10, . . . , так как \\(3_x + 3_y + P_{2^{-1}} = 1 + 1 + 0 = 10\\). Этому случаю соответствует логическое условие \\(3_x \\wedge 3_y \\wedge P_{2^{-1}} = 1\\)."
    },
    {
        "tag": "методика выполнения умножения над прямыми кодами",
        "text": "Рассмотрение операции сложения—вычитания показало, что представление исходных чисел и результатов в прямом или дополнительном, обратном коде оказывает влияние на методику выполнения операции. Такое же положение характерно и для операции умножения.\\n**Методика выполнения умножения над прямыми кодами исходных чисел.** Условие выполнения операции: \\([X]_n = 3_x, x_1, . . . x_n\\), \\([Y]_n = 3_y, y_1, . . . y_n\\). Если рассматривается фиксированная запятая при \\(m = 0\\), то \\(|X| < 1\\) и \\(|Y| < 1\\); требуется получить \\([Z]_n = [X]_n, [Y]_n = 3_z, z_1, . . . z_n\\).\\n\\[\\begin{array}{c|c|c} 3_x & 3_y & 3_z \\\\ \\hline 0 & 0 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 0 \\\\ \\end{array}\\]\\nОперация выполняется в два этапа. Отдельно определяется \\(3_z\\) в соответствии с приводимой таблицей истинности. Эта таблица описывает элементарную логическую функцию—сложение по модулю 2. Таким образом, \\(3_z = 3_x \\oplus 3_y\\).\\nЗатем определяется цифровая часть произведения путем перемножения цифровых частей сомножителей с нулевыми знаковыми разрядами. Процесс умножения можно представить в следующем виде:\\n\\[Z = XY = X\\left(y_1 \\cdot 2^{-1} + y_2 \\cdot 2^{-2} + . . . + y_{n-1} \\cdot 2^{-n+1} + y_n \\cdot 2^{-n}\\right) = X \\cdot 2^{-1} \\cdot y_1 + X \\cdot 2^{-2} \\cdot y_2 + . . . + X \\cdot 2^{-n+1} \\cdot y_{n-1} + X \\cdot 2^{-n} \\cdot y_n.\\]\\nЭто же выражение после преобразования по схеме Горнера представляется в виде\\n\\[Z = \\left( \\left( 0 + X y_n \\right) \\cdot 2^{-1} + X y_{n-1} \\right) \\cdot 2^{-1} + \\ldots + X y_2 \\cdot 2^{-1} + X y_1 \\cdot 2^{-1}.\\]"
    }
],
[
    {
        "tag": "умножение с младших разрядов",
        "text": "Согласно выражению (2-18) при умножении с младших разрядов должна выполняться следующая последовательность действий: анализируется младшая цифра множителя. Если \\\\( y_n = 1 \\\\), то множимое \\\\( X \\\\) участвует в формировании цифровой части произведения. Если \\\\( y_n = 0 \\\\), то множимое не участвует в формировании цифровой части произведения; полученное первое частичное произведение, равное \\\\( 0 + X y_n \\\\), сдвигается на один разряд вправо, т. е. умножается на \\\\( 2^{-1} \\\\). Указанная последовательность действий справедлива при умножении на все последующие разряды. Так, при умножении на разряд \\\\( y_{n-1} \\\\): анализируется цифра множителя \\\\( y_{n-1} \\\\). Если \\\\( y_{n-1} = 1 \\\\), то множимое прибавляется к сдвинутому первому частичному произведению, т. е. \\\\( (0 + X y_n) \\\\cdot 2^{-1} + X \\\\cdot 1 \\\\). Если \\\\( y_{n-1} = 0 \\\\), то множимое не участвует в формировании произведения, т. е. \\\\( (0 + X y_n) \\\\cdot 2^{-1} + X \\\\cdot 0 \\\\); полученное второе частичное произведение, равное \\\\( (0 + X y_n) \\\\cdot 2^{-1} + X \\\\cdot 1 \\\\) или \\\\( (0 + X y_n) \\\\cdot 2^{-1} + X \\\\cdot 0 \\\\), сдвигается на один разряд вправо."
    },
    {
        "tag": "пример умножения с младших разрядов",
        "text": "Пример: \\\\[[X]\\\\_n = 1,1101\\\\]\\n\\\\[[Y]\\\\_n = 1,1011 \\quad \\\\mathcal{Z}\\\\_2 = \\\\mathcal{Z}\\\\_x \\oplus \\\\mathcal{Z}\\\\_y = 1 \\oplus 1 = 0\\\\]\\n\\\\[y_4 = 1 + \\\\begin{cases} 0,0000 \\\\ 0,1101 = X y_4 \\\\ 0,1101 = 0 + X y_4 = A_1 \\\\end{cases}\\\\]\\n\\\\[y_3 = 1 + \\\\begin{cases} 0,01101 = A_1 \\\\cdot 2^{-1} \\\\ 0,1101 = X y_3 \\\\ 1,00111 = A_1 \\\\cdot 2^{-1} + X y_3 = A_2 \\\\end{cases}\\\\]\\n37\\n\\\\[0,100111 = A_2 \\\\cdot 2^{-1}\\\\] \\\\[y_2 = 0 + 0,0000 = X y_2\\\\] \\\\[0,100111 = A_2 \\\\cdot 2^{-1} + X y_2 = A_3\\\\]\\n\\\\[0,0100111 = A_3 \\\\cdot 2^{-1}\\\\] \\\\[y_1 = 1 + 0,1101 = X y_1\\\\] \\\\[1,0001111 = A_3 \\\\cdot 2^{-1} + X y_1 = A_4\\\\] \\\\[0,10001111 = A_4 \\\\cdot 2^{-1}\\\\]"
    },
    {
        "tag": "рекуррентная формула умножения",
        "text": "Указанную процедуру умножения можно описать следующей рекуррентной формулой: \\\\[A_i = A_{i-1} \\\\cdot 2^{-1} + y_{n+1-i} X. \\\\tag{2-19}\\\\] Для выполнения умножения необходимо повторить n тактов (i = 1 \\\\ldots n) в соответствии с формулой (2-19) и в заключение осуществить последний n-й сдвиг A_n \\\\cdot 2^{-1} = x \\\\cdot y = z."
    },
    {
        "tag": "умножение со старших разрядов",
        "text": "Рассмотрим умножение со старших разрядов множителя. Согласно (2-17) при умножении только на один разряд должна выполняться следующая последовательность: множимое сдвигается на один разряд вправо, т. е. \\\\[X \\\\cdot 2^{-1}\\\\]; анализируется старшая цифра множителя \\\\[y_1\\\\]. Если \\\\[y_1 = 1\\\\], то \\\\[X \\\\cdot 2^{-1}\\\\] участвует в формировании произведения. Если \\\\[y_1 = 0\\\\], то \\\\[X \\\\cdot 2^{-1}\\\\] не участвует в формировании произведения. Выполнение такой последовательности соответствует умножению на старший разряд множителя и справедливо при умножении на все последующие разряды. Так, при умножении на второй разряд: производится второй сдвиг множимого, т. е. \\\\[(X \\\\cdot 2^{-1}) \\\\cdot 2^{-1}\\\\]; анализируется значение \\\\[y_2\\\\], и осуществляется передача или непередача \\\\[X \\\\cdot 2^{-2}\\\\] на суммирование."
    },
    {
        "tag": "пример умножения со старших разрядов",
        "text": "Пример:\\n\\\\[[X]\\\\_n = 1,10111111\\\\]\\n\\\\[[Y]\\\\_n = 0,10110101 \\quad 3_z = 1 \\oplus 0 = 1\\\\]\\n38\\n1.    2. 0,10111111    0,10111111 0,10110101    0,10110101 X·2^{-1}·y_1 = 0,010111111    0,010111111 X·2^{-2}·y_2 = 0,000000000    0,000000000 0,00010111111    0,00010111111 0,000010111111    0,00001011111 0,000000000000    0,000000000 0,0000010111111    0,0000010111 X·2^{-7}·y_7 = 0,000000000000    0,000000000 X·2^{-8}·y_8 = 0,000000001011111    0,000000001 0,100001110001011    0,10000110110\\n\\\\[[Z]\\\\_n = [X]\\\\_n·[Y]\\\\_n = 1,10000111\\\\]"
    },
    {
        "tag": "умножение в уменьшенной разрядной сетке",
        "text": "Умножение в уменьшенной разрядной сетке выполняется в том случае, когда необходимо получать в произведении только n разрядов. При этом операция выполняется в n + d-разрядной сетке, где d = \\\\log_{2} n. При таких условиях разряды сдвигаемого множимого с n + d + 1 по 2n не участвуют в операции, что приводит к погрешности произведения. Максимальное значение этой погрешности (в частности, в случае, когда \\\\|[X]\\\\_n = [Y]\\\\_n| = 0, 1 \\\\ldots 1\\\\) не превышает 2^{-n}. Такая погрешность допустима даже в случае минимальных относительных ошибок сомножителей, равных приблизительно 2^{-n-1}, при которых получить произведение с относительной погрешностью, меньшей 2^{-n}, невозможно. На практике этот метод применяется лишь в n + d-разрядной сетке."
    },
    {
        "tag": "умножение дополнительного и обратного кодов",
        "text": "Умножение дополнительного и обратного кодов отрицательных чисел на 2^{\\\\pm k}. Эти частные случаи умножения являются основными элементарными действиями при выполнении как собственно умножения дополнительных или обратных кодов чисел, так и операции деления во всех её модификациях. Допустим, требуется 0, x_1 \\\\ldots x_n \\\\cdot 2^{-k} = 0, 0 \\\\ldots 0 \\\\underbrace{x_{1+k} \\\\ldots x_{n+k}}_{k \\\\text{нулей}} или 0, 0 \\\\ldots 0 \\\\underbrace{x_{s+1} \\\\ldots x_n}_{s \\\\text{нулей}} \\\\cdot 2^{i-k} = 0, 0 \\\\ldots 0 \\\\underbrace{x_{s+1-k} \\\\ldots x_{n-k}}_{s \\\\text{нулей}} \\\\cdot 0 \\\\ldots 0. Из этих примеров следует, что умножение положительного числа на 2^{i-k} равноценно сдвигу на k разрядов в ту или другую сторону. Заметим, что должно соблюдаться следующее неравенство: \\\\[0, 0 \\\\ldots 0 \\\\underbrace{x_{s+1} \\\\ldots x_n}_{s \\\\text{нулей}} \\\\cdot 2^{i-k} < 1.\\\\]"
    }
]"}],
[{"tag":"умножение обратного кода отрицательного числа","text":"Умножение обратного кода отрицательного числа имеет определенную специфику. Так, ([-0, x_1 \\ldots x_n]_0 = 1, \\overline{x_1}, \\ldots \\overline{x_n}) \\cdot 2^{-k} =\n\n= [-0, x_1 \\ldots x_k \\cdot 2^{-k}]_0 = [-0, 0 \\ldots 0 \\underbrace{x_{1+k} \\ldots x_{n+k}}_{k \\text{ нулей}}]_0 =\n\n= 1, 1 \\ldots 1 \\underbrace{\\overline{x_{1+k}} \\ldots \\overline{x_{n+k}}}_{k \\text{ единиц}}\n\n\\begin{aligned} &(-0, 0 \\ldots 0 \\underbrace{x_{s+1} \\ldots x_n}_{s \\text{ нулей}}) = 1, 1 \\ldots 1 \\underbrace{\\overline{x_{s+1}} \\ldots \\overline{x_n}}_{s \\text{ единиц}} \\cdot 2^{i-k} = \\\\ &=[-0, 0 \\ldots 0 \\underbrace{x_{s+1} \\ldots x_n}_{s \\text{ нулей}} \\cdot 2^{i-k}]_0 = [-0, 0 \\ldots 0 \\underbrace{x_{s+1-k} \\ldots x_{n-k}}_{s \\text{ нулей}}]_0 = 1, 1 \\ldots 1 \\underbrace{\\overline{x_{s+1-k}} \\ldots \\overline{x_{n-k}}}_{k \\text{ единиц}} \\end{aligned}"},"tag":"умножение дополнительного кода отрицательного числа","text":"Также специфично умножение дополнительного кода отрицательного числа. Так, ([-0, x_1 \\ldots x_n]_n = 1, \\overline{x_1} \\ldots \\overline{x_n} + 2^{-n} = 1, \\overline{x_i} \\ldots \\overline{x_n}) \\cdot 2^{-k} = 1, 1 \\ldots 1 \\underbrace{\\overline{x_{1+k}} \\ldots \\overline{x_{n+k}}}_{k \\text{ единиц}} (здесь \\overline{x_i} - коды разрядов суммы \\overline{x_1} \\ldots \\overline{x_n} + 2^{-n});\n\n([-0, 0 \\ldots 0 \\underbrace{x_{s+1} \\ldots x_n}_{s \\text{ нулей}}]_n = 1, 1 \\ldots 1 \\underbrace{\\overline{x_{s+1}} \\ldots \\overline{x_n}}_{s \\text{ единиц}} \\cdot 2^{i-k} = )\n\n40\n\n= [-0, 0 \\ldots 0 x_{s+1-k} \\ldots x_{n-k} 0 \\ldots 0]_{\\pi} = \\] \\[s - k \\text{ нулей}\\] \\[= 1, 1 \\ldots 1 \\overline{x}_{s+1-k} \\ldots \\overline{x}_{n-k} 1 \\ldots 1 + 2^{-n} = \\] \\[s - k \\text{ единиц}\\] \\[= 1, 1 \\ldots 1 \\overline{x}_{s+1-k} \\ldots \\overline{x}_{n-k} 0 \\ldots 0.\\] \\[s - k \\text{ единиц}\\]"},"tag":"методика умножения дополнительными кодами","text":"Методика выполнения умножения над дополнительными, обратными кодами чисел. Операцию умножения над дополнительными кодами исходных чисел можно трактовать в общем виде следующим образом: если X > 0 и Y > 0, то поскольку [X > 0]_n = X, специфика выполнения умножения здесь не проявляется; если X < 0, а Y > 0, то [X < 0]_n = 2 + X и [X]_n [Y]_n = 2Y + XY — так называемое псевдопроизведение, и для того, чтобы получить правильный результат [XY < 0]_n = 2 + XY, необходимо к псевдопроизведению прибавить 2 и вычесть 2Y; если X > 0, Y < 0, то [X]_n [Y]_n = 2X + XY, и здесь необходима поправка, равная +2 и -2X; если X < 0 и Y < 0, то [X]_n [Y]_n = (2 + X)(2 + Y), а правильный результат XY, и необходима поправка -4-2X-2Y. Существует несколько способов введения поправок. Рассмотрим на примере умножения с младших разрядов множителя способ, обеспечивающий автоматическое введение поправок при любых знаках перемножаемых чисел. Обозначим разряд дополнительного кода множителя, на который производится умножение y_{n+1-i}. По отношению к данному разряду младший разряд будет y_{n+2-i}. Алгоритм рассматриваемой методики заключается в следующем: если y_{n+1-i} = y_{n+2-i}, то производится лишь сдвиг частичного произведения A_{i-1} \\cdot 2^{-1}, если y_{n+1-i} = 0, а y_{n+2-i} = 1, то к A_{i-1} \\cdot 2^{-1} прибавляется [X]_n; если y_{n+1-i} = 1, а y_{n+2-i} = 0, то от A_{i-1} \\cdot 2^{-1} вычитается [X]_n или к A_{i-1} \\cdot 2^{-1} прибавляется [-[X]_n]_n. Для этого алгоритма справедлива следующая рекуррентная формула: A_i = A_{i-1} \\cdot 2^{-1} + (y_{n+2-i} - y_{n+1-i}) [X]_n, \\tag{2-20} развернутый вид этой формулы [по аналогии с формулой (2-18)] имеет следующий вид: [Z]_n = (\\ldots ((0 + [X]_n [y_{n+1} - y_n]) \\cdot 2^{-1} + [X]_n [y_n - y_{n-1}] ) \\cdot 2^{-1} + \\ldots \\ldots + [X]_n [y_2 - y_1]) \\cdot 2^{-1} + [X]_n [y_1 - y_0]. \\tag{2-21} При этом операция состоит из n + 1 такта для i = 1 \\ldots n + 1. Другими словами, умножение производится и на знаковый разряд множителя — y_0 = 3y. После умножения на y_0 получаем A_{n+1} = [X]_A[Y]_A = |Z|_A, сдвиг A_{n+1} не производится."},{"tag":"пример умножения в дополнительном коде","text":"Пример:\n[X]_A = 0,10101\n[Y]_A = 1,01101\ni = 1   0   1   1,01011 = [-0,10101]_A\ni = 2   1   0   1,10101\ni = 3   0   1   0,10101 = [X]_A\ni = 4   1   1   0,00101\ni = 5   1   1   1,00000\ni = 6   0   0   1,11000001\ni = 5   1   0   0,10000001\ni = 5   1   0   0,11100001\ni = 5   1   0   0,10101 = [X]_A\ni = 6   0   1   0,10001001\ni = 6   0   1   0,010001001\ni = 6   0   1   1,01011 = [-10101]_A\ni = 6   0   1   1,100111001\n\n[X]_A[Y]_A = 1,10011"},"tag":"умножение со старших разрядов множителя","text":"Рассматриваемая методика применима и к умножению со старших разрядов множителя. Алгоритм выполнения операции имеет следующий вид:\n\n[X]_A [Y]_A = [X]_A (y_1 - y_0) + [X]_A \\cdot 2^{-1} \\cdot (y_2 - y_1) + \\ldots\n\n\\cdots + [X]_A \\cdot 2^{-n+1} \\cdot (y_n - y_{n-1}) + [X]_A \\cdot 2^{-n} \\cdot (y_{n+1} - y_n)."},"tag":"умножение обратными кодами сомножителей","text":"Возможно выполнение операции умножения над обратными кодами сомножителей. Рассмотрим методику умножения с младших разрядов с анализом знаков сомножителей.\n\nЕсли X > 0 и Y > 0, то здесь используется обычная методика.\n\nЕсли X < 0 и Y > 0, то в данном случае A_i = A_{i-1} \\cdot 2^{-1} + [X < 0]_{0, y_{n+1-i}}.\n\nЗдесь как частичные произведения, так и окончательное будут представлены в обратном коде.\n\nЕсли X > 0, а Y < 0, то необходимо осуществлять передачу [-0, x_1, \\ldots, x_n]_{0, y_{i-1}} = 1, x_1, \\ldots, x_n в сумматор, если y_i = 0; при y_i = 1 передача множимого не производится. При этом y_i — цифры обратного кода отрицательного множителя.\n\nЕсли X < 0, а Y < 0, то при y_i = 0 осуществляется передача не исходного кода [X < 0]_{0, y_{i-1}} = 1, x_1, \\ldots, x_n, а положительного кода множимого 0, x_1, \\ldots, x_n, который получается с помощью логической операции отрицания; при y_i = 1 передача множимого не осуществляется. Произведение в этом случае получается положительным.\n\nДанную методику можно распространить и на умножение со старших разрядов обратных кодов.\n\nПреимущество умножения чисел в дополнительном или обратном"}],
[{"tag":"деление со сдвигом остатка","text":"В ЭВМ широкое распространение получили две методики получения кода частного. Одна из них называется: деление со сдвигом остатка и его автоматическим восстановлением. Как уже указывалось в § 2-2, основой выполнения деления является операция вычитания с целью получения остатка, знак которого определяет цифру частного. Такой подход характерен для всех методик, применяемых в ЭВМ, в том числе и для рассматриваемой. Алгоритм выполнения деления имеет следующий вид:\n\n\\[X-Y = \\alpha_0.\\]\n\nЕсли \\(\\alpha_0 \\geq 0\\), то \\(z_0 = 1\\), если \\(\\alpha_0 < 0\\), то \\(z_0 = 0\\). Для определения следующей цифры частного необходимо выполнить действия: при \\(\\alpha_0 > 0\\) \\(2\\alpha_0 - Y = \\alpha_1\\), а при \\(\\alpha_0 < 0\\) \\(2\\alpha_0 + Y = \\alpha_1\\). При этом если \\(\\alpha_1 \\geq 0\\), то \\(z_1 = 1\\), если \\(\\alpha_1 < 0\\), то \\(z_1 = 0\\) и т. д.\n\nУказанную процедуру можно представить в виде рекуррентной формулы:\n\n\\[\\alpha_i = \\begin{cases} 2\\alpha_{i-1} - Y & \\text{при } \\alpha_{i-1} \\geq 0; \\\\ 2\\alpha_{i-1} + Y & \\text{при } \\alpha_{i-1} < 0. \\end{cases} \\tag{2-22}\\]\n\nЕсли \\(\\alpha_i < 0\\), т. е. \\(\\beta_{\\alpha_i} = 1\\), то \\(z_i = 0\\); если \\(\\alpha_i \\geq 0\\), т. е. \\(\\beta_{\\alpha_i} = 0\\), то \\(z_i = 1\\).\n\nВ данном случае знак остатка \\(\\beta_{\\alpha_i}\\) определяет не только значение соответствующей цифры частного, но и характер операции (прибавление или вычитание делителя к сдвинутому остатку) при определении следующей цифры частного. Операция \\(2\\alpha_{i-1} - Y\\) будет выполняться как операция сложения \\(2\\alpha_{i-1} + [-Y]_{\\alpha_0}\\)."},{"tag":"пример деления со сдвигом остатка","text":"Пример:\n\n\\[[X]_n = 1,100! + 0,100! + 0,101!\\]\n\n\\[[Y]_n = 0,101! + 1,010!\\]\n\n\\[\\beta_z = 1 \\oplus 0 = 1 \\quad 1,1110 = \\alpha_0 = (X + [-Y])_n < 0, \\; z_0 = 0\\]\n\n\\[2\\alpha_0 = 1,1100 + 0,101!\\]\n\n\\[0,011! = \\alpha_1 = (2\\alpha_0 + Y) > 0, \\; z_1 = 1\\]\n\n\\[2\\alpha_1 = 0,1110 + 1,010!\\]\n\n\\[0,001! = \\alpha_2 = (2\\alpha_1 + [-Y])_n > 0, \\; z_2 = 1\\]\n\n44\n\n\\[2\\alpha_2 = 0,0110\\] \\[+\\] \\[1,0101\\]\n\n\\[1,1011 = \\alpha_3 = (2\\alpha_2 + [-Y]_n) < 0, \\; z_3 = 0\\]\n\n\\[2\\alpha_3 = 1,0110\\] \\[+\\] \\[0,1011\\]\n\n\\[0,0001 = \\alpha_4 = (2\\alpha_3 + Y) > 0, \\; z_4 = 1\\]\n\n\\[[Z]_{n} = 1,1101.\\]"},{"tag":"деление со сдвигом делителя","text":"Вторая методика: деление со сдвигом делителя и автоматическим восстановлением остатка. Ее алгоритм:\n\nX - Y = \\alpha_0;\n\nесли \\alpha_0 \\geq 0, то z_0 = 1, и если \\alpha_0 < 0, то z_0 = 0. Для определения следующей цифры частного необходимо выполнить действия: при \\alpha_0 \\geq 0 \\alpha_0 - Y \\cdot 2^{-1} = \\alpha_1, а при \\alpha_0 < 0 \\alpha_0 + Y \\cdot 2^{-1} = \\alpha_1. Если \\alpha_1 \\geq 0, то z_1 = 1, а если \\alpha_1 < 0, то z_1 = 0 и т. д.\n\nУказанную процедуру можно представить в виде рекуррентной формулы:\n\n\\[\\alpha_i = \\begin{cases} \\alpha_{i-1} - Y \\cdot 2^{-i} & \\text{при } \\alpha_{i-1} \\geq 0; \\\\ \\alpha_{i-1} + Y \\cdot 2^{-i} & \\text{при } \\alpha_{i-1} < 0. \\end{cases}\\]\n\n(2-23)\n\nЕсли \\alpha_i < 0, то z_i = 0, если \\alpha_i \\geq 0, то z_i = 1.\n\nДля данной методики характерно выполнение операции алгебраического суммирования по мере возрастания i в увеличивающейся разрядной сетке. Так, при i = n суммирование должно происходить в 2n-разрядной сетке. На практике эта методика, так же как и методика умножения со старших разрядов множителя, выполняется в уменьшенной n + d-разрядной сетке, где d = log_n."}]"}],
[{"tag":"пример деления прямых кодов","text":"\\[[X]_n = 1,01100001\\] \\[[Y]_n = 1,10010010\\] 3z = 1 \\oplus 1 = 0 0,01100001 1,01101110 = [-Y]_n 1,11001110 = \\alpha_0 = X + [-Y]_n < 0, z_0 = 0 0,01001010 0,0001100000 = \\alpha_1 = \\alpha_0 + Y \\cdot 2^{-1} > 0, z_1 = 1 1,110110110 = [-Y \\cdot 2^{-2}]_n 45 Здесь операция выполняется в \\( n + d \\)-разрядной сетке, \\( n = 8 \\) и \\( d = 3 \\) \\[1,11110011100 = \\alpha_2 = \\alpha_1 + [-Y \\cdot 2^{-2}]_{R} < 0, \\quad z_2 = 0\\] \\[0,00010010010 = Y \\cdot 2^{-3}\\] \\[0,00000101110 = \\alpha_3 = \\alpha_2 + Y \\cdot 2^{-3} > 0, \\quad z_3 = 1\\] \\[1,11110110111 = [-Y \\cdot 2^{-4}]_{R}\\] \\[[Z]_{n} = 1,1010\\] \\[1,1111100101 = \\alpha_4 = \\alpha_3 + [-Y \\cdot 2^{-4}]_{R} < 0, \\quad z_4 = 0\\]"},{"tag":"методики деления прямых кодов","text":"Рассмотренные две методики деления прямых кодов исходных чисел широко применяются в ЭВМ, особенно методика со сдвигом остатка."},{"tag":"деление дополнительными кодами","text":"Методика выполнения деления над дополнительными кодами исходных чисел. Алгоритм выполнения операции со сдвигом остатка определяется следующей формулой: \\[\\alpha_i = \\begin{cases} 2\\alpha_{i-1} + [-Y]_{R} & \\text{ если } 3\\alpha_{i-1} = 3; \\\\ 2\\alpha_{i-1} + [Y]_{R} & \\text{ если } 3\\alpha_{i-1} \\neq 3. \\end{cases} \\tag{2-24}\\] Если \\( 3\\alpha_i = 3_y \\), то \\( z_i = 1 \\), если \\( 3\\alpha_i \\neq 3_y \\), то \\( z_i = 0 \\). В первом такте операции вместо \\( 3\\alpha_{i-1} \\) берется \\( 3_x \\), а вместо \\( 2\\alpha_{i-1} \\) принимается код \\([X]_{R}\\)."},{"tag":"пример деления дополнительными кодами","text":"\\[[X]_{R} = 1,0111 + 1,0111 - 1,0011\\] \\[[Y]_{R} = 1,0011 + 0,1101 = [-Y]_{R} \\] Так как \\( 3_x = 3_y \\), то \\[0,0100 = \\alpha_0 = [X]_{R} + [-Y]_{R} \\] \\[2\\alpha_0 = 0,1000 \\quad 3\\alpha_0 \\neq 3_y \\quad \\text{и } z_0 = 0.\\] \\[+ 1,0011 = [Y]_{R}\\] \\[1,1011 = \\alpha_1 = 2\\alpha_0 + [Y]_{R},\\] Так как \\( 3\\alpha_i \\neq 3_y \\), то \\[2\\alpha_1 = 1,0110 \\quad 3\\alpha_i = 3_y \\quad \\text{и } z_1 = 1.\\] \\[+ 0,1101 = [-Y]_{R} \\] \\[0,0011 = \\alpha_2 = 2\\alpha_1 + [-Y]_{R} \\] \\[2\\alpha_2 = 0,0110 \\quad 3\\alpha_i \\neq 3_y \\quad \\text{и } z_2 = 0.\\] \\[+ 1,0011 = [Y]_{R}\\] \\[1,1001 = \\alpha_3 = 2\\alpha_2 + [Y]_{R},\\] Так как \\(3_{\\alpha_3} = 3_y\\), то"}]"}],
[{"tag":"формулы деления","text":"\\\\[2\\\\alpha_3 = \\frac{1,0010}{1 + 0,1101} \\quad 3_{\\\\alpha_3} = 3_y \\quad \\text{и} \\quad z_3 = 1.\\\\]\\n\\\\[\\frac{1,1111}{1 - 0,1111} = \\alpha_4 = 2\\\\alpha_3 + [1 - [Y]_n]_n,\\\\]\\n\\\\[3_{\\\\alpha_4} = 3_y \\quad \\text{и} \\quad z_4 = 1.\\\\]\\n\\nтаким образом, \\(Z = 0,1011\\)"},"tag":"преимущества метода деления","text":"Преимущество такого способа выполнения деления то же, что и для умножения дополнительных, обратных кодов. Операция деления выполняется в виде одного этапа (\\\\(n + 1\\\\) такт). При этом во время выполнения первого также получаем код знака частного—\\\\(3_z = z_0\\\\). Частное получается в дополнительном коде."},{"tag":"условия применения метода деления","text":"Рассмотренная методика справедлива при условии, что \\(|[Z]_n| = \\left| \\frac{X_{1n}}{Y_{1n}} \\right| < 1\\). В случае необходимости определения частного \\(1 \\leq |[Z]_n| < 2\\) поступают следующим образом: \\(\\frac{[X_{1n}]^2}{[Y]_{1n}} = z_0, \\; z_1 \\ldots \\ldots z_n\\), при этом \\(z_0\\) будет определять знак, а код \\(z_1\\) — целую часть числа."},{"tag":"методика арифметики с фиксированной запятой","text":"Методика выполнения арифметических действий над целыми числами при их представлении с фиксированной запятой\\n\\nВесь предшествующий материал данного параграфа ориентирован на представление чисел с фиксированной запятой при \\\\(m = 0\\\\). Указанное ограничение приводит к необходимости выполнения трудоемкой работы по масштабированию задачи, но в то же время сопровождается уменьшением объёма оборудования и упрощением конструкции \\\\(Ay'\\\\)."},"tag":"аппаратные решения условно-фиксированной запятой","text":"Аппаратные решения, обеспечивающие выполнение методики арифметических действий над дополнительными или обратными кодами правильных дробей, могут без каких-либо аппаратных дополнений быть использованы и для выполнения арифметических действий над целыми числами. Такой режим работы \\\\(Ay'\\\\) получил название режима работы с условно-фиксированной запятой."},{"tag":"сущность режима условно-фиксированной запятой","text":"Сущность этого режима заключается в следующем. В разрядной сетке числа, предназначенной для представления правильной дроби, условно принимается положение запятой, определяемое величиной \\\\(k = n/2\\\\) относительно знакового разряда (рис. 2-5, a). При этом целое число изображается в левой части разрядной сетки. Диапазон изображения целых чисел \\(0 < |X_{1n}| \\leq 2^k - 1\\). Веса разрядов в режиме условно-фиксированной запятой имеют значения в соответствии с рис. 2-5, б."},{"tag":"пример сложения в условно фиксированной запятой","text":"Рассмотрим выполнение арифметических действий в разрядной сетке, содержащей \\\\(n = 10\\\\) разрядов, где условное положение запятой определяется значением \\\\(k = n/2 = 5\\\\).\\n\\nСложение. Обратимся к примеру: требуется сложить два целых числа\\n\\n\\\\[ 1011 = 11 \\\\] \\\\[ -1101 = -13 \\\\]\\n\\nЭти два числа в режиме условно фиксированной запятой имеют следующий вид:\\n\\n\\\\[ 0,0101100000 = [X = 1011]_n \\\\] \\\\[ 1,0110100000 = [Y = -1101]_n \\\\]\\n\\nОперация сложения, выполняемая над данными кодами по обычной методике сложения дополнительных или обратных кодов правильных дробей, дает нам требуемый результат:\\n\\n\\\\[ 0,0101100000 = [X = 1011]_n \\\\] \\\\[ 1,1001100000 = [Y = -1101]_n \\\\] \\\\[ 1,1111000000 = [X + [Y < 0]_n]_n \\\\] \\\\[ 1,0001000000 = [X + Y]_n \\\\]"},"tag":"пример умножения в условно фиксированной запятой","text":"Умножение. Допустим, требуется перемножить два числа:\\n\\n\\\\[ 1001 = 9 \\\\] \\\\[ -11 = -3 \\\\] \\\\[ 0,0100100000 = [X = 1001]_n \\\\] \\\\[ 1,0001100000 = [Y = -11]_n \\\\]\\n\\nКак и в обычной методике, \\\\( \\mathcal{J}_z = \\mathcal{J}_x \\oplus \\mathcal{J}_y = 0 \\oplus 1 = 1 \\\\). И перемножая прямые коды чисел с младших разрядов, получим следующий результат:\\n\\n\\\\[\\\\begin{array}{l} 0,010010000 \\\\times \\\\ 0,000110000 \\\\end{array}\\\\]\\n\\n\\\\[\\\\begin{array}{l} 0,000000000 = A_5 \\cdot 2^{-1} \\\\ + \\\\ 0,010010000 = X \\cdot y_5 \\\\end{array}\\\\]\\n\\n\\\\[\\\\begin{array}{l} 0,010010000 = A_6 \\\\end{array}\\\\]\\n\\n\\\\[\\\\begin{array}{l} 0,001001000 = A_8 \\cdot 2^{-1} \\\\ + \\\\ 0,010010000 = X \\cdot y_4 \\\\end{array}\\\\]\\n\\n\\\\[\\\\begin{array}{l} 0,011011000 = A_7 \\\\end{array}\\\\]"}]"}],
[{"tag":"смещение при умножении фиксированной запятой","text":"\\[\\\\begin{array}{l} 0,0011011000 = A_7 \\\\cdot 2^{-1} \\\\\\\\ \\end{array}\\]\\n\\n\\[\\\\begin{array}{l} 0,0000011011 = A_{10} \\\\cdot 2^{-1} = XY \\\\\\\\ \\end{array}\\]\\n\\nПолучили правильное произведение, но сдвинутое относительно условного положения запятой на \\( k = n/2 = 5 \\) разрядов. Предусматривая в программе задачи после каждого выполнения операции умножения выполнение операции сдвига на \\( k \\) разрядов влево, будем получать правильный результат относительно условного расположения запятой."},{"tag":"смещение при делении фиксированной запятой","text":"\\[\\\\begin{array}{l} 1,011110000 = [X = -1111]_n \\\\ 1,011110000 = [Y = -1111]_n \\\\\\\\ \\end{array}\\]\\n\\n\\(3_z = 1 \\oplus 1 = 0\\)\\n\\n\\[\\\\begin{array}{c|c} 0,011110000 & 0,011110000 \\\\\\hline 1,100010000 & 1 \\\\\\ \\end{array}\\]\\n\\n\\[\\\\begin{array}{l} 0,000000000 = \\alpha_0 = X + [-Y]_{\\alpha} = 0, \\quad z_0 = 1 \\\\\\ \\end{array}\\]\\n\\nПрименяя обычную методику деления чисел с фиксированной запятой, получили код \\( 1,0 \\ldots 0 \\) вместо требуемого \\( 0,000010000 \\). Код результата деления двух целых чисел оказывается сдвинутым относительно условной запятой на \\( k = 5 \\) разрядов влево. Правильный результат будет получен за счет выполнения предварительного сдвига кода делимого на \\( k = 5 \\) разрядов вправо. Выполнив предварительный сдвиг делимого \\[0,0111100000 \\cdot 2^{-(k=5)} = 0,0000001111\\] и осуществив операцию деления \\[\\\\begin{array}{c|c} 0,0000001111 & 0,0111100000 \\\\\\hline 1,1000100000 & \\\\\\ 1,1000101111 & = \\alpha_0 < 0, \\, z_0 = 0 \\\\\\ 1,0001011110 & \\\\\\ 0,0111100000 & \\\\\\ 1,1000111110 & = \\alpha_1 < 0, \\, z_1 = 0 \\\\\\ 1,0001111100 & \\\\\\ 0,0111100000 & \\\\\\ 1,1001011100 & = \\alpha_2 < 0, \\, z_2 = 0 \\\\\\ 1,0010111000 & \\\\\\ 0,0111100000 & \\\\\\ 1,1010011000 & = \\alpha_3 < 0, \\, z_3 = 0 \\\\\\ 1,0100110000 & \\\\\\ 0,0111100000 & \\\\\\ 1,1100010000 & = \\alpha_4 < 0, \\, z_4 = 0 \\\\\\ 1,1000100000 & \\\\\\ 0,0111100000 & \\\\\\ 0,0000000000 = \\alpha_5 = 0, \\, z_5 = 1, \\\\\\ \\end{array}\\] получим \\( Z = 0,0000100000 \\)."},{"tag":"выбор значения k при фиксированной запятой","text":"Следует заметить, что возможно условное положение запятой и при значении \\( k \\neq n/2 \\). Но уменьшение этого значения уменьшит диапазон представления чисел, не давая при этом никаких преимуществ. Случай \\( k > n/2 \\) будет сопровождаться увеличением диапазона представления чисел, но и потребует выполнять большее количество дополнительных операций."},{"tag":"аппаратные ограничения мини-ЭВМ","text":"В современных мини-ЭВМ встречаются арифметические устройства, аппаратура которых в минимальном комплекте обеспечивает лишь выполнение операции сложения, вычитания и \\([X]_n \\times 2^{k+1} (k - целое число)\\). При этом разрядная сетка может использоваться для представления любых чисел (целых, правильных дробей, произвольных). Выполнение же длинных арифметических операций осуществляется по специальным программам или с помощью дополнительной аппаратуры (приставки, модули)."},{"tag":"введение в арифметику плавающей запятой","text":"### 2-6. Арифметические действия над числами с плавающей запятой в двоичной системе счисления\\n\\nВыполнение всех операций будем производить над нормализованными числами, получая нормализованный результат. Рассмотрим вначале выполнение наиболее простых арифметических действий над числами с плавающей запятой."},{"tag":"формулы умножения и деления плавающей запятой","text":"\\[X = 2^m x \\\\cdot M_x, \\\\quad где \\\\quad M_x = 3x, \\\\quad x_1 \\ldots x_n \\\\quad и\\]\\n\\n\\[Y = 2^my \\\\cdot M_y, \\\\quad M_y = 3y, \\\\quad y_1 \\ldots y_n.\\]\\n\\nЛегко видеть, что \\( Z = XY = 2^mx + my (M_x M_y) \\), а\\n\\n\\[Z = \\\\frac{X}{Y} = 2^mx - my \\\\left( \\\\frac{M_x}{M_y} \\\\right).\\]\\n\\nВ соответствии с этими выражениями умножение и деление чисел с плавающей запятой выполняются в два этапа: определяется порядок произведения или частного путем сложения или вычитания порядков; определяется мантисса произведения или частного путем перемножения или деления двух чисел с фиксированной запятой.\\n\\nТаким образом, методика выполнения умножения — деления чисел с плавающей запятой полностью основана на использовании методики выполнения алгебраического суммирования целых чисел и умножения — деления чисел с фиксированной запятой."},{"tag":"расчет порядка и нормализация при умножении и делении","text":"В операции умножения суммирование машинных порядков сомножителей даст результат \\( m_{xм} + m_{yм} = m_{xч} + 2^n n^{-1} + m_{yч} + 2^n n^{-1} \\), который отличается от правильного \\( m_{xyм} = m_{xч} + m_{yч} + 2^n n^{-1} \\) на \\( 2^n n^{-1} \\). Соответственно определение порядка произведения должно выполняться по следующей формуле: \\( m_{xм} + m_{yм} - 2^n n^{-1} = m_{xyм} \\).\\n\\nЛегко показать, что определение порядка частного должно выполняться по следующей формуле: \\( m_{xм} - m_{yм} + 2^n n^{-1} = m_{xyм} \\).\\n\\nМетодика выполнения операций над числами с плавающей запятой несколько усложняется из-за наличия частных случаев.\\n\\nПри умножении и делении нормализованных мантисс исходных чисел можно получить ненормализованные мантиссы произведения и частного. Определим возможные границы нарушения нормализации.\\n\\nПри умножении \\( 1 > |M_{xy}| \\geq M_{xy \\; мин} = M_{x \\; мин} M_{y \\; мин} = 0,10 \\ldots 0,10 \\ldots 0 = 0,010 \\ldots 0 = 2^{-2} \\). Для получения нормализованного произведения необходимо увеличить в 2 раза ненормализованную мантиссу произведения — \\( M_{xy} \\cdot 2^{+1} \\) с одновременным уменьшением порядка произведения — \\( (m_x + m_y - 1) \\)."}]"}],
[{"tag":"диапазон мантиссы частного","text":"Диапазон мантиссы частного \\( |M_{x \\, макс}| \\geq |M_{x'}| \\geq |M_{y \\, мин}| \\) или \\( 2 > \\frac{1 - 2^{-n_{м}}}{2^{-1}} \\geq |M_{x'}| \\geq \\frac{2^{-1}}{1 - 2^{-n_{м}}} > 2^{-1} \\). И здесь нарушение нормализации происходит максимум на один разряд. Для получения нормализованной мантиссы частного необходимо в 2 раза уменьшить ненормализованную мантиссу частного \\( M_{x'y'} \\cdot 2^{-1} \\) с одновременным увеличением порядка частного \\( (m_x - m_y + 1) \\)."},{"tag":"условия нормализации мантиссы","text":"Необходимость выполнения рассмотренных нормализаций легко определяется в процессе выполнения операций. Нормализация мантиссы произведения выполняется тогда, когда \\( z_1 = 0 \\) в прямом коде \\( M_z = M_x M_y \\). Нормализация в делении — тогда, когда \\( z_0 = 1 \\), где \\( z_0 \\) — целая часть \\( M_z = M_x / M_y \\) в прямом коде."},{"tag":"переполнение разрядной сетки порядков","text":"В операциях умножения и деления при формировании порядков произведения и частного возможно переполнение разрядной сетки порядков."},{"tag":"переполнение порядка (бесконечность)","text":"Например, \\( m_x \\pm m_y > m_{макс} \\), это соответствует случаю, когда в машине получается число, большее, чем максимально возможное, которое можно представить на машине, при этом \\( Z = XY = \\infty \\) или \\( Z = X/Y = \\infty \\) и машина должна останавливаться."},{"tag":"переполнение порядка (ноль)","text":"Если \\( m_x \\pm m_y < m_{макс} \\), то в машине получается число, меньшее, чем минимально возможное, которое можно представить в машине, при этом \\( Z = XY \\) или \\( Z = X/Y \\) принимается равным нулю без останова машины."},{"tag":"анализ порядка на бесконечность и ноль","text":"Анализ порядка произведения на наличие кода \\(\\infty\\) и порядка частного на код нуля следует проводить после нормализации мантиссы произведения и частного. При этом исключаются случаи переполнения порядков, когда \\( m_x + m_y = m_{\\text{макс}} + 1 \\) и \\( m_x - m_y = -m_{\\text{макс}}-1 \\). В ряде ЭВМ при переполнении разрядной сетки порядков осуществляется прерывание."},{"tag":"модифицированные коды для бесконечности и нуля","text":"Фиксировать переполнение разрядной сетки порядков удобно с помощью модифицированных кодов. При изображении порядков в ЭВМ положительными и отрицательными числами \\( Z = \\infty \\) и \\( Z = 0 \\) соответствуют коды 01, . . . и 10, . . . в знаковых разрядах порядка произведения или частного. При изображении порядков в машине целыми положительными числами в соответствии с равенством (2-11) в фиксации случаев \\( Z = \\infty \\) и \\( Z = 0 \\) при операциях с порядками есть некоторая специфика. В операции умножения случаю \\( Z = \\infty \\) будет соответствовать"},{"tag":"код 10 для бесконечности","text":"\\[m_{xм} + m_{yм} - 2^n n^{-1} > m_{м. макс} = 2^n n - 1 = 1, . . . 1.\\] Здесь происходит положительное переполнение, которое фиксируется в сумме порядков кодом 10."},{"tag":"код 11 для нуля","text":"Случай \\( Z = 0 \\) будет определяться неравенством"},{"tag":"код 11 для нуля","text":"\\[m_{xм} + m_{yм} - 2^n n^{-1} < m_{м. мин} = 0, . . . 0.\\] Все случаи, соответствующие данному неравенству, будут определяться в сумме порядков кодом 11."},{"tag":"формула порядка частного и коды результата","text":"В операции деления, где порядок частного определяется по формуле \\[m_{x,yм} = m_{xм} - m_{yм} + 2^n n^{-1}, \\quad Z = \\infty \\quad и \\quad Z = 0\\] фиксируются так же, как в операции умножения. Таким образом, в операции умножения и деления над числами, порядки которых изображены целыми положительными числами, код результата, равный \\(\\infty\\) или 0, определяется по значению двух старших разрядов кода суммы или разности порядков. Веса этих разрядов \\( 2^n n \\) — это знаковый разряд при алгебраическом суммировании и \\( 2^n n^{-1} \\) — старший разряд в разрядной сетке порядков. Код этих разрядов, равный 10, соответствует \\( Z = \\infty \\), код, равный 11, соответствует \\( Z = 0 \\)."},{"tag":"пример умножения","text":"Пример 1. Умножить два числа \\[[m_{x}]_n = 0,101 \\quad 1,10000000 = [M_{x}]_n\\] \\[[m_{y}]_n = 1,111 \\quad 1,10000000 = [M_{y}]_n\\] 53 + 00,101 = [m_x]^M + 11,111 = [m_y]^M - 00,100 = [m_{xy}]^M \\[[M_{xy}]_n = 1,010 \\ldots 0 - \\text{мантисса}\\] произведения не нормализована. Выполняем сдвиг мантиссы влево и вычитание единицы из порядка произведения + 00,100 + 11,111 = [-0,001]^M - 00,011 Ответ: 0,011 1,10 \\ldots 0."},{"tag":"пример деления","text":"Пример 2. Разделить два числа \\[m_{xм} = 0001 \\quad 1,11111111 = [M_x]_n\\] \\[m_{yм} = 0101 \\quad 1,11111110 = [M_y]_n\\] 0,0001 = m_{xм} + 1,1011 = [-m_{yм}]_n = [-0101]_n 0,1000 = 2^n n^{-1} = 2^{4-1} - 0,0100 = m_{xy'м}\\] \\[\\frac{3}{x y} = 1 \\oplus 1 = 0 \\quad \\text{и} \\quad \\left"}],
[{"tag":"представление чисел в плавающей точке","text":"[[m_x]_o = 0,110 \\\\quad 1,10101010 = [M_x]_n] [[m_y]_o = 1,001 \\\\quad 1,11100011 = [M_y]_n] 54 + 00,110 = [m_x]^M 00,110 = [-[m_y]_0]^M \\\\quad [-[m_y]_0]^M 01,100 — в знаковых разрядах порядка частного код 01, . . . , это соответствует z = x/y = ∞."},{"tag":"пример умножения чисел","text":"Пример 4. Умножить два числа \\\\[[ m_{xм} = 0001 \\\\]] \\\\[[ m_{yм} = 0010 \\\\]] 1,11110000 = [M_x]_n 0,11001101 = [M_y]_n 0,0001 + 0,0010 1,1000 = [-2^n-1]_n 1,1011 — в разрядах порядка произведения код 1,1 . . . , это соответствует Z = 0."},{"tag":"операция сложения и вычитания","text":"Сложение — вычитание Операция над числами X = 2^{m_x} M_x и Y = 2^{my} M_y осуществляется по формуле S = X ± Y = 2^{макс (m_x, my)} (M_x' ± M_y'), при этом если \\\\( m_x - my > 0 \\\\), то \\\\( M_x' = M_x \\\\), а \\\\( M_y' = M_y \\cdot 2^{-|m_x - my|} \\\\), если \\\\( m_x - my < 0 \\\\), то \\\\( M_x' = M_x \\cdot 2^{-|m_x - my|} \\\\), а \\\\( M_y' = M_y \\\\), если \\\\( m_x = my \\\\), то \\\\( M_x' = M_x \\\\) и \\\\( M_y' = M_y \\\\)."},{"tag":"выравнивание порядков","text":"Выравнивание порядков. При этом прежде всего определяется разность порядков \\( m_x - my \\) и затем осуществляется денормализация (сдвиг вправо на \\|m_x - my\\| разрядов) мантиссы меньшего слагаемого. Знак разности порядков однозначно определяет мантиссу меньшего слагаемого. Необходимость этого этапа можно иллюстрировать на примере чисел с плавающей запятой в десятичной системе счисления. Допустим, требуется сложить 504,136 = 10^3 \\cdot 0,504136 и 0,098702 = 10^{-1} \\cdot 0,987020. Очевидно, что недопустимо производить суммирование мантисс в виде + 0,504136. Необходимо предварительно выравнять порядки, т. е. 3 — (-1) = 4, и денормализовать мантиссу меньшего слагаемого — 0,987020 \\cdot 10^{-4} = 0,000098702 и затем осуществлять суммирование мантисс + 0,504136000 + 0,000098702."},{"tag":"алгебраическое суммирование мантисс","text":"Алгебраическое суммирование мантисс с равными порядками, т. е. \\( M_x + M_y \\cdot 2^{-|m_x - m_y|} \\), если \\( m_x - m_y > 0 \\); \\[M_x \\cdot 2^{-|m_x - m_y|} + M_y, \\quad \\text{если } m_x - m_y < 0.\\] \\[M_x + M_y, \\quad \\text{если } m_x - m_y = 0.\\] Этот этап выполняется по методике суммирования чисел с фиксированной запятой."},{"tag":"нормализация мантиссы","text":"Нормализация влево или вправо. Нормализация влево производится тогда, когда \\( 2^{1-i-1} \\leq |M_x^i + M_y^i| < 2^{-i} \\). В этом случае мантисса суммы умножается на \\( 2^{1+i} \\) (т. е. сдвигается на \\( i \\) разрядов влево), и одновременно от порядка суммы вычитается \\( i \\) единиц, т. е. \\( (m_x, m_y) - i \\). При этом мантисса оказывается нормализованной, поскольку её величина удовлетворяет \\( 2^{-1} \\leq |(M_x^i + M_y^i)| \\times 2^{1+i} < 1 \\). Нормализация вправо выполняется тогда, когда \\( |M_x^i + M_y^i| \\geq 1 \\). В этом случае \\( |M_x^i + M_y^i| \\cdot 2^{-1} \\) и max \\( (m_x, m_y) + 1 \\)."},{"tag":"преобразование кода отрицательной мантиссы","text":"Преобразование дополнительного, обратного кода отрицательной мантиссы суммы в прямой. Этот этап выполняется в том случае, когда слагаемые и сумма представляются в прямом коде."},{"tag":"блокировки и переполнение при нормализации","text":"При нормализации мантиссы суммы вправо возможно переполнение порядка суммы — max \\( (m_x, m_y) + 1 > m_{\\text{макс}} \\). В этом случае получается число, большее, чем максимально возможное, которое можно представить на машине. При этом сумма — разность принимается равной \\( \\infty \\), и машина останавливается. При нормализации мантиссы суммы влево тоже возможно переполнение порядка суммы max \\( (m_x, m_y) - i < m_{\\text{макс}} \\). В этом случае получается число, меньшее, чем минимально возможное, которое можно представить в машине. Результат принимается равным нулю без останова машины. В ряде ЭВМ в рассматриваемых случаях осуществляется прерывание. Последний случай — блокировка. Если при выравнивании порядков \\( |m_x - m_y| > m_{\\text{макс}} \\), то дальнейшее выполнение операции блокируется и результат равен большему слагаемому. В этом случае мантисса меньшего слагаемого должна сдвигаться вправо на количество разрядов, большее, чем \\( m_{\\text{макс}} = 2^{n_n-1} - 1 \\). Если учесть, что во всех ЭВМ \\( n_n - 1 \\geq \\log_2 n_m \\), то окажется, что сдвиг будет выполняться на количество разрядов, большее или равное \\( n_m \\). При этом мантисса меньшего слагаемого выйдет за разрядную сетку. Все три рассмотренные блокировки характеризуются переполнением разрядной сетки порядков, что удобно фиксировать с помощью модифицированного дополнительного или обратного кода."}]"}],
[
    {
        "tag": "блокировка при представлении порядков знаковыми числами",
        "text": "При представлении порядков чисел в машине положительными и отрицательными целыми числами случаю, когда max \\(m_x, m_y\\) + 1 > m_{макс}, будет соответствовать код 01, ..., случаю max \\(m_x, m_y\\) - i < m_{макс} код 10, ..., и блокировке выравнивания порядков — код 10, ..., или 01, ..., в знаковых разрядах суммы или разности порядков."
    },
    {
        "tag": "блокировка при представлении порядков положительными числами",
        "text": "При представлении порядков в машине положительными числами в соответствии с равенством (2-11) фиксация указанных блокировок несколько видоизменяется. Так, блокировка X \\pm Y = \\infty будет определяться неравенством max \\(m_{xм}, m_{yм}\\) + 1 > m_{макс} = 2^n - 1, и ей будет соответствовать код \\underline{10}, ..., в сумматоре порядков. Блокировка X \\pm Y = 0 будет определяться неравенством max \\(m_{xм}, m_{yм}\\) - i < m_{макс} = 0, ..., и ей будет соответствовать код \\underline{11}, ..., в сумматоре порядков. Таким образом, код \\infty и код 0 при сложении—вычитании фиксируются так же, как и при умножении и делении."
    },
    {
        "tag": "условие блокировки выравнивания порядков",
        "text": "Блокировка выравнивания порядков:\\n\\\\[|m_{xм} - m_{yм}| > m_{макс}\\\\]\\nВ этом случае \\(m_{xм} - m_{yм}\\) = m_{xч} + 2^n - 1 — \\(m_{yч} - 2^n - 1 = m_{xч} - m_{yч}\\). Переполнение такой разности порядков фиксируется так же, как и в случае представления исходных порядков положительными или отрицательными числами, т. е. кодами \\(01\\), ..., или \\(10\\), ..."
    },
    {
        "tag": "таблица параметров разрядов",
        "text": "\\\\[\\\\begin{array}{cc} n_n & n_{разрядов} \\\\\\\\ \\hline \\text{разрядов} & n_n \\\\\\\\ \\end{array}\\\\]"
    },
    {
        "tag": "пример 1 сложение чисел",
        "text": "Пример 1. Сложить два числа.\\n\\\\[\\\\[m_x\\]_o = 1,110 \\quad 0,10000000 = [M_x]\\_n\\\\]\\n\\\\[\\\\[m_y\\]_o = 0,001 \\quad 1,11111111 = [M_y]\\_n\\\\]\\nСначала определяем разность порядков\\n\\\\[\\\\underline{11,110}\\\\]\\n\\\\[\\\\underline{11,110}\\\\]\\n\\\\[\\\\underline{11,100}\\\\]\\n\\\\[\\\\underline{11,101} = m_x - m_y < 0\\\\]\\nЗатем денормализуем мантиссу меньшего слагаемого \\(0,10000000\\). В ЭВМ на каждый сдвиг мантиссы меньшего слагаемого к отрицательной разности порядков прибавляется \\(00,001\\) (при положительной разности вычитается \\(00,001\\)). Такая процедура выполняется до тех пор, пока разность порядков не будет сведена к нулю (в об-\\n\\n11,101    0,0100000 00,001    0,0010000 11,110 00,001 11,111 = [-00,000]^M\\n\\nСуммирование мантисс с равными порядками: \\\\[ 00,00100000 = [M_x \\cdot 2^{-2}]_0^M \\\\] \\\\[ 11,00000000 = [M_y]_0^M \\\\] \\\\[ 11,00100000 = [M_s]_0^M \\\\]\\nПреобразуем обратный код отрицательной мантиссы суммы в прямой: \\\\[ [M_s]_0 = 1,00100000 \\quad [M_s]\\_n = 1,11011111. \\\\]\\nОтвет: 0,001 1,11011111."
    },
    {
        "tag": "пример 2 сложение чисел",
        "text": "Пример 2. Сложить два числа.\\n\\\\[ [m_x]\\_A = 1,001 \\quad 0,11111111 = [M_x]\\_n \\\\] \\\\[ [m_y]\\_A = 0,110 \\quad 1,11111111 = [M_y]\\_n \\\\]\\n11,001 = [m_x]\\_A^M\\n11,010 = [-[m_y]\\_A]^M\\n10,011 = [(m_x - m_y) < 0]\\_A^M. В знаковых разрядах код 10, . . . дальнейшее выполнение операции блокируется, результат равен большему слагаемому. Ответ: 0,110 1,11111111."
    },
    {
        "tag": "пример 3 сложение чисел",
        "text": "Пример 3. Сложить два числа.\\n\\\\[ m_{xм} = 1111 \\quad 1,00100000 = [M_x]\\_A \\\\] \\\\[ m_{yм} = 1111 \\quad 1,00100000 = [M_y]\\_A \\\\] \\\\[ 0,1111 \\\\] \\\\[ 1,0001 \\\\] \\\\[ 0,0000 = m_{xм} - m_{yм} = 0 \\\\]\\n58\\n\\n11,00100000 = [M_x]^M 11,00100000 = [M_y]^M 10,01000000 = [M_s < 0]^M\\n\\\\[ |M_s| > 1 \\\\], так как 10, . . . в знаковых разрядах мантиссы результата. Необходима нормализация вправо 0,1111 = max \\(m_{xм}, m_{yм}\\) 10,01000000·2^{-1} = 1,00100000 0,0001\\n\\n1,0000—В старших разрядах порядка суммы код 1,0 . . . Это соответствует max \\(m_{xм}, m_{yм}\\) + 1 > m_{м. макс}\\) и результат принимается равным ∞."
    },
    {
        "tag": "пример 4 сложение чисел",
        "text": "Пример 4. Сложить два числа.\\n\\\\[ m_{xм} = 0001 \\\\] \\n\\\\[ m_{yм} = 0001 \\\\] \\n0,11110000 = [M_x]\\_n\\n1,11111000 = [M_y]\\_n\\n0,0001 = \\(m_{xм}\\)\\n1,1111 = [-0001]\\_n\\n0,0000 = \\(m_{xм} - m_{yм} = 0\\)\\n00,11110000 = [M_x]\\_n^M\\n11,00001000 = [M_y]\\_n^M\\n11,11111000 = [M_s < 0]\\_n^M\\n1,00001000 = [M_s < 0]\\_n\\n\\nНеобходима нормализация влево 0,0001 = max \\(m_{xм}, m_{yм}\\) 1,00001000·2^{+1} = 1,00010000 1,1111 = [-0001]\\_n 0,0000 1,00010000·2^{+1} = 1,00100000 1,1111 1,1111"
    }
]"}],
[
    {
        "tag": "условие переполнения в BCD",
        "text": "59\\n\\nВ старших разрядах исправляемого порядка суммы две единицы, это соответствует max \\(m_{xм}, m_{yм}\\) - i < m_{м. мин}, и сумма принимается равной нулю. Ответ: 0000 0,00000000."
    },
    {
        "tag": "введение в двоично‑десятичные системы счисления",
        "text": "2-7. Арифметические действия в двоично‑десятичных системах счисления\\n\\nДвоично‑десятичные системы счисления широко используются в ЭВМ как для представления чисел, так и для выполнения арифметических действий над ними. При этом методика выполнения арифметических действий над двоично‑десятичными числами, полностью базируясь на правилах двоичной арифметики, имеет свою специфику. Необходимость этой специфики становится очевидной при попытке осуществить суммирование двоично‑десятичных чисел, ограничиваясь правилами обычного суммирования двоичных кодов. Допустим, требуется сложить в системе 8421 или 8421 + 3 следующие десятичные цифры:\\n\\n\\\\[\\\\begin{array}{ccc} 5 & 0101 & 1000 \\\\\\\\ + & + & + \\\\\\\\ 6 & 0110 & 1001 \\\\\\\\ 11 & в системе & в системе & 10001 \\\\\\\\ 9 & 8421 & 8421 + 3 & 1100 \\\\\\\\ + & + & + \\\\\\\\ 8 & 1000 & 1011 \\\\\\\\ 17 & 10001 & 10111 \\\\\\\\ \\\\end{array}\\\\]\\n\\nВо всех примерах не получен правильный результат."
    },
    {
        "tag": "методика сложения в системе 8421",
        "text": "Методика выполнения сложения в системе 8421. В сложении двух чисел в \\(i\\)-м десятичном разряде участвуют \\(X_i + Y_i + p_{i+1} = S_i\\), здесь \\(X_i\\) и \\(Y_i\\) — тетрады \\(i\\)-х десятичных цифр, \\(p_{i+1}\\) — перенос из младшего десятичного разряда, равный 1 или 0. В результате суммирования этих кодов получаются предварительный код тетрады суммы \\(S_{in}\\) и перенос \\(P_i\\) в следующий десятичный разряд.\\n\\nСпецифика сложения в данной системе кодирования проявляется в выработке импульса переноса \\(P_i\\), когда \\(X_i + Y_i + p_{i+1} \\geq 10\\). В системе 8421 этот перенос вырабатывается двояким образом. В том случае, когда \\(X_i + Y_i + p_{i+1} \\geq 16\\), переносу \\(P_i\\) соответствует единица переноса, возникающая в разряде с весом \\(2^3\\): это так называемый естественный перенос. В случае, когда \\(15 \\geq X_i + Y_i + p_{i+1} \\geq 10\\), имеет место искусственный перенос, вырабатываемый специальной схемой.\\n\\nЛогика работы этой схемы определяется следующим образом:\\n\\n\\\\[S_{in}\\\\]\\n\\n\\\\[\\\\begin{array}{cccc} a_8 & a_4 & a_2 & a_1 \\\\\\\\ 1 & 0 & 1 & 0 \\\\\\\\ 1 & 0 & 1 & 1 \\\\\\\\ 1 & 1 & 0 & 0 \\\\\\\\ 1 & 1 & 0 & 1 \\\\\\\\ 1 & 1 & 1 & 0 \\\\\\\\ 1 & 1 & 1 & 1 \\\\\\\\ \\\\end{array}\\\\]\\n\\nРассмотрим все возможные комбинации \\(S_{in}\\), которые определяются неравенством \\(15 \\geq X_i + Y_i + p_{i+1} = S_{in} \\geq 10\\). Все приведенные коды объединяются одним логическим"}],
[{"tag":"вычитание в системах 8421 и 8421+3","text":"Методика выполнения вычитания в системах 8421 и 8421 + 3. Так же как и в обычной двоичной системе, здесь операция вычитания заменяется суммированием дополнительных, обратных кодов слагаемых. При этом системы кодирования двоично-десятичных чисел подразделяются на две группы."},{"tag":"самодополняющая система 8421+3","text":"Самодополняющиеся, где получение обратного и дополнительного кодов получается за счет отрицания двоичных кодов десятичных цифр отрицательного числа. К этой группе относится система 8421 + 3. Например, \\[-11001001001,1000 = -960,5]_{o} = 1,001101101100, 0111\\]. Дополнительный код получается за счет прибавления к обратному коду 1 в младший двоичный разряд младшей десятичной цифры."},{"tag":"несамодополняющая система 8421","text":"Несамодополняющиеся, в которых обратный код получается с помощью специальных преобразующих схем. К этой группе относится система 8421. Выпишем для этой системы двоичные коды десятичных цифр \\((a_8 a_4 a_2 c_1)\\) и соответствующие им тетрады обратного кода десятичных цифр \\((c_8 c_4 c_2 c_1)\\)."},{"tag":"таблица кодов 8421","text":"\\[\\begin{array}{cccccc} 0 = 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 = 9 = 0 \\\\ 1 = 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 = 8 = 1 \\\\ 2 = 0 & 0 & 1 & 0 & 0 & 1 & 1 & 1 = 7 = 2 \\\\ 3 = 0 & 0 & 1 & 1 & 0 & 1 & 1 & 0 = 6 = 3 \\\\ 4 = 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 = 5 = 4 \\\\ 5 = 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 = 4 = 5 \\\\ 6 = 0 & 1 & 1 & 0 & 0 & 0 & 1 & 1 = 3 = 6 \\\\ 7 = 0 & 1 & 1 & 1 & 0 & 0 & 1 & 0 = 2 = 7 \\\\ 8 = 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 = 1 = 8 \\\\ 9 = 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 = 0 = 9 \\\\ \\end{array}\\]"},{"tag":"логические уравнения преобразования в обратный код","text":"Анализ этих кодов показывает, что \\[c_1 = \\bar{a}_1;\\] \\[c_2 = a_2;\\] \\[c_4 = \\bar{a}_4 \\land a_2 \\lor a_4 \\land \\bar{a}_2;\\] \\[c_8 = \\bar{a}_8 \\land \\bar{a}_4 \\land \\bar{a}_2.\\] Эти логические уравнения и описывают работу схем преобразования в обратный код в системе 8421."},{"tag":"пример вычитания в системе 8421","text":"Пример 1 (система 8421). \\[\\begin{array}{cccc} 358 & 0,0000 & 0011^\\diamondsuit & 0101 & 1000 \\\\ -1739 & 1,1000 & 0010 & 0110 & 0000 = [-1739]_o \\\\ -1381 & 1,1000 & 0110 & 1011 & 1000 \\\\ & & & 0110 & \\\\ \\end{array}\\] \\[\\begin{array}{cccc} 1,1000 & 0110 & 0001 & 1000 - \\text{обратный ход} \\\\ 1,0001 & 0011 & 1000 & 0001 - \\text{прямой ход} \\\\ \\end{array}\\]"},{"tag":"пример вычитания в системе 8421+3","text":"Пример 2 (система 8421 + 3). \\[\\begin{array}{cccc} 1739 & 0^1,0100^1 & 1010 & 0110^1 & 1100 \\\\ -358 & 1,1100 & 1001 & 0111 & 0100 \\\\ & & & 1 & \\\\ 1381 & 0,0001 & 0011 & 1110 & 0001 \\\\ & 0011 & 0011 & 1101 & 0011 \\\\ & & & 0,0100 & 0110 & 1011 & 0100 \\\\ \\end{array}\\] = [-358]_x"},{"tag":"методика умножения и деления","text":"Методика выполнения умножения и деления. Выполнение этих операций основано на использовании сложения и вычитания. Существует несколько способов выполнения операций умножения и деления, которые не зависят от принятой системы кодирования десятичных чисел. На практике применяется ограниченное количество различных методов, это особенно характерно для операции деления."},{"tag":"рекуррентная формула умножения","text":"Самая простая методика умножения с младших разрядов иллюстрируется рекуррентной формулой, аналогичной (2-19): \\[A_i = A_{i-1} \\cdot 2^{-4} + XY_{n+1-i};\\] здесь \\( X \\) — множимое, содержащее \\( n \\) десятичных разрядов, а \\( Y_{n+1-i} \\) — десятичная цифра множителя."},{"tag":"таблица суммирования при умножении (0-5)","text":"\\[\\begin{array}{c|cc} Y_{n+1-i} & A_{i-1} \\cdot 2^{-4} + XY_{n+1-i} \\\\ \\hline 0 & A_{i-1} \\cdot 2^{-4} + 0 \\\\ 1 & A_{i-1} \\cdot 2^{-4} + X \\\\ 2 & A_{i-1} \\cdot 2^{-4} + 2X \\\\ 3 & A_{i-1} \\cdot 2^{-4} + X + 2X \\\\ 4 & A_{i-1} \\cdot 2^{-4} + 2X + 2X \\\\ 5 & A_{i-1} \\cdot 2^{-4} + X + 2X + 2X \\\\ \\end{array}\\]"},{"tag":"таблица суммирования при умножении (6-9)","text":"\\[\\begin{array}{c|cc} Y_{n+1-i} & A_{i-1} \\cdot 2^{-4} + XY_{n+1-i} \\\\ \\hline 6 = 10 - 4 & A_{i-1} \\cdot 2^{-4} - 2X - 2X \\\\ 7 = 10 - 3 & A_{i-1} \\cdot 2^{-4} - X - 2X \\\\ 8 = 10 - 2 & A_{i-1} \\cdot 2^{-4} - 2X \\\\ 9 = 10 - 1 & A_{i-1} \\cdot 2^{-4} - X \\\\ \\end{array}\\]"},{"tag":"пример преобразования множителя","text":"В случае такой замены Y_{n+1-i} и цифры множителя Y_{n-1} я цифра множителя (старшая по отношению к Y_{n+1-i} увеличивается на единицу). В результате такого преобразования множитель 175928 будет иметь вид \\(2 \\frac{2}{4} \\frac{1}{3} \\frac{2}{2}\\)."},{"tag":"методика деления","text":"**Деление.** Простейший метод выполнения этой операции связан с последовательным вычитанием делителя \\( Y \\) и формированием кода частного \\( Z_i = 0 + 1 + 1 + \\cdots + 1 \\), на каждое вычитание прибавляется единица. Такая процедура выполняется до тех пор, пока \\( \\alpha_i = 2^4 \\cdot \\alpha_{i-1} - Z_i Y < 0 \\). Если \\( \\alpha_i < 0 \\), то \\( \\alpha_i + Y \\) (восстановление остатка) и затем \\[ \\alpha_{i+1} = 2^4 (\\alpha_i + Y) - Z_{i+1}Y. \\]"}]"}],
[
    {
        "tag": "модификация метода деления",
        "text": "На практике часто используется несколько видоизмененная методика. В ней если \\\\( \\\\alpha_i < 0 \\\\) , то \\\\( \\\\alpha_{i+1} = 2^4 \\\\alpha_i + Z_{i+1}Y \\\\) — производится прибавление \\\\( Y \\\\) , одновременно формируется код псевдо-частного \\\\( Z_{i+1} = 1 + 1 + \\\\cdots + 1 \\\\). Эта процедура выполняется до тех пор, пока \\\\( \\\\alpha_{i+1} \\geq 0 \\\\). Код \\\\( Z_{i+1} \\\\) является дополнительным кодом \\\\( Z_{i+1} \\\\) , т. е. \\\\( Z_{i+1} = 10 - Z_{i+1} \\\\). При таком алгоритме двоичные коды \\\\( Z_i \\\\) получаются в прямом (при \\\\( \\\\alpha_{i-1} \\geq 0 \\\\)) или дополнительном (при \\\\( \\\\alpha_{i-1} < 0 \\\\)) кодах. Обоснованием такой модификации методики является то, что вычитание, вызвавшее \\\\( \\\\alpha_i < 0 \\\\) , эквивалентно десяти вычитаниям, производимым при определении \\\\( Z_{i+1} \\\\) — цифры соседнего младшего разряда частного. И цифра \\\\( Z_{i+1} \\\\) может быть определена по номеру той операции сложения, которая приводит снова к положительному остатку."
    },
    {
        "tag": "таблицы арифметических операций",
        "text": "**Выполнение арифметических действий с помощью таблиц.** Таблица — это специализированное запоминающее устройство, в котором хранятся результаты арифметической операции над кодами двоично-десятичных чисел i-го разряда. Коды исходных десятичных чисел в i-м разряде являются адресами, в соответствии с которыми осуществляется выбор результата из таблицы арифметической операции. При параллельном выполнении операции необходимо на каждый десятичный разряд иметь таблицы сложения, вычитания, умножения, деления (таблицы арифметических операций). При этом выполнение любой операции будет заключаться в одновременном обращении к n таблицам (\\\\( n \\\\) — количество десятичных цифр). На практике есть примеры реализации последовательной методики выполнения арифметических операций с помощью таблиц. Здесь в составе \\\\( AY \\\\) имеется по одной таблице на каждую арифметическую операцию. При обращении к этой таблице последовательно во времени разряд за разрядом формируется результат арифметической операции."
    },
    {
        "tag": "таблица сложения",
        "text": "Рассмотрим принципы организации таблиц. Таблица сложения. Исходной информацией (адресами) являются двоичные коды десятичных цифр — \\\\( X_i \\\\) и \\\\( Y_i \\\\) , а также \\\\( P_{i+1} \\\\) — единица переноса из младшего разряда. Результат, считываемый из таблицы, определяет код \\\\( S_i \\\\) (код единиц) и код \\\\( P_i \\\\) (код десятков)."
    },
    {
        "tag": "таблица вычитания",
        "text": "Таблица вычитания. В рассматриваемой методике нет необходимости обращения к дополнительным и обратным кодам. Исходной информацией являются \\\\( X_i \\\\) и \\\\( Y_i \\\\) и \\\\( P_{i+1} \\\\) — в данном случае являющаяся единицей займа. Соответственно и результат представляется кодом \\\\( S_i \\\\) (код разности — код единиц) и кодом \\\\( P_i \\\\) (код займа — код десятков)."
    },
    {
        "tag": "таблица умножения",
        "text": "Таблица умножения. Обеспечивает получение произведения \\\\( X_iY_i \\\\) , состоящего из кода единиц — \\\\( Z_i \\\\) и кода десятков — \\\\( P_i^h \\\\) , который в данном случае может принимать значения от 0 до 8."
    },
    {
        "tag": "алгоритм умножения с таблицами",
        "text": "Рассмотрим алгоритм умножения \\\\( n \\\\)-разрядного множилого — \\\\( X_1 \\ldots X_n \\\\) на одну цифру множителя \\\\( Y_j \\\\) , реализуемый с помощью двух таблиц: умножения и сложения. Этот алгоритм состоит из последовательного повторения этапов, обеспечивающих \\\\( X_iY_j \\\\) . В каждом этапе участвуют коды \\\\( X_i \\\\) , \\\\( Y_j \\\\) и \\\\( P_{i+1}^0 \\\\) — обобщенный перенос десятков, возникающий при умножении \\\\( X_{i+1} \\\\) на \\\\( Y_j \\\\) десятичную цифру. Каждый этап состоит из трех последовательно выполняемых тактов: первый такт — обращения к таблице умножения с целью получения предварительного кода произведения \\\\( Z_i^n \\\\) , и кода десятков — \\\\( P_{i,j}^h \\\\) , второй такт — обращение к таблице сложения с целью получения кода \\\\( Z_i \\\\) , \\\\j = Z_i^n + P_{i+1}^0 \\\\) , и кода переноса единицы — \\\\( P_{i,j}^1 \\\\) , третий такт — вновь обращение к таблице сложения с целью получения \\\\( P_{i,j}^0 = P_{i,j}^h + P_{i,j}^1 \\\\) . Например:\n\n\\\\[X_i = 8\\\\]\n\\\\[Y_j = 6\\\\]\n\\\\[P_{i+1}^0 = 5\\\\]\n\\\\[\\\\begin{aligned} &8 = Z_i^n \\\\\\\\ &4 = P_{ij}^h \\\\end{aligned}\\\\]\n\\\\[\\\\begin{aligned} &8 = Z_i^n \\\\\\\\ &5 = P_{i+1}^0 \\\\\\\\ &3 = Z_i \\cdot i \\\\\\\\ &1 = P_{i,j}^1 \\\\\\\\ &4 = P_{i,j}^h \\\\\\\\ &1 = P_{i,j}^1 \\\\end{aligned}\\\\]\n\\\\[\\\\begin{aligned} &5 = P_{i,j}^0 = P_{i,j}^h + P_{ij}^1. \\\\end{aligned}\\\\]"
    },
    {
        "tag": "операция умножения n-разрядных чисел",
        "text": "Операция умножения \\\\( n \\\\)-разрядных чисел состоит из \\\\( j \\\\) этапов (\\( j = n \\ldots 1 \\) при умножении с младших разрядов). В каждом этапе выполняется умножение \\((X_1 \\ldots X_n) Y_j\\) и прибавление полученного кода к частичному произведению: \\( A_{j-1} + (X_1 \\ldots X_n) Y_j \\cdot 2^{j-1} \\). Необходимый сдвиг должен осуществляться за счет переадресации ячеек оперативного запоминающего устройства, где хранятся двоичные коды десятичных цифр произведения \\((X_1 \\ldots X_n) Y_j\\)."
    },
    {
        "tag": "методика деления с таблицами",
        "text": "Методика выполнения операции деления с помощью таблиц деления и непосредственно таблицы деления являются сложными и труднореализуемыми на практике. Поэтому операция деления выполняется по итерационным формулам, использующим сложение, вычитание и умножение, реализуемым с помощью таблиц. Рассмотренная методика нашла применение в отечественных вычислительных машинах серии МИР."
    },
    {
        "tag": "методика округления результатов арифметических операций",
        "text": "2-8. Методика округления результатов арифметических операций. Проблема точности вычислений в ЭВМ зависит от многих факторов: от выбора разрядной сетки, системы счисления, от способа представления чисел. Кроме указанного, одним из факторов, влияющих на точность вычислений, являются ошибки результатов арифметических операций, которые неизбежны в силу ограниченной разрядной сетки. С целью уменьшения влияния погрешности результатов арифметических операций на точность вычисления в ЭВМ широко используется округление. Основная цель округления: сделать ошибку результатов арифметических операций разного знака по отношению к абсолютному значению результатов, что позволит уменьшить накопление ошибок при выполнении большого количества операций при решении задачи на ЭВМ; уменьшить абсолютное значение ошибки результата. Рассмотрим методику округления результатов арифметических операций, представленных в прямом коде, над числами с фиксированной запятой.\n\nСложение—вычитание. В этих операциях округление не применяется, так как в процессе выполнения операции не возникает ошибок.\n\nУмножение. При умножении с младших разрядов множителя, перемножая \\\\( n \\\\)-разрядные сомножители, получаем \\\\( 2n \\\\)-разрядное произведение. В формировании \\\\( n \\\\)-разрядного произведения отбрасываются разряды с весами от \\\\( 2^{-n-1} \\\\) до \\\\( 2^{-2n} \\\\). В результате вносится погрешность \\( \\Delta_{xy \\text{макс}} = 2^{-n} - 2^{-2n} \\approx 2^{-n} \\) и \\( \\Delta_{xy \\text{мин}} = 2^{-2n} \\). Результат всегда получается с недостатком по отношению к абсолютному значению произведения. Осуществление округления: прибавление единицы в разряд с весом \\\\( 2^{-n-1} \\\\) (в десятичной системе это соответствует прибавлению \\\\( 5 = P/2 \\\\)) уменьшает \\( \\Delta_{xy \\text{макс}} = 2^{-n-1} \\) и делает её разного знака. После округления результат может быть как с недостатком, так и с избытком. Ниже приведены примеры округления, соответствующие предельным значениям погрешности произведения. При округлении произведения, равного\n\n\\\\[\\begin{array}{ccc} 0, & z_1 & \\cdots & z_n \\\\ & & +1 \\\\end{array}\\\\]\n\nполучаем результат с недостатком и с погрешностью \\( \\Delta_{xy} = 2^{-n-1} - 2^{-2n} \\).\n\nПри округлении произведения, равного\n\n\\\\[\\begin{array}{cccccc} 0, & z_1 & \\cdots & z_{n-3} & 0 & 1 & 1 & 0 & \\cdots & 0 \\\\ & & & & +1 & & & & & \\\\ 0, & z_1 & \\cdots & z_{n-3} & 1 & 0 & 0 & & & \\\\end{array}\\\\]\n\nполучаем результат с избытком и с погрешностью \\( \\Delta_{xy} = 2^{-n-1} \\).\n\nВозможно округление прибавлением случайной единицы в разряд с весом \\\\( 2^{-n-1} \\\\). Ошибка округления \\(|\\Delta_{xy}| \\leq 2^{-n}\\) и имеет разный знак.\n\nНедостаток рассмотренных методик округления заключается в том, что на выполнение округления требуется время, равное времени суммирования двух чисел. Этот недостаток исключается, если округление производить одновременно с прибавлением произведения множимого на последнюю цифру множителя или младший разряд произведения \\((z_n)\\) принимать всегда равным 1. При \\(z_n = 1\\) погрешность произведения имеет разный знак и её значение \\(|\\Delta_{xy}| \\leq 2^{-n}\\).\n\nНа практике широкое распространение получила методика, основанная на прибавлении единицы в старший из отбрасываемых разрядов.\n\nУмножение со старших разрядов выполняется, как правило, в \\( n + d \\)-разрядной сетке. При формировании \\( n \\)-разрядного произведения отбрасываются разряды с \\( n + 1 \\) по \\( n + d \\), что приводит к результату с недостатком. Здесь так же, как и при умножении с младших разрядов, необходимо проводить округление по одной из методик, рассмотренных выше."
    }
]"}],
[{"tag":"деление со сдвигом остатка","text":"**Деление.** При делении со сдвигом остатка возможно получение бесконечного ряда цифр частного. Формируя \\(n\\)-разрядное частное, получаем результат с недостатком с погрешностью \\(|\\Delta_{x,y}|_{\\text{макс}} \\approx 2^{-n}\\). Применяя округление (допустим, прибавление единицы в разряд с весом \\(2^{-n-1}\\)), уменьшаем ошибку в 2 раза, получаем ее разных знаков. При этом в частном достаточно иметь \\(n + 1\\) цифру после запятой."},{"tag":"деление со сдвигом делителя","text":"При делении со сдвигом делителя в \\(n + d\\)-разрядной сетке частное может иметь как положительную, так и отрицательную погрешность. Соответственно округление по ранее рассмотренным методикам здесь недопустимо, так как погрешность результата вместо уменьшения может даже возрастать."},{"tag":"частное с избытком","text":"Здесь частное с избытком будет тогда, когда \\( Z = X/Y = 0, z_1 \\ldots z_{i-1} \\ldots 1 \\), т. е. частное имеет все единицы начиная с i-го разряда. Этому коду, начиная с i-го такта, будут соответствовать все положительные остатки, и в каждом такте деления будет выполняться \\( \\alpha_{i-1} - Y \\cdot 2^{-i} = \\alpha_i \\). Поскольку деление происходит в \\( n + d \\)-разрядной сетке, то начиная с определения \\( d + 1 \\) цифры частного часть разрядов делителя выходит за разрядную сетку и теряется. Все сказанное можно представить в виде равенства \\( \\alpha_{i-1} - (Y \\cdot 2^{-i} - \\gamma) = \\alpha_i \\), где \\( \\gamma \\) — код потерянных разрядов делителя. В результате делитель уменьшается, а остаток увеличивается и частное получается с избытком."},{"tag":"частное с недостатком","text":"Если \\( Z = X/Y = 0, z_1 \\ldots z_{i-1} \\ldots 0 \\), то начиная с i-го такта деления все остатки \\( \\alpha_i \\ldots \\alpha_n < 0 \\) и в каждом такте начиная с i-го \\( \\alpha_{i-1} + (Y \\cdot 2^{-i} - \\gamma) = \\alpha_i \\). В данном случае уменьшение делителя приведет к уменьшению остатка и частное будет получаться с недостатком."},{"tag":"методика округления результатов","text":"Все изложенное определяет основу методики округления результатов, которая развивается и усложняется при арифметических операциях над числами с плавающей запятой, над числами, представленными в дополнительном или обратном кодах."},{"tag":"округление дополнительного и обратного кода","text":"Округлению дополнительного кода отрицательного результата должен предшествовать перевод его в прямой код. При округлении обратного кода отрицательного результата вместо прибавления единицы следует вычитать единицу из старшего отбрасываемого разряда результата."},{"tag":"ошибки при сложении и вычитании с плавающей запятой","text":"Усложнение методики округления результатов арифметических операций над числами с плавающей запятой определяется следующим. Здесь результат сложения—вычитания получается с ошибкой из-за денормализации мантиссы меньшего слагаемого при выравнивании порядка и нормализации мантиссы суммы (разности) вправо. Источником дополнительной погрешности при делении является нормализация мантиссы частного."},{"tag":"округление сложения‑вычитания с плавающей запятой","text":"Методика округления сложения—вычитания с плавающей запятой зависит от знаков чисел, участвующих в операции. При суммировании чисел одинаковых знаков округлению должна подвергаться нормализованная мантисса результата. При суммировании чисел разных знаков округление в соответствии с рассмотренными выше методиками исключается. Здесь возникающая ошибка складывается из кода группы цифр, отброшенной при выравнивании порядков, и значения цифры дополнительного разряда, который отбрасывается при формировании окончательного результата. Эти ошибки имеют противоположные знаки, и каждая из них — \\( \\Delta \\leq 2^{-n-1} \\). Ошибка за счет отбрасывания разрядов при выравнивании порядков имеет знак, противоположный знаку суммы. Ошибка другого знака возникает при отбрасывании дополнительного разряда суммы."},{"tag":"глава 3 основные понятия об элементах ЭВМ","text":"Глава третья ОСНОВНЫЕ ПОНЯТИЯ О ЭЛЕМЕНТАХ ЭВМ"},{"tag":"раздел 3-1 типы и системы элементов","text":"3-1. Типы и системы элементов"},{"tag":"логические элементы","text":"Современные цифровые вычислительные машины, и прежде всего их арифметические устройства, состоят из большого количества простейших электронных схем. Эти электронные схемы называются элементами, и они осуществляют преобразование или хранение сигналов, представляющих числовую или логическую информацию. Элементы, реализующие преобразование сигналов, подразделяются на две группы. Первая группа элементов осуществляет логическое преобразование и является группой логических элементов, каждый из которых реализует выполнение одной из элементарных логических функций. Наборы логических элементов, или базисы, определены в логических основах в виде понятия функционально‑полных систем элементарных логических функций. Известны базисы, состоящие из элементов, выполняющих \\( V \\), \\( A \\) и \\( V' \\), а также широко используемые в последнее время однокомнатные базисы, реализующие элементарные логические функции штрих Шеффера (И—НЕ) или стрелку Пирса (ИЛИ—НЕ)."},{"tag":"физические элементы","text":"Вторая группа элементов осуществляет физическое преобразование, которое проявляется в усилении сигналов, в восстановлении их формы (длительности, фронтов). Это группа вспомогательных элементов. Набор логических элементов (базис), дополненный вспомогательными элементами, которые обеспечивают все электрические и временные особенности взаимо‑связанной работы логических элементов, является технически полным."},{"tag":"элементы хранения","text":"Третья группа элементов — элементы хранения или памяти. Классическим примером элементов этой группы являются статические и динамические триггеры, которые широко применялись в машинах 1‑го и 2‑го поколений. В настоящее время в качестве элементов этой группы широко используются различные типы триггеров, построенные на элементах базиса И—НЕ или ИЛИ—НЕ."},{"tag":"система элементов","text":"Все три группы элементов образуют систему элементов. Под системой элементов подразумевается логически и технически полный набор элементов, включая элементы хранения, использующие одинаковые способы представления информации и межэлементных связей."},{"tag":"виды систем элементов","text":"В практике построения ЭВМ и их устройств широко используются различные системы элементов, отличающиеcя по способу представления двоичной информации. К их числу относятся потенциальные, потенциально‑импульсные и импульсные системы элементов."},{"tag":"потенциальная система элементов","text":"В потенциальной системе элементов двоичная информация представляется высоким и низким уровнем напряжения. Потенциальный сигнал сохраняет постоянный уровень в течение времени, необходимость для представления информации в любой точке схемы. Значение потенциального сигнала в переходные моменты (с низкого на высокий и наоборот) не является определенным. Для элементов этих систем характерны прямые гальванические связи. Потенциальные системы элементов получили широкое распространение в машинах 3‑го поколения."},{"tag":"импульсная система элементов","text":"В импульсной системе элементов двум значениям двоичной информации соответствует либо положительный и отрицательный электрический импульс, либо наличие"}],
[{"tag":"транзисторно-транзисторный элемент И—НЕ","text":"В настоящее время широкое распространение получили транзисторно-транзисторные элементы И—НЕ и ИЛИ—НЕ. Одна из таких схем со сложным инвертором приведена на рис. 3-2. В этой схеме сигналу I и сигналу 0 соответствуют положительные сигналы высокого и низкого уровня. На схеме рис. 3-2 роль конъюнктора на четыре входа выполняет многомитетный транзистор \\( T_1 \\). На транзисторах \\( T_2, T_3 \\) и \\( T_4 \\) реализован сложный инвертор. Если на все входы многомитетного транзистора поданы сигналы, соответствующие I, то транзистор \\( T_2 \\) открыт, при этом открыт \\( T_4 \\), а \\( T_3 \\) закрыт, и на выходе имеется сигнал, соответствующий нулю. Если на один из входов \\( T_1 \\) поступит низкий уровень, соответствующий 0, то закрывается \\( T_2 \\), при этом закрывается транзистор \\( T_4 \\), а открывается \\( T_3 \\). На выходе возникает сигнал, соответствующий 1 и приблизительно равный + E."},{"tag":"RS-триггер на И—НЕ","text":"Самый простой тригер в рассматриваемой системе элементов можно получить из двух элементов И—НЕ или ИЛИ—НЕ, взаимно охваченных обратной связью, что и показано на рис. 3-4. На этих же рисунках приведены таблицы переходов, иллюстрирующих работу триггеров и их условные обозначения. В таблицах перехода каждой входной комбинации ставится в соответствие одно из возможных состояний триггерa: 0,1, Q (t), \\(\\bar{Q} (t)\\), ? — неопределенное состояние. В таблицах перехода состояние триггера, предшествующее подаче сигналов по входам S (\\(\\bar{S}\\)) и R (\\(\\bar{R}\\)) в момент t, обозначается Q (t), состояние триггера после поступления сигналов на его входы Q (t + 1). Рассмотрим работу триггера, построенного на элементах И—НЕ. Здесь подача сигналов, соответствующих 1 (высокий уровень), на входы S и R не приведет к изменению состояния триггера: \\( Q(t + 1) = Q(t) \\), что соответствует режиму хранения. Подача сигнала высокого уровня только по входу S или только по входу R приводит к установке триггера в положение 0 или 1 соответственно. Подача сигналов, соответствующих 0 (низкий уровень), на входы $ и R запрещена. Аналогично работает тригер, построенный на элементах ИЛИ—НЕ. Здесь запрещена подача сигналов, соответствующих 1, на входы $ и R. Такие простейшие триггеры обычно называют RS-триггерами или запоминающими ячейками (ЗЯ). Они имеют два устойчивых состояния и в любом из них могут находиться сколь угодно долго. Переключение ЗЯ начинается после поступления сигнала на вход S (S) или вход R (R)."},{"tag":"master-slave (MS) триггер","text":"При построении схем ЭВМ обычно используется триггер с более сложной организацией. К таким триггерам следует отнести синхронный триггер, схема которого показана на рис. 3-5. Здесь на входах RS-триггера введены элементарные логические схемы И—НЕ, управляемые сигналом, поступаемым по шине С. Сигналы 5 и & проходят на входы триггера лишь при подаче сигнала по шине синхронизации С. Обобщенная схема триггера со сложной организацией изображена на рис. 3-6. Здесь к ЗЯ добавлена предварительная ступень логической обработки: входной информации X; информации, поступающей по обратным связям с выхода ЗЯ, y; управляющей информации г, которая, например, определяет простую передачу входной информации X, передачу х со сдвигом и T. При работе такой схемы обеспечить одновременное поступление сигналов"}],
[{"tag":"промежуточные группы АУ","text":"Существует и промежуточная группа — АУ последовательно-параллельного (параллельно-последовательного) действия. Такой тип представления и обработки информации не оказывает существенного влияния на принципы и основы построения основных узлов. В состав таких АУ входят узлы как параллельного, так и последовательного действия."},{"tag":"регистры хранения и сдвига","text":"4-1. Регистры хранения и сдвига\n\nРегистры подразделяются на две группы: статические и динамические регистры."},{"tag":"статический регистр","text":"Работа статического регистра проста и полностью иллюстрируется логической схемой, изображенной на рис. 4-1. Здесь для хранения \\( n \\)-разрядного кода используется \\( n \\) синхронных триггеров."},{"tag":"шина R и гашение","text":"Объединение \\( R \\)-входов каждого триггера общей шиной образует шину у «0» или цепь гашения. Для того, чтобы установить все триггеры в 0, необходимо одновременно подать сигналы по шине \\( I \\) и по шине \\( C \\) (\\( ГИ \\))."},{"tag":"прием кода в регистре","text":"Двоичный код \\( x_1 \\ldots x_n \\), появляющийся на шинах, непосредственно связанных с S-входами каждого разряда регистра, принимается на триггере только при подаче сигнала по шине \\( C \\) (\\( ГИ \\)). Так реализуется элементарное действие — прием."},{"tag":"временные параметры RS-триггера","text":"Время выполнения рассмотренных элементарных действий определяется временными параметрами \\( RS \\)-триггера: \\( t_s \\) и \\( t_\\phi \\)."},{"tag":"выдача и преобразование кода","text":"Реализация элементарных действий выдачи (выдача прямого кода) и преобразования (выдача обратного кода) осуществляется с помощью элементов И—НЕ, объединенных по своим входам шиной / и шиной ///. Для выполнения этих действий достаточно подать сигнал по одной из указанных шин. Время выполнения выдачи и преобразования — определяется — задержкой — переключения схемы И—НЕ и длительностью сигнала, подаваемого по шине // и шине ///."},{"tag":"парафазная передача","text":"В практике построения узлов и устройств ЭВМ широко распространена так называемая парафазная передача. Сущность ее иллюстрируется схемой, приведенной на рис. 4-2. Здесь осуществлена непосредственная (прямая) коммутация выходов одного элемента хранения со входами другого. При этом прямой выход (Q) Т, коммутируется со входом S-триггера T}, а инверсный выход (Q) Т, — со входом \\( R \\)-триггера \\( T_i' \\). Передача при этом осуществляется подачей сигнала по шине \\( C \\)."},{"tag":"регистры сдвига на MS-триггерах","text":"При наличии \\( MS \\)-триггеров с помощью парафазной передачи кодов легко реализуется регистр сдвига. Его схема, осуществляющая сдвиг на один разряд в сторону младших разрядов, приведена на рис. 4-3, \\( a \\). В схеме на \\( MS \\)-триггерах в каждой паре разрядов осуществляется парафазная передача с выходов \\( i \\)-го разряда (старшего) на вход \\( (i + 1) \\)-го разряда (младшего). Для осуществления такой передачи достаточно подать один сигнал по шине \\( C \\). На рис. 4-3, \\( б \\) показана такая же схема регистра, но с изображением \\( MS \\)-триггера в виде двух \\( RS \\)-триггеров. Эта схема позволяет более подробно проиллюстрировать реализацию сдвига. Здесь при подаче сигнала по шине \\( C \\) в первом такте происходит передача со сдвигом кода из выходных триггеров \\( T_i' \\) во входные \\( T_{i+1} \\). А во втором такте по сигналу \\( C \\), позволяющемуся на выходе инвертора, осуществляется собственно фиксация сдвинутого кода в выходных триггерах. Условное изображение регистра сдвига в соответствии с ГОСТ 2.743-72 изображено на рис. 4-3, \\( e \\)."},{"tag":"временная диаграмма и время сдвига","text":"На рис. 4-4 приведена временная диаграмма работы рассмотренного регистра сдвига. Данная диаграмма построена при условии, что на регистре зафиксирован код 10101010 . . . Исходное состояние трех промежуточных разрядов регистра соответствует коду 101. После подачи сигнала по шине C через время, равное \\( t_s + t_\\phi \\), устанавливается сдвинутый код 010 и т. д. Любой регистр сдвига характеризуется своим временным параметром (быстродействие регистра) — время сдвига (\\( t_{cAB} \\)). Это время легко определяется с помощью временной диаграммы: \\[t_{cAB} > t_u + t_s + t_\\phi.\\]"},{"tag":"логические операции на регистре хранения","text":"Статические регистры широко применяются в АУ параллельного действия. На основе рассмотренного регистра легко реализуется параллельное выполнение ряда логических операций. К их числу относятся логическое сложение, логическое умножение, сложение по модулю 2. Реализация всех указанных операций на регистре хранения с цепями парафазного приема кодов \\( x_i \\) и \\( y_i \\) отражена на рис. 4-5, где показан один разряд регистра. Выполнение рассматриваемых логических операций осуществляется в два этапа. Первый этап одинаков для всех трех операций. Это парафазная передача кода \\( x_i \\) на регистр хранения (подаются сигналы по шинам \\( \\Pi_{x_i} \\) и \\( C \\)), которая исключает предварительную установку в нуль элементов хранения. Для операции логического сложения второй этап — это подача сигнала по шине \\( J/C \\). Передается код \\( y_i \\) на вход S триггера. Выполнение операции логического умножения требует подачи сигнала по шине \\( J/V \\). Передается \\( y_i \\) на вход R триггера. Правильный код результата подтверждается таблицей истинности (табл. 4-1). В операции сложения по модулю 2: \\( x_i \\oplus y_i = \\bar{x}_i \\land y_i \\lor x_i \\land \\bar{y}_i \\), второй этап — это подача сигнала по шине \\( \\oplus \\). При этом на каждый разряд регистра требуются два трехвходовых конъюнктора, на которые поступают сигналы как с выхода триггера (\\( Q_i = x_i \\) и \\( \\bar{Q}_i = \\bar{x}_i \\)), так и код \\( \\bar{y}_i \\) и \\( \\bar{y}_i \\)."},{"tag":"динамические регистры","text":"**Динамические регистры.** В таких регистрах код в режиме хранения постоянно циркулирует по замкнутому кольцу. В настоящее время их основой является замкнутый (закольцованный) стат"}],
[
    {
        "tag": "режимы динамического регистра",
        "text": "При таких понятиях, если в динамическом регистре реализуется условие \\( t_{u. u} = t_{u. cx} \\), выполняется режим хранения; если \\( t_{u. u} > t_{u. cx} \\) и при этом \\( t_{u. u} = t_{u. cx} + kt_{cдв} \\), то выполняется режим сдвига на \\( k \\) разрядов в сторону старших разрядов; если \\( t_{u. u} < t_{u. cx} \\) и \\( t_{u. u} = t_{u. cx} - mt_{cдв} \\), то выполняется режим сдвига на \\( m \\) разрядов в сторону младших разрядов. При этом, чтобы исключить потерю разрядов при сдвиге в сторону младших разрядов, значение \\( t_{u. cx} \\) всегда выбирается из условия \\[t_{u. cx} = (n + m) t_{cдв},\\] где \\( n \\) — количество разрядов хранимого и сдвигаемого кода, а \\( m \\) — максимальное количество разрядов, на которое осуществляется сдвиг в сторону младших разрядов."
    },
    {
        "tag": "схема и сигналы динамического регистра",
        "text": "Все указанные режимы хранения и сдвига реализуются при построении динамического регистра в соответствии со схемой, изображенной на рис. 4-8. В этом регистре настройка его на один из трех режимов определяется подачей сигнала, соответствующего логической 1 только на одну из трех шин: I (сдвиг на \\( m \\) разрядов), II (хранение), III (сдвиг на \\( k \\) разрядов)."
    },
    {
        "tag": "временная диаграмма динамического регистра",
        "text": "Справедливость всего изложенного очевидна из рассмотрения временной диаграммы работы динамического регистра, изображенной на рис. 4-9. Эта временная диаграмма соответствует следующим условиям. Подлежит хранению и сдвигу шестиразрядный код: \\( n = 6 \\), \\( k = m = 1 \\); соответственно \\( t_{ц. cx} = (n + m) \\; t_{cдв} = 7 \\; t_{cдв} \\). Исходное состояние кода, которое циркулирует младшими разрядами вперед, изображено на рис. 4-8 в соответствии со своими весами от \\( 2^{-1} \\) до \\( 2^{-6} \\). В том случае, когда цикл циркуляции (разрядность регистра сдвига) становится больше \\( n \\), коды в дополнительных разрядах принимаются равными нулю."
    },
    {
        "tag": "сдвиг при подаче сигнала III",
        "text": "Если подать сигнал по шине III (рис. 4-9), это приведет к увеличению \\( t_{ц. ц} = (7 + 1) \\; t_{сдв} \\) по сравнению с постоянным при всех режимах \\( t_{ц. сх} = 7 \\; t_{сдв} \\). При этом на выходе регистра будет последовательный код в соответствии со второй строкой временной диаграммы. Легко заметить, что переход от одного цикла схемы к другому сопровождается сдвигом кода на один разряд в сторону старших разрядов."
    },
    {
        "tag": "сдвиг при подаче сигнала I",
        "text": "Подача сигнала по шине I приводит к уменьшению \\( t_{ц. ц} = (7 - 1) \\; t_{сдв} \\), и последовательный код на выходе динамического регистра будет соответствовать третьей строке временной диаграммы. Здесь при переходе от одного цикла схемы к другому (последующему) имеем код, сдвинутый на один разряд в сторону младших разрядов."
    },
    {
        "tag": "основы АУ последовательного действия",
        "text": "Рассмотренные динамические регистры хранения и сдвига являются основой построения АУ последовательного действия."
    },
    {
        "tag": "сумматоры",
        "text": "Сумматор — узел, обеспечивающий суммирование двух чисел. Все сумматоры, применяемые в ЭВМ, подразделяются на две основные группы: комбинационные — не обладающие функцией хранения и накопительные — обладающие функцией хранения. Каждый из указанных типов сумматоров подразделяется на сумматоры параллельного действия, обеспечивающие суммирование \\( n \\)-разрядных кодов во всех разрядах одновременно, и одноразрядные суммирующие схемы (одноразрядные сумматоры). Последние являются основой построения как АУ последовательного действия, так и сумматоров параллельного действия."
    },
    {
        "tag": "одноразрядный сумматор",
        "text": "Одноразрядный сумматор \\[a = \\text{таблица истинности}; \\; \\delta = \\text{условное обозначение}\\] Сущность функционирования всех указанных типов сумматоров определяется логикой работы одноразрядного сумматора, которой соответствует таблица истинности, изображенная на рис. 4-10. В этой таблице истинности отражены все возможные комбинации исходных кодов \\( x_i, y_i \\) и \\( p_{i+1} \\) и соответствующих им результатов \\( S_i \\) и \\( P_i \\), которые могут получиться при суммирование двух чисел в \\( i \\)-м разряде. Здесь \\( x_i \\) и \\( y_i \\) — соответственно двоичные коды первого и второго слагаемого в \\( i \\)-м разряде, а \\( p_{i+1} \\) — перенос из \\( (i + 1) \\)-го в \\( i \\)-й разряд; \\( S_i \\) — код суммы, а \\( P_i \\) — перенос из \\( i \\)-го в \\( (i-1) \\)-й разряд. Данной таблице истинности соответствуют следующие логические уравнения: \\[S_i = \\bar{x}_i \\land \\bar{y}_i \\land p_{i+1} \\lor \\bar{x}_i \\land y_i \\land \\bar{p}_{i+1} \\lor x_i \\land \\bar{y}_i \\land \\bar{p}_{i+1} \\lor x_i \\land y_i \\land p_{i+1};\\] (4-1) \\[P_i = \\bar{x}_i \\land \\bar{y}_i \\land p_{i+1} \\lor \\bar{x}_i \\land y_i \\land \\bar{p}_{i+1} \\lor x_i \\land \\bar{y}_i \\land p_{i+1} \\lor x_i \\land y_i \\land p_{i+1};\\] Уравнения (4-1) называются каноническими уравнениями одноразрядного сумматора комбинационного. Применяя к ним классические методы минимизации логических функций, например метод Квайна—Мак-Класски, метод диаграмм Вейча, можно упростить одно из уравнений: \\[S_i = \\bar{x}_i \\land \\bar{y}_i \\land p_{i+1} \\lor \\bar{x}_i \\land y_i \\land \\bar{p}_{i+1} \\lor x_i \\land \\bar{y}_i \\land p_{i+1} \\lor x_i \\land y_i \\land p_{i+1};\\] (4-2) \\[P_i = x_i \\land y_i \\lor x_i \\land p_{i+1} \\lor y_i \\land p_{i+1};\\]"
    }
]"}],
[
    {
        "tag": "комбинационный сумматор SM уравнения",
        "text": "**Комбинационные SM.** Рассмотрим пример построения такого сумматора в базисе И, НЕ. Для этого в соответствии с § 1-5 представим уравнение (4-2) в следующей записи: \\[S_i = (\\bar{x}_i | \\bar{y}_i | p_{i+1}) | (\\bar{x}_i | y_i | p_{i+1}) | (x_i | \\bar{y}_i | p_{i+1}) | (x_i | y_i | p_i);\\] (4-3) \\[P_i = (x_i | y_i) | (x_i | p_{i+1}) | (y_i | p_{i+1}).\\]"
    },
    {
        "tag": "схема комбинационного сумматора SM",
        "text": "В соответствии с уравнениями (4-3) легко строится схема комбинационного сумматора \\(SM\\), которая приведена на рис. 4-11. В этой схеме для каждой входной переменной предусмотрены две входные шины. Если \\(x_i = y_i = p_{i+1} = 1\\), то сигнал в виде высокого уровня напряжения поступает по шинам \\(x_i, y_i и p_{i+1}\\). Если \\(x_i = y_i = p_{i+1} = 0\\), то сигнал соответственно появляется на шинах \\(x_i, y_i, p_{i+1}\\)."
    },
    {
        "tag": "пример работы комбинационного сумматора SM",
        "text": "Допустим, поданы сигналы, соответствующие единице, по шинам \\(x_i, y_i, p_{i+1}\\). При этом на выходе элементов 4, 5, 6 и 7 появится низкий уровень, соответствующий логическому нулю, а на выходах элементов 8 и 9, т. е. на выходах \\(S_i и P_i\\), появятся высокие уровни, т. е. сигналы, соответствующие единице."
    },
    {
        "tag": "характеристика комбинационного сумматора (отсутствие памяти)",
        "text": "Данная схема относится к разряду комбинационных, так как она не обладает функцией хранения. Сигналы на выходе этой схемы присутствуют до тех пор, пока действуют сигналы на входах схемы."
    },
    {
        "tag": "временные параметры схемы SM (t_s, t_phi)",
        "text": "В практике проектирования элементов и схем ЭВМ наряду с их логическим содержанием очень важным является обеспечение необходимых временных параметров. Рассмотрим эти параметры для схемы \\(SM\\), изображенной на рис. 4-11. К временным параметрам этой схемы относятся \\(t_s\\) и \\(t_\\phi\\"}],
[
    {
        "tag": "структура параллельного сумматора",
        "text": "Эти сумматоры, обеспечивающие суммирование \\( n \\)-разрядных кодов, образуются путем объединения \\( n \\) одноразрядных сумматоров. Схема одного такого сумматора изображена на рис. 4-15, \\( a \\). Здесь перенос \\( P_i \\) коммутируется со входом \\( i-1 \\)-го разряда. Передача \\( P_1 \\) на вход \\( SM_n \\) обеспечивает суммирование чисел в обратном коде.\\[\\begin{array}{cc} &  \\\\ \\text{Рис. 4-15. Сумматор параллельного действия на одноразрядных комбинационных сумматорах} & \\text{а — схема сумматора; б — временная диаграмма работы} \\end{array}\\]"
    },
    {
        "tag": "временная диаграмма сумматора",
        "text": "Работу этого сумматора иллюстрирует временная диаграмма, изображенная на рис. 4-15, \\( \\delta \\). Она построена для случая суммирования кодов\\[\\begin{array}{c} 11 \\ldots 11 \\\\ 00 \\ld"}],
[
    {
        "tag": "направления повышения быстродействия сумматоров",
        "text": "На основе формулы (4-10) или (4-11) можно конкретизировать два основных направления повышения быстродействия сумматоров. Первое направление: уменьшение \\( t_s \\) — задержки распространения сигнала по тракту переноса внутри \\( SM_i \\). Второе — уменьшение или исключение влияния величины \\( n \\) на \\( t_s \\). Оба указанных направления обеспечивают уменьшение или исключение времени на распространение переноса. Рассмотрим эти направления. Иллюстрация большинства вопросов будет производиться: a) на потенциальной системе элементов (\\( И—НЕ \\) или \\( И—ИЛИ—НЕ \\)) с положительной логикой (логической единице соответствует высокий уровень сигнала); б) на основе использования комбинационных одноразрядных сумматоров."
    },
    {
        "tag": "уменьшение задержки t_s и эмпирические схемы SM",
        "text": "Уменьшение \\( t_s \\). Это направление относится к проблеме синтеза \\( SM \\), т. е. к проблеме создания схемы \\( SM \\), содержащей минимум оборудования и обладающей минимальными временными параметрами (\\( t_{st \\; мин} \\) и, что особенно важно, \\( t_{s \\; мин} \\)). В настоящее время не существует формальных методов синтеза схем одноразрядных комбинационных сумматоров. Поэтому на практике как раньше, так и сейчас применяются схемы \\( SM \\), полученные эмпирическим путем. В [1—3] приведены описания ряда эмпирических схем \\( SM \\), которые широко использовались и используются в практике построения ЭВМ."
    },
    {
        "tag": "особенности эмпирических схем SM",
        "text": "Сущность всех эмпирических схем \\( SM \\) заключается в том, что они строятся не по каноническим уравнениям, преобразованным с помощью классических методов минимизации, а по другим уравнениям."
    },
    {
        "tag": "",
        "text": "Рис. 4-17. Сумматор с двухпроводной цепью переноса a — схема одноразрядного сумматора комбинационного; б — схема параллельного сумматора со сквозным переносом. Рис. 4-18. Схема сумматора параллельного действия с однопроводной цепью сквозного переноса."
    },
    {
        "tag": "логические уравнения построения SM",
        "text": "В настоящее время широко распространено построение \\( SM \\) в соответствии со следующими уравнениями:\\n\\\\[S_i = (x_i \\wedge y_i \\lor x_i \\wedge \\overline{y_i}) \\wedge p_{i+1} \\lor (x_i \\wedge \\overline{y_i} \\lor x_i \\wedge \\overline{y_i}) \\wedge \\overline{p_{i+1}};\\\\]\\n\\\\[P_i = (x_i \\wedge y_i \\lor x_i \\wedge \\overline{y_i}) \\wedge \\overline{p_{i+1}} \\lor x_i \\wedge \\overline{y_i};\\\\]\\n\\\\[\\overline{P_i} = (x_i \\wedge y_i \\lor x_i \\wedge \\overline{y_i}) \\wedge p_{i+1} \\lor x_i \\wedge \\overline{y_i}.\\\\]"
    },
    {
        "tag": "эквивалентность уравнений (4-12) и (4-1)",
        "text": "Приведенные логические уравнения эквивалентны уравнениям (4-1). Другими словами, уравнения (4-12) и (4-1) — это разная форма логического описания одной и той же таблицы истинности одноразрядного сумматора."
    },
    {
        "tag": "двухпроводная реализация переноса и общие выражения",
        "text": "Специфич"}],
[{"tag":"время переключения элемента хранения","text":"\\[t_s^* = t_s + t_n.\\] В этой формуле \\( t_n \\) — время переключения элемента хранения."},{"tag":"сокращение времени распространения переноса","text":"Уменьшение или исключение времени распространения переноса за счет уменьшения или исключения влияния \\( n \\) на \\( t_s \\). К этому направлению относится несколько типов сумматоров."},{"tag":"сумматоры с групповым переносом","text":"Сумматоры с групповым переносом. Сущность такого сумматора можно объяснить на примере сумматора со сквозным переносом. Допустим, в операции сложения участвуют два тринадцатиразрядных числа, изображенных на рис. 4-19. В данном случае имеет место распространение переноса через 12 последовательных разрядов. В сумматоре со сквозным переносом потребуется время, равное 12 \\( t_s \\). Разобьем разрядную сетку на группы, содержащие по четыре разряда. Каждую группу объединим конъюнктором на четыре входа. Выход каждого из них управляет двухвходовыми конъюнкторами, которые при последовательном соединении образуют цепь группового переноса. Если при данных суммируемых кодах единицу переноса, возникшую в младшем разряде, направить в цепь группового переноса, то на ее распространение через 12 разрядов потребуется лишь 3 \\( t_s \\)."},{"tag":"структура группы сумматора с групповым переносом","text":"Рассмотрим подробно схему одной, \\( j \\)-й группы сумматора, с групповым переносом, содержащей \\( k \\) разрядов. Основу группы представляет \\( k \\)-разрядный сумматор с однопроводной цепью сквозного переноса. В каждом \\( SM_j, (k+1) \\) группы предусмотрен выход \\( \\Sigma_{j,k} = x_{j, k} \\oplus y_{j, k}, \\ldots, \\Sigma_{j,1} = x_{j,1} \\oplus y_{j,1} \\). Наличие такого выхода без ка-\\n\\nКод на этих выходах образуется через \\( t_s \\) после подачи кодов слагаемых и остается неизменным в течение всего времени суммирования. Выходы \\( \\Sigma_{i, k} \\ldots \\Sigma_{j, 1} \\) каждого \\( SM \\) группы и сигнал переноса \\( P_{i+1(\\text{уск})} \\), поступающий из младшей группы, объединяются конъюнктором на \\( k + 1 \\) вход."},{"tag":"логическая функция сигнала переноса","text":"На выходе диэьюнктора появляется сигнал, соответствующий логической функции\\n\\n\\[P_{i+1(\\text{уск})} \\land \\Sigma_{i, k} \\land \\Sigma_{j, k-1} \\land \\ldots \\land \\Sigma_{j, 1} \\lor P_{i(\\text{скв})} = P_{i(\\text{уск})},\\]\\n\\nгде \\( P_{i(\\text{скв})} \\) — сигнал переноса, поступающий из цепи сквозного переноса группы в цепь группового переноса."},{"tag":"оптимальное разбиение сумматора","text":"Представляет интерес вопрос об оптимальном разбиении сумматора на группы. Под оптимальным разбиением понимается выбор значения \\( k \\), при котором получаем \\( t_s \\)."},{"tag":"быстродействие сумматора","text":"Выразим быстродействие сумматора \\( t_s = f(k) \\). Для этого обратимся к примеру суммирования двух чисел на сумматоре с групповым переносом, изображенному на рис. 4-21. Здесь взяты (выбраны) два числа, при суммировании которых перенос, возникший в 3-й группе, распространяется по всей разрядной сетке. Другими словами, на суммирование принятой пары чисел требуется максимальное время, т. е. \\( t_s \\).\\n\\nВ рассматриваемом случае\\n\\n\\[t_s = t_s + k t_s + \\left( \\frac{n}{k} - 2 \\right) t_s + k t_s + t_\\phi,\\]\\n\\nгде \\( t_s \\) — задержка распространения сигнала по тракту переноса внутри \\( SM \\); \\( k t_3 \\) — время распространения переноса по цепи сквозного переноса в 3-й и 4-й группах; \\( \\left( \\frac{n}{k} - 2 \\right) t_3 \\) — время распространения переноса (поступившего из 3-й группы) по цепи группового переноса. Здесь принимается, что задержка распространения сигнала через последовательно соединенные элементы \\( \\hat{M} \\) или \\( \\hat{U}_i \\)/\\( \\hat{U}_j \\) группы равна \\( t_3 \\); \\( t_\\phi \\) — время установления сигнала суммы на выходе \\( SM \\) в старшем разряде 4-й группы, во всех остальных разрядах сумматора оно окончилось раньше.\\n\\nТаким образом,\\n\\n\\[t_S = \\left( 2k + \\frac{n}{k} - 1 \\right) t_3 + t_\\phi \\cdots\\]"},{"tag":"минимальное время суммирования","text":"Взяв от выражения (4-13) производную \\( dt_s/dk \\) и приравняв ее нулю, найдем значение \\( k \\), при котором требуется минимум времени на суммирование чисел в самом худшем случае:\\n\\n\\[\\frac{d t_s}{d k} = \\left( 2 - \\frac{n}{k^2} \\right) t_3 = 0,\\]\\n\\nоткуда\\n\\n\\[k = \\sqrt{n/2}.\\]\\n\\nПодставив в выражение (4-13) значение \\( k = \\sqrt{n/2} \\), получим формулу для оценки быстродействия сумматоров с групповым переносом. На практике для \\( n = 30 \\div 50 \\) разрядов оценка быстродействия таких сумматоров производится (с некоторым превышением) по формуле\\n\\n\\[t_S \\approx \\frac{n}{2} t_3 + t_\\phi.\\]\\n\\nИз этой формулы видно, что сумматор с групповым переносом в 2 раза сокращает время распространения переноса. Временные составляющие, определяющие время выработки переноса в каждом разряде \\( t_3 \\), и время установления кода суммы после распространения переноса \\( t_\\phi \\) остаются без изменения."}]"}],
[
    {
        "tag": "условный перенос",
        "text": "4 Заказ № 785\\n\\n97\\n\\nСумматоры с условным переносом. В данном случае сумматор разбивается на две равные части, и половина сумматора, объединяющая старшие разряды, дублируется. Схема такого сумматора показана на рис. 4-22. Здесь представлены три \\( n/2 \\)-разрядных сумматора с условным изображением цепей сквозного переноса. Коды слагаемых одновременно поступают на три части сумматора. Работа сумматора младших разрядов протекает обычным образом.\\n\\nРис. 4-22. Схема сумматора с условным переносом"
    },
    {
        "tag": "время условного переноса",
        "text": "разом. Одновременно производится суммирование в старших разрядах с условными значениями \\( P_n^y_{n+1} = 0 \\) и \\( P_n^y_{n+2} = 1 \\). По истечении времени \\[t_s = \\frac{n}{2} t_s + t_\\phi\\] суммирование во всех трех сумматорах закончено. На выходе цепи переноса сумматора младших разрядов появляется действительное значение \\( P_n^x_{n+1} \\), с помощью которого выбирается код суммы старших разрядов сумматора. В сумматорах с условным переносом (практически дублируется половина сумматора) время распространения переноса сокращается в 2 раза."
    },
    {
        "tag": "одновременный перенос",
        "text": "**Сумматоры с одновременным переносом.** Перенос в каждом разряде сумматора (как комбинационного, так и накопительного) вырабатывается по двум различным каналам: \\[P_t = x_t \\wedge y_t \\lor (x_t \\lor y_t) \\wedge \\wedge p_{t+1}, \\text{обозначив } x_t \\wedge y_t = D_t, \\quad a \\left( x_t \\lor y_t \\right) = \\Sigma_t, \\text{получим: } P_t = D_t \\lor \\Sigma_t \\wedge p_{t+1}. \\] Заменим: \\[P_{t+1} = D_{t+1} \\lor \\Sigma_{t+1} \\wedge p_{t+2}, \\text{имеем } P_t = D_t \\lor \\Sigma_t \\wedge D_{t+1} \\lor \\Sigma_t \\wedge \\Sigma_{t+1} \\wedge p_{t+2}; \\text{продолжая подобную замену, получим:}\\] \\[P_t = D_t \\lor \\Sigma_t \\wedge D_{t+1} \\lor \\Sigma_t \\wedge \\Sigma_{t+1} \\wedge D_{t+2} \\lor \\cdots \\lor \\Sigma_t \\wedge \\Sigma_{t+1} \\wedge \\cdots \\wedge \\Sigma_{n-1} \\wedge D_n.\\] Получили уравнение, определяющее логику работы цепи одновременного переноса в каждом разряде. Это уравнение можно представить в базисе И—НЕ\\n\\n\\[P_i = \\bar{D}_i | (\\Sigma_i | D_{i+1}) | (\\Sigma_i | \\Sigma_{i+1} | D_{i+2}) | \\cdots\\]\\n\\n\\[\\cdots | (\\Sigma_i | \\Sigma_{i+1} | \\cdots | \\Sigma_{n-1} | D_n).\\]\\n\\nИз этих уравнений видно, что в каждом разряде требуется иметь \\( n + 1 - i \\) схем И или И—НЕ с количеством входов от 1 до \\( n + 1 - i \\) и одну схему ИЛИ или И—НЕ с количеством входов \\( n + 1 - i \\)."
    },
    {
        "tag": "логические уравнения одновременного переноса",
        "text": "Напишем логические уравнения одновременного переноса для первых четырех разрядов сумматора:\\n\\n\\[P_n = D_n;\\]\\n\\n\\[P_{n-1} = \\bar{D}_{n-1} | (\\Sigma_{n-1} | D_n);\\]\\n\\nРис. 4-23. Схема младших разрядов сумматора с одновременным переносом\\n\\n\\[P_{n-2} = \\bar{D}_{n-2} | (\\Sigma_{n-2} | D_{n-1}) | (\\Sigma_{n-2} | \\Sigma_{n-1} | D_n);\\]\\n\\n\\[P_{n-3} = \\bar{D}_{n-3} | (\\Sigma_{n-3} | D_{n-2}) | (\\Sigma_{n-3} | \\Sigma_{n-2} | D_{n-1}) | (\\Sigma_{n-3} | \\Sigma_{n-2} | \\Sigma_{n-1} | D_n);\\]"
    },
    {
        "tag": "время работы одновременного переноса",
        "text": "Для рассматриваемого сумматора быстродействие оценивается по формуле \\[ t_s = 3t_s + t_\\phi. \\]\\n\\nВремя распространения переноса здесь практически исключается. Здесь одно \\( t_s \\) — это время задержки трактов, связанных с формированием в каждом разряде \\( \\Sigma_i \\) и \\( D_i \\). Второе \\( t_s \\) в этой формуле — время задержки, вносимое цепями одновременного переноса (задержка, вносимая двумя последовательно соединенными элементами \\( H—HE \\)). Третье \\( t_s \\) — время задержки, вносимое цепями формирования \\( S_i \\)."
    },
    {
        "tag": "варианты организации одновременного переноса",
        "text": "Возможны два варианта организации одновременного переноса в группах. Допустим, сумматор разбит на \\( n/k \\) групп, и каждая группа содержит \\( k \\) разрядов.\\n\\nПервый вариант. Одновременный перенос реализуется для каждого разряда любой группы. Перенос из старшего разряда младшей группы поступает во все разряды старшей группы. При этом \\[ t_s = 3t_s + \\left( \\frac{n}{k} - 1 \\right) t_s + t_\\phi, \\] где \\[ \\left( \\frac{n}{k} - 1 \\right) t_s \\] — это распространение переноса между группами в самом худшем случае; \\( t_\\phi \\) — время формирования сигнала на выходе суммы.\\n\\nВторой вариант. Одновременный перенос формируется лишь в старшем разряде каждой группы, в остальных разрядах любой группы реализован сквозной перенос. Перенос из старшего разряда младшей группы поступает в схему выработки одновременного переноса в старшем разряде и в цепь сквозного переноса старшей группы. Быстродействие будет оцениваться по следующей формуле: \\[ t_s = 3t_s + \\left( \\frac{n}{k} - 1 \\right) t_s + \\left( k - 1 \\right) t_s + t_\\phi. \\]\\n\\nВ данном случае к трем составляющим добавляется еще одна \\( (k-1) t_s \\) — время распространения переноса по цепи сквозного переноса в группе."
    },
    {
        "tag": "асинхронные сумматоры",
        "text": "Асинхронные сумматоры. Все, что изложено MO сумматорам параллельного действия, относится K так называемым синхронным сумматорам. В таких сумматорах на суммирование любой пары чисел отводится максимальное время, т. е. время, необходимое в самом худшем случае. В этом случае время, отводимое на суммирование, B большинстве случаев используется неэффективно. Этот вывод становится особенно очевидным, если учесгь, что средняя длина распространения переноса —л{ь\"<л. Так, в ряде работ показано, что л\\\" ® logyn."
    }
]"}],
[
    {
        "tag": "асинхронные сумматоры принципы построения",
        "text": "Существуют асинхронные сумматоры, B которых на суммирование любой пары чисел отводнтся необходимое время. B таких сумматорах имеются цепи, которые определяют момент окончания распространения переноса. Существуют различные принципы построения таких цепей. Они зависят и от типа используемых систем элементов (потенциальной или потенциально-импульсной)."
    },
    {
        "tag": "окончание распространения переноса логическое выражение",
        "text": "Рассмотрим пример определения окончания суммирования (окончания распространения переноса) в комбинационном сумматоре с двухпроводной целью сквозного переноса. При суммировании любых \\( n\\)-разрядных кодов в каждом разряде сумматора всегда будет либо \\( P_t = 1 \\), либо \\( P_t = 1 \\) или \\( P_t \\lor P_i = 1 \\) при условии, что \\( P_t \\land P_i = 0 \\). Окончание распространения переноса будет определяться следующим логическим выражением:\n\n\\[(P_1 \\lor P_1) \\land (P_2 \\land P_2) \\land \\ldots \\land (P_n \\lor P_n) = 1.\\]"
    },
    {
        "tag": "исключение одновременного переноса",
        "text": "Уравнение вида\n\n\\[\\overline{(P_1 \\land P_1)} \\lor (P_2 \\land P_2) \\lor \\ldots \\lor (P_n \\land P_n) = 1\\]\n\n(4-15)\n\nисключает случаи появления хотя бы в одном из разрядов \\( P_t = \\overline{P}_t = 1 \\)."
    },
    {
        "tag": "схема определения окончания переноса",
        "text": "Рассмотрим схему, определяющую окончание распространения переноса, для двухпроводной цели переноса, построенную в соответствии с логическими уравнениями:\n\n\\[P_t = x_i \\land y_i \\lor x_i \\land p_{i+1} \\lor y_i \\land p_{i+1} = x_i \\land y_i \\lor (x_i \\lor y_i) \\land p_{i+1};\\]\n\n\\[\\overline{P}_t = \\overline{x}_i \\land \\overline{y}_i \\lor \\overline{x}_i \\land p_{i+1} \\lor \\overline{y}_i \\land p_{i+1} = x_i \\land \\overline{y}_i \\lor (\\overline{x}_i \\lor \\overline{y}_i) \\land p_{i+1}.\\]"
    },
    {
        "tag": "описание работы схемы окончание переноса",
        "text": "Эта схема изображена на рис. 4-25. Здесь в отличие от ранее рассмотренных схем сумматоров (одноразрядных и параллельного действия) распространение переноса начинается не с момента одновременной подачи кодов слагаемых. Суммирование (распространение переноса) после подачи кодов слагаемых по шинам \\( x_i, y_i, \\overline{x}_i \\) и \\( y_i \\) начинается с подачей импульса по шине переноса (ИП). При этом перед началом суммирования в каждом разряде \\( P_t = \\overline{P}_t = 0 \\). После подачи импульса по шине ИП в тех разрядах, где \\( x_i = y_i = 1 \\) или \\( x_i = \\overline{y}_i = 1 \\), появляются соответственно \\( P_t = 1 \\) либо \\( P_t = 1 \\) и начинается их распространение. Завершение распространения переноса определяется сигналом, соответствующим 1 в точке \\( A \\), на выходе схемы, реализующей уравнение (4-14). Наличие сигнала, соответствующего 1 в точке \\( B \\), на выходе схемы, реализующей уравнение (4-15), исключает случаи появления хотя бы в одном из разрядов сумматора \\( P_t = \\overline{P}_t = 1 \\)."
    },
    {
        "tag": "пример асинхронного суммирования в двухрядовом коде",
        "text": "В практике построения процессоров ЭВМ применяется асинхронное суммирование чисел в двухрядовом коде. Сущность этого суммирования можно показать на примере\n\n\\[\\begin{array}{c|c} 10011101011 & \\text{Два исходных числа в однорядовом коде.} \\\\ \\hline 01000101101 & \\\\ \\hline 11100011000 & \\text{Cумма двух исходных чисел в обычном коде, ее можно представить и в двухрядовом коде.} \\\\ S^1_i = 11011000110 & \\\\ P^1_i = 00000101001 & \\text{Oдин ряд соответствует коду } S^1_i = x_i \\oplus y_i = x_i \\land \\overline{y} \\lor \\\\ S^2_i = 11010010100 & \\lor x_i \\land \\overline{y}_i, \\text{а другой ряд соответствует коду } P^1_i = x_i \\land \\overline{y}_i. \\\\ P^2_i = 00001000010 & \\text{Далее снова получаем двухрядовый код } S^2_i = \\\\ S^3_i = 11000010000 & = S^1_i \\land (\\overline{P}^1_i \\cdot 2^{i+1}) \\lor \\overline{S}^1_i \\land (P^1_i \\cdot 2^{i+1}) = S^1_i \\oplus P^1_i \\cdot 2^{i+1}; \\\\ P^3_i = 00010000100 & P^2_i = S^1_i \\land (P^1_i \\cdot 2^{i+1}). \\\\ S^4_i = 11100011000 & \\text{Аналогично получаем: } S^3_i, P^3_i \\text{ и } S^4_i, P^4_i. \\\\ P^4_i = 00000000000 & \\\\ \\end{array}\\]"
    },
    {
        "tag": "завершение переноса нулевой сигнал",
        "text": "Наличие нуля во всех разрядах Р; фиксирует окончание распространения переноса. Код суммы (однорядовый) — $#. Takoe выполнение сложения называется процессом приведения переноса к нулю."
    },
    {
        "tag": "аппаратная реализация двухрядового суммирования",
        "text": "Аппаратная реализация этого метода иллюстрируется схемой, изображенной на рис. 4-26. Здесь на каждый разряд суммируемых кодов предусматривается по две схемы полусумматоров — HS; и Н$,.\n\nВ начале суммируемые коды Xy . .. Хд И Y1 ... Уд одновременно (сигналом по шине /) подаются на входы НЗ„ на выходах которых с некоторой задержкой появляется двухрядовый код $; ($/) и P}(Pl). Затем st коды по сигналу, подаваемому по шине I/, поступают на входы HS;. При этом передача Р/ происходит со сдвигом. Двухрядовый код, появляющийся на выходах HS;, соответствует $; (/1) н P (Р/+!). Этот код по сигналу, подаваемому по шине /]I, поступает на вход Н5;. Здесь, так же как и в предшествующем случае, передача кода переноса Р/!! пронсходит со сдвигом. Рассмотренные циклы, состоящие из двух тактов где каждый такт — время получения очередного двухрядового кода, повторяются до тех пор, пока Pty Py L. yPIH = 0.\n\nНаличие такого условия фиксируется специальной схемой, входами которой являются выходы \\( P_i^{i+1} \\) полусумматора \\( HS_i \\)."
    },
    {
        "tag": "временная диаграмма и условие t_s = t_{it}",
        "text": "Упрощенная временная диаграмма, отражающая последовательность работы \\( HS_i \\) и \\( HS_i' \\) в течение цикла, приведена на рис. 4-26, б. Из этой диаграммы следует, что для нормальной работы схемы необходимо выполнение следующего соотношения:\n\n\\[ t_s = t_{it}. \\]"
    },
    {
        "tag": "оценка быстродействия асинхронных сумматоров",
        "text": "Быстродействие рассмотренных асинхронных сумматоров оценивается не максимальным, а средним временем выполнения операции:\n\n\\[ t_{scp} = n_c^m t_s + t_{\\phi}. \\]"
    },
    {
        "tag": "применение и ограничения асинхронных сумматоров",
        "text": "Такие типы сумматоров находят применение в машинах, предназначенных для решения широкого класса задач. Но их применение исключено в тех специализированных ЭВМ, где время решения задачи строго фиксировано и не должно зависеть от кодов чисел, подлежащих суммированию."
    },
    {
        "tag": "специфика сумматоров в двоично-десятичных системах счисления",
        "text": "### Специфика построения сумматоров для чисел #### в двоично-десятичных системах счисления"
    },
    {
        "tag": "факторы влияющие на построение в ДДС",
        "text": "На специфику рассматриваемого вопроса влияют два основных фактора. Это специфика выполнения арифметических действий над числами в двоично-десятичной системе счисления: выработка искусственного переноса, необходимость выполнения коррекции, подробно рассмотренные в § 2-4, и способы представления двоично-десятичных чисел."
    },
    {
        "tag": "способы представления чисел в ДДС",
        "text": "Возможны четыре способа представления чисел. На рис. 4-27 показано представление числа 369 всеми возможными способами."
    },
    {
        "tag": "последовательное представление чисел",
        "text": "Последовательное представление (рис. 4-27, а) — десятичные цифры и их двоичные коды представляются (и обрабатываются) последовательно во времени младшими разрядами вперед."
    },
    {
        "tag": "последовательно-параллельное представление",
        "text": "При последовательно-параллельном представлении (рис. 4-27, б) десятичные цифры представляются последовательно во времени, а их двоичные коды параллельно."
    },
    {
        "tag": "параллельно-последовательное представление",
        "text": "Параллельно-последовательное представление (рис. 4-27, в) характеризуется параллельным представлением десятичных цифр и последовательным представлением их двоичных кодов."
    },
    {
        "tag": "полностью параллельное представление",
        "text": "При параллельном представлении как десятичные, так и двоичные цифры представляются и обрабатываются параллельно. Это способ рис. 4-27, а, но с вертикальной осью времени."
    },
    {
        "tag": "распространённые способы представления",
        "text": "На практике получили наибольшее распространение последовательно-параллельный и параллельный способы представления."
    }
]"}],
[{"tag":"схема сумматора 8421","text":"В настоящее время B машине БЭСМ-6, Bo всех моделях серии ЕС ЭВМ, в машине «Минск-22», в моделях АСВТ реализована возможность работы с двоично-десятичными числами.\n\nНа рис. 4-28 приведена схема сумматора для последовательно-параллельного суммирования чисел в системе 8421. Схема построена на комбинационных одноразрядных сумматорах. Основу схем"}],
[
    {
        "tag": "получение 2n-разрядного произведения",
        "text": "Практически без аппаратных затрат на рассматриваемой схеме возможно получение \\( 2n \\)-разрядного произведения. Для этого необходимо сдвигаемый код младших разрядов произведения подавать в регистр множителя (в его старшие разряды)."
    },
    {
        "tag": "аритметическое устройство параллельного действия",
        "text": "5-3. Арифметическое устройство параллельного действия для сложения — вычитания чисел с плавающей запятой\\n\\nВ качестве примера рассмотрим \\( AV \\) параллельного действия для сложения—вычитания нормализованных чисел с плавающей запятой. Такое арифметическое устройство (рис. 5-5) состоит из \\( AV \\) порядков и \\( AV \\) мантисс. \\( AV \\) порядков содержит \\( n_n \\) разрядов, \\( AV \\) мантисс — \\( n_M \\) разрядов."
    },
    {
        "tag": "структура устройства (регистры и сумматоры)",
        "text": "Каждое из устройств состоит из трех регистров (\\( RG_{1n} \\), \\( RG_{2n} \\), \\( RG_{S_n} \\)) для порядков и \\( RG_{1M} \\), \\( RG_{2M} \\), \\( RG_{S_M} \\) для мантисс) и одного синхронного сумматора (\\( S_n \\) и \\( S_M \\)). Оба сумматора построены на комбинационных одноразрядных суммирующих схемах (\\( SM_i \\)). Их объединение с регистрами \\( RG_{S_n} \\) и \\( RG_{S_M} \\) образуют накопительные сумматоры порядков и мантиссы. В целях упрощения схемы в ней не показаны цепи распространения переноса в сумматоре, лишь символически изображены цепи сдвига на одни разряд в \\( RG_{S_M} \\) (шины 21 и 22)."
    },
    {
        "tag": "представление нормализованных чисел",
        "text": "Основные характеристики рассматриваемой схемы. Представление нормализованных чисел с плавающей запятой принято в соответствии с формулой\\n\\n\\[x = \\pm 2^m \\sum_{i=1}^{n_M} a_i \\cdot 2^{-i}.\\]"
    },
    {
        "tag": "представление порядков",
        "text": "Отрицательные и положительные порядки суммируемых чисел (\\( mx_u \\) и \\( my_u \\)) представляются в машине целыми положительными числами в соответствии с формулой\\n\\n\\[m_M = m_u + 2^{n - 1}.\\]"
    },
    {
        "tag": "хранение порядков и мантисс в ОЗУ",
        "text": "В оперативном запоминающем устройстве (ОЗУ) порядки хранятся в виде целых \\( n_n \\)-разрядных положительных чисел, а мантиссы в дополнительном коде."
    },
    {
        "tag": "алгебраическое суммирование порядков и мантисс",
        "text": "При алгебраическом суммировании порядков используется дополнительный код, а мантисс — модифицированный дополнительный код."
    },
    {
        "tag": "процесс загрузки операндов",
        "text": "Первое cnaraeMoe или уменьшаемое принимается на первый регистр (RGy, и RG,,), второе слагаемое или вычитаемое — на второй регистр (RG,y, и RG,,). Разность порядков осуществляется вычитанием из кода порядка первого слагаемого кода порядка второго слагаемого. Выдача результата сложения или вычитания производится с регистров сумматоров (RGs, и RGs,)."
    },
    {
        "tag": "элементы схемы (триггеры, сумматоры и др.)",
        "text": "Схема построена на потенциальной системе элементов. На элементах такой системы реализованы комбинационные сумматоры SM;, синхронные и асинхронные В$-триггеры, двухтактные MS-триггеры, дизъюнкторы и конъюнкторы, которые и являются основной рассматриваемой схемы."
    },
    {
        "tag": "кодовые шины",
        "text": "Все одноименные разряды АУ порядков и АУ мантисс объединены так называемыми кодовыми шинами с параф"}],
[{"tag":"временная диаграмма выполнения операции","text":"Временная диаграмма, соответствующая выполнению данного примера, показана на рис. 5-6. В ней отражена временная последовательность сигналов на шинах \\( AV \\), обеспечивающая выполнение операции с момента приема из \\( O3V \\) слагаемых на регистры \\( AV \\) и кончая выдачей результата в \\( O3V \\). При построении временной диаграммы времена выполнения основных этапов выражаем через время передачи \\( t_n \\) и основные временные параметры \\( t_{обр} = 3t_n \\), \\( t_{s_n} = 3t_n \\), \\( t_{s_u} = 4t_n \\) и \\( t_{сдв} = 2t_n \\)."},{"tag":"этапы выполнения операции (прием, разность, денормализация, выравнивание)","text":"В такт \\( I - 3 \\) и \\( 5 - 7 \\) осуществляется прием исходных кодов на регистр \\( AV \\) порядков и мантисс (подаются сигналы приема по шинам 2, 16). После приема исходных чисел определяется разность порядков. Вначале осуществляется передача \\( m_{xu} \\) с \\( RG_{1n} \\) через \\( S_n \\) на \\( RG_{s_n} \\) (подаются сигналы по шинам 1, 11 и 8 в такте 9), а затем (такты \\( II - 13 \\)) осуществляется на \\( S_n \\) вычитание \\( m_{yu} \\) из \\( m_{xu} \\) (по-даются одновременно сигналы по шинам 10, 11 и 14). B конце такта 18 код разности порядков на S, сформировался, и подачей сигнала по шине & этот код передается на хранение в RGsn. Затем B начале (или во время) такта /3 анализируется наличие сигналов по шинам §, 6, 7 и 9. В данном случае сигналы IO ним отсутствуют (B TOM числе по шине знака разности порядков — 9), что определяет необходимость денормализации вычитаемого. Этап денормализации мантиссы вычитаемого (такты /4—17) начинается с передачи мантиссы сигналами по шинам 26, 25, 28 Bpemn через сумматор мантисс в RGs, FIIpu этом} на входы сумматора мантисс поступает единственный код [— [M,] |4 который с выходов сумматора сигналом по шине 23 передается на КО_;_. Затем. начинается собственно денормализация или выравнивание порядков. Выполняется первый сдвиг [—[М„]д];‘ вправо на один разряд (сигнал по шине 2/). Одновременно (такты /8—20) контролируется окончание выравнивания порядков: вычитается единица M3 разности порядков или суммируется код [—00...01]; = =-1,1...1 с кодом разности порядков (сигналы MO шинам 10 и 12). После передачи уменьшенной на единицу разности порядков на RGs (сигнал по шине 8) анализируется сигнал на шине 6 (такт 20). Сигнал отсутствует, следовательно, разность порядков не сведена к нулю и выравнивание порядков продолжается. Повторяется (тактъ 22—24) только что рассмотренный этап. В такте 24 будет установлен на шине 6 высокий уровень, соответствующий коду \\(0,0 \\ldots 0\\) на сумматоре порядков, т. е. окончанию выравнивания порядков."},{"tag":"суммирование мантисс","text":"Суммирование мантисс осуществляется подачей сигналов по шинам 17, 25 и 24 (тактъ 26—29). Здесь суммируются коды, находящиеся в \\(RG_{S_M} (\\left[ - [M_u]^u_1 \\cdot 2^{-2} \\right] \\) и в \\(RG_{I_M} [M_u]^u_1\\). Одновременно код порядка большего слагаемого сигналами по шинам 1, 11, 8 передается в \\(RG_{S_n}\\). По истечении \\(t_{S_M}\\) (тактъ 26—29) код суммы сигналом по шине 23 передается в \\(RG_{S_M}\\)."},{"tag":"нормализация мантиссы","text":"**Нормализация мантиссы.** Здесь вначале (такт 30) анализируются сигналы на шинах 18 и 19. В нашем случае есть сигнал на шине 18, что определяет необходимость выполнения нормализации вправо. Подаются сигналы по шине 21 (осуществляется сдвиг мантис"}],
[{"tag":"условие завершения цикла","text":"В конце этого цикла анализируются уровни сигналов в точках \\( a, b, c \\) (на шинах 17, 18, 19 и 20), и если не выполняется условие \\[ U_a \\land U_c = 1 \\] и \\[ U_b \\land U_e = 1 \\], то осуществляется заключительный цикл."},{"tag":"цикл выдачи t5","text":"\\( t_5 \\) — цикл выдачи, подачей кода по шине 14 осуществляется выдача результата в ОЗУ."},{"tag":"синхронизация схемы","text":"Работа всей схемы синхронизируется непрерывной подачей синхронизирующих импульсов на все три регистра. Эти импульсы показаны на первой горизонтальной линии временной диаграммы."},{"tag":"шины АУ для сложения и вычитания","text":"Перечень и характеристика шин АУ последовательного действия для выполнения сложения — вычитания\n\n| Номер шины | Характеристика шины |\n|---|---|\n| 1    | Разрешение выдачи кода \\[ \\[X\\]_n \\] с \\[ RG \\[X\\]_n \\] на вход \\( x \\) SM. |\n| 2    | Прием \\[ \\[X\\]_n \\] в \\[ RG \\[X\\]_n \\]. |\n| 3    | Указать: исходных чисел в АУ. |\n| 4    | Хранение в \\[ RG \\[X\\]_n \\] (или гашение \\[ RG \\[X\\]_n \\]). |\n| 5    | Разрешение выдачи кода \\[ \\[Y\\]_n \\] с \\[ RG \\[Y\\]_n \\] на вход \\( y \\) SM. |\n| 6    | Прием \\[ \\[Y\\]_n \\] в \\[ RG \\[Y\\]_n \\] (шина сложения). |\n| 7    | Хранение в \\( RG \\[Y\\]_Д \\) (или гашение \\( RG \\[Y\\]_Д \\)). |\n| 8    | Разрешение выдачи код \\([-[Y]\\_Д]\\) на вход \\( Y \\) SM (шина вычитания). |\n| 9    | Подача 1 дополнительного кода \\( (2-n) \\) на вход \\( pSM \\). |\n| 10   | Выделение сигнала переноса из старшего разряда суммы \\(-P_2-1 \\). |\n| 11   | Установка \\( T_{пер} \\) и \\( T_{З_x} = 3_y = 0 \\) в 0, а \\( T_{З_x} = 3_y = 1 \\) в единицу. |\n| 12   | Выделение знака \\([X]\\_Д\\) |\n| 13   | \\[Y\\]_Д\\] или \\([-[Y]\\_Д]\\) и блокировка передачи переноса из знакового разряда результата на вход \\( pSM \\). |\n| 14   | Разрешение выдачи результата. |\n| 15   | Выдача результата. |\n| 16   | Хранение результата в \\( RG ([X]\\_Д \\pm [Y]\\_Д) \\). |\n| 17   | Наличие переноса в старшем разряде результата. |\n| 18   | Отсутствие переноса в старшем разряде результата. |\n| 19   | Суммирование двух отрицательных чисел \\( (\\frac{3}{x} = 3y = 1) \\). |\n| 20   | положительных чисел \\( (\\frac{3}{x} = 3y = 0) \\). |"},{"tag":"арифметическое устройство умножения","text":"5-5. Арифметическое устройство последовательного действия для выполнения операции умножения\n\nРассмотрим в качестве примера схему \\( AV \\) последовательного действия \\( (AVII\\Д) \\), обеспечивающую выполнение операции умножения прямых кодов исходных чисел с младших разрядов множителя. Схема такого устройства изображена на рис. 5-9. Далее приведен полный перечень управляющих шин."},{"tag":"структура схемы умножения","text":"Основой схемы являются комбинационный сумматор SM и три динамических регистра, выполняющих хранение и сдвиги компонентов и частичных произведений. Регистр \\( RG_1 \\) предназначен для хранения множитого. Регистр \\( RG_2 \\) предназначен для хранения и сдвига множителя. В этом же регистре на месте разрядов множителя, на которые выполнено умножение, записываются младшие разряды"}],
[
    {
        "tag": "циклы умножения t5‑t9",
        "text": "\\( t_5 \\) и \\( t_6 \\) — это циклы умножения на третий — \\( y_2 \\) и четвертый \\( y_1 \\) разряды множителя. Последовательность выполнения этих циклов не отличается от ранее разобранных. \\( t_7 \\) — цикл сдвига младших и старших разрядов произведения. Этот цикл необходим, так как во время выполнения первого цикла умножения множимое подавалось в сумматор без сдвига; кроме того, этот цикл необходим для фиксации старшего кода младших разрядов произведения и его записи в регистре \\( RG_2 \\). \\( t_8 \\) и \\( t_9 \\) — циклы хранения полученных кодов и выдачи либо старших, либо младших разрядов произведения. Для обеспечения циркуляцию кода через регистры \\( RG_2 \\) и \\( RG_3 \\), задержка которых равна шести тактам, поскольку открыты конъюнкторы \\( \\delta_8 \\) и \\( \\delta_{10} \\). Выдача полученных кодов происходит через конъюнкторы \\( \\delta_{12} \\) и \\( \\delta_{11} \\), которые открываются сигналами, подаваемыми по шинам 10 и 12."
    },
    {
        "tag": "арихметическое устройство последовательно‑параллельного действия",
        "text": "Арифметическое устройство последовательно‑параллельного действия (АУППД), содержащее \\( m \\)-разрядные сдвиговые регистры и сумматор, способно производить различные арифметические и логические операции над словами длины \\( n > m \\), если обеспечить последовательное поступление в это АУ \\( m \\)-разрядных частей \\( n \\)-разрядного слова в требуемом порядке. При такой организации обработки \\( n \\)-разрядных слов (\\( n > m \\)) традиционное в параллельных АУ требование: \\( n = \\text{const} \\) является не принципиальным, если устройство управления может фиксировать значение \\( n \\) по информации о длине слова, указанной в команде. Последовательно‑параллельный принцип обработки слов переменной длины (\\( n \\neq \\text{const} \\)) используется в тех случаях, когда необходимо построить относительно дешевые (по сравнению с АУ параллельного действия) и достаточно при этом быстродействующие (по сравнению с АУ последовательного действия) устройства. В частности, этот принцип был использован при разработке арифметических устройств младших моделей единой системы ЭВМ (ЕС ЭВМ)."
    },
    {
        "tag": "внешние характеристики АУППД",
        "text": "Рассмотрим организацию и работу АУППД со следующими внешними характеристиками.\n\nАрифметическое устройство производит операции со словами, длина которых \\( n = 8l \\), где \\( l \\) — целое число.\n\nДля хранения операторов длины \\( n \\) используется \\( l \\) ячеек памяти длиной в 1 байт (восемь разрядов) в оперативном запоминающем устройстве или в так называемой «области регистров \\( R \\)). Для того чтобы извлечь или записать определенный байт в регистр \\( R_i \\) области регистров, необходимо указать номер регистра и номер соответствующего байта в нем."
    },
    {
        "tag": "структура АУППД",
        "text": "Арифметическое устройство последовательно‑параллельного действия обрабатывает числа форматов, изображенных на рис. 5‑11.\n\nНа рис. 5‑12 изображена схема АУППД с нижеприведенными характеристиками.\n\nВсе исходные числа и результаты хранятся в ОЗУ в дополнительном коде. Арифметическое устройство состоит из четырех восьмиразрядных регистров (\\( RGA, RGB, RGC \\) и \\( RGD \\)). В них, кроме хранения, выполняются операция сдвига (\\( RGA, RGC \\) и \\( RGD \\)) и суммирование (\\( RGA \\)). Организация сумматора, регистров, цепей приема, выдачи между регистрами выполнена в полном соответствии со схемой АУ параллельного действия, рассмотренной в § 5‑3. На схеме АУППД как сами регистры, так и их цепи приема, выдачи изображены условно. Также условно в виде одной горизонтальной шины изображены восемь кодовых шин, объединяющих одноименные разряды всех четырех регистров."
    },
    {
        "tag": "элементы хранения в схеме",
        "text": "В схеме предусмотрен ряд элементов хранения, предназначенных для запоминания одноразрядной информации, необходимой при выполнении различных операций.\n\nВсе оборудование схемы построено на потенциальной системе элементов."
    },
    {
        "tag": "мультиоперации АУППД",
        "text": "Приведенная схема АУППД и набор микроопераций (перечень и характеристика шин), приведенный далее, позволяют реализовать определенное множество операций. В частности, могут быть выполнены операции сложения, вычитания, умножения, деления как с фиксированной, так и с плавающей запятой."
    },
    {
        "tag": "характеристика шин АУППД",
        "text": "Перечень и характеристика шин АУППД\n\n| Номер шины | Характеристика шины |\n|---|---|\n| 1    | Выдача парафазного кода с \\( RGD \\).    |\n| 2    | Сдвиг в \\( RGD \\) на один разряд.    |\n| 3    | Установка кода частного.    |\n| 4    | Прием парафазного кода на \\( RGD \\).    |\n| 5    | Выдача кода с \\( RGC \\).    |\n| 6    | Сдвиг в \\( RGC \\) на один разряд.    |\n| 7    | У «О» \\( RGC \\).    |\n| 8    | Прием парафазного кода в \\( RGC \\).    |\n| 9    | Передача кода при сдвиге из \\( RGA \\) в \\( RGC \\).    |\n| 10   | Подача кода с \\( RGA \\) на входы сумматора.    |\n| 11   | Передача парафазного кода с \\( RGA \\).    |\n| 12   | Сдвиг \\( RGA \\) на один разряд.    |\n| 13   | Прием парафазного кода в \\( RGA \\).    |\n| 14   | Подача кода единицы в младший разряд \\( RGA \\).    |\n| 15   | Передача инверсного кода с \\( RGB \\).    |\n| 16   | Передача прямого кода с \\( RGB \\).    |\n| 17   | Прием парафазного кода в \\( RGB \\).    |\n| 18   | Код разряда множителя.    |\n| 19   | Запоминание кода разряда множителя.    |\n| 20   | Код переноса \\( P_2^{-1} \\) из седьмого разряда \\( RGA \\).    |\n| 21   | Запоминание кода переноса \\( P_2^{-1} \\) из седьмого разряда \\( RGA \\).    |\n| 22   | Код переноса в старший байт.    |\n| 23   | Код \\( S_x \\).    |\n| 24   | Запоминание кода \\( S_x \\).    |\n| 25   | Запоминание кода переноса в старший байт.    |\n| 26* | Код \\( S_y \\).    |\n| 27* | Запоминание кода \\( S_y \\).    |\n| 28   | Код \\( S_y \\).    |\n| 29   | Код \\( S_y \\).    |\n\n* Указанные шины используются при операции деления."
    },
    {
        "tag": "операция сложения‑вычитания в АУППД",
        "text": "Выполнение операции сложения—вычитания. Допустим, требуется просуммировать два числа \\([X]_n\\) и \\([Y]_n\\) с фиксированной запятой, содержащие по 8\\(l\\) разрядов. Вначале суммируются младшие байты чисел \\([X]_n\\) и \\([Y]_n\\), т. е. байты с номером \\( l \\, \\delta_{x_l}\\) и \\( \\delta_{y_l} \\). Возникающий перенос из старшего восьмого разряда байта суммы \\( \\delta_{s_l} \\) запоминается, чтобы впоследствии прибавить его к младшему разряду"}],
[{"tag":"пример вычитания байтов","text":"\\[[\\sigma_{y_3}]_A^o = 00110110 \\,(\\text{III 15 и 10})\\]\\n\\n1 \\,(\\text{III 14})\\n\\n\\[[\\sigma_{S_3}]_A = 10111100 \\,(\\text{III 11})\\]\\n\\n0 — перенос во 2-й байт (III 22)\\n\\nСуммируем вторые байты:\\n\\n\\[[\\sigma_{x_3}]_A = 11110100 \\,(\\text{III 13})\\]\\n\\n\\[[\\sigma_{y_3}]_A^o = 11100000 \\,(\\text{III 15 и 10})\\]\\n\\n0\\n\\n\\[[\\sigma_{S_3}] = 11010100 \\,(\\text{III 11})\\]\\n\\n1 — перенос в 1-й байт (III22)\\n\\nСуммируем старшие байты: \\[ [6_{x_1}]_{\\pi} = 1,0111101 \\quad (\\text{III 13}) \\] \\[ [[6_{y_1}]_{\\pi}]_0 = 1,1010010 \\quad (\\text{III 15 и 10}) \\] \\[\\begin{array}{c} 1 \\quad (\\text{III 14}) \\\\ \\end{array}\\] \\[ [6_{s_1}]_{\\pi} = 1,0010000 \\quad (\\text{III 11}) \\] \\[ 1 - \\text{перенос} \\quad (\\text{III 20}) \\]"},"tag":"проверка переполнения","text":"Проверяем условие переполнения. В данном случае его нет, т. е. \\(3_x \\land 3_y \\land P_{2-1} = 0\\) и \\(\\overline{3}_x \\land \\overline{3}_y \\land P_{2-1} = 0\\). Проверка указанных условий осуществляется анализом сигналов, появившихся на шинах 28, 23 и 20 после окончания суммирования старших байтов."},{"tag":"временная диаграмма вычитания","text":"Временная диаграмма, соответствующая данному примеру вычитания, показана на рис. 5-13. Она построена при следующих параметрах: \\(t_n\\) — время выполнения передачи, принятое за масштаб диаграммы; \\(t_{обр} = 3 \\; t_n\\) — время обращения к ОЗУ или «области регистров» \\(R\\); \\(t_s = 2t_n\\) — быстродействие накопительного сумматора."},{"tag":"время выполнения операции вычитания","text":"Все три этапа практически одинаковы. Для первого этапа характерна безусловная подача сигнала по шине 14. Для последнего (третьего) этапа — запоминание \\(S_x\\) и \\(P_{2-1}\\) (сигналы по шинам 24, 21) с последующим анализом сигналов на шинах 28, 23 и 20.\\n\\nВремя выполнения операции вычитания (сложения)\\n\\n\\[ t_{\\pm} = l(t_l) = l(3t_{обр} + t_s + t_n). \\]"},{"tag":"операция сдвига","text":"Выполнение операции сдвига. Допустим, требуется осуществить сдвиг \\( l \\)-байтового кода (содержащего 8\\( l \\) разрядов) на \\( k \\) разрядов влево. Рассмотрим частный случай сдвига на \\( k = 3 \\) разряда. Исходное число — \\( X \\), содержит 3 байта и имеет вид:\\n\\n\\[\\begin{array}{ccc} 101 & 10101010 & 11001100 \\\\ 101 & 01010\\underline{110} & 01100\\underline{111} \\\\ & 1-й байт & 2-й байт \\\\ & & 11100011 \\\\ & & 00011000 \\\\ & & 3-й байт \\\\ \\end{array}\\]"},{"tag":"пример сдвига кода","text":"Дача такой процедуры сдвига характерно формирование байтов сдвинутого кода из двух частей. Для \\( i \\)-го байта сдвинутого кода одна часть (пятиразрядная) образуется при сдвиге \\( i \\)-го исходного байта, а вторая часть (трехразрядная) образуется при сдвиге \\((i + 1)\\)-го исходного байта. Процедура сдвига должна начинаться со старшего (первого) байта. Сдвинутый код представляется тремя байтами, соответственно код трех старших выдвинутых разрядов \\( 1 \\)-го байта теряется.\\n\\nРеализация такого сдвига возможна на схеме рассматриваемого АУППД, что иллюстрируется последующим примером сдвига вышеприведенного кода на три разряда влево.\\n\\nЗдесь (в примере) указано содержание регистров \\( RGA \\), \\( RGB \\) и \\( RGC \\), участвующих в формировании трех байтов сдвинутого кода.\\n\\n\\[t_1 \\quad A \\quad 10101010 - прием \\quad \\sigma_x, \\quad B \\quad RGA \\quad (\\text{III 13}).\\]\\n\\n\\[A \\quad 01010000 - сдвиг \\quad кода \\quad B \\quad RGA \\quad (\\text{III 12}).\\]\\n\\n\\[B \\quad 01010000 - передача \\quad кода \\quad из \\quad RGA \\quad B \\quad RGB \\quad (\\text{III 11}, \\text{III 17}).\\]\\n\\n\\[A \\quad 11001100 - прием \\quad \\sigma_x, \\quad B \\quad RGA \\quad (\\text{III 13}).\\]\\n\\n\\[C \\quad 00000000 - установка \\quad 0 \\quad RGC \\quad (\\text{III 7}).\\]\\n\\n\\[t_2 \\quad A \\quad 01100000 - одновременное \\quad выполнение \\quad сдвига \\quad B \\quad RGA.\\]\\n\\n\\[C \\quad 00000110 - (\\text{III 12}) \\quad и \\quad RGC \\quad (\\text{III 6}) \\quad c \\quad передачей \\quad кодов, \\quad выдвигаемых \\quad из \\quad RGA \\quad B \\quad RGC \\quad (\\text{III 9}).\\]\\n\\n\\[B \\quad 01010110 - передача \\quad кода \\quad RGC \\quad на \\quad RGB \\quad (\\text{III 5}, \\text{III 17}), \\quad получение \\quad 1-го \\quad байта \\quad сдвинутого \\quad кода \\quad и \\quad его \\quad выдача \\quad c \\quad RGB \\quad B \\quad O3V \\quad (\\text{III 16}).\\]\\n\\nВ 01100000 A 11100011 C 00000000 A 00011000 C 00000111"}]"}],
[
    {
        "tag": "прием δx3 в RGA",
        "text": "прием \\( \\delta x_3 \\) в \\( RGA \\) (III 13)."
    },
    {
        "tag": "получение и выдача байтов сдвинутого кода",
        "text": "В 01100111 — получение 2-го байта сдвинутого кода и его выдача с \\( RGB \\) в ОЗУ (III 16). В остальном выполнение этапа \\( t_3 \\) полностью аналогично этапу \\( t_2 \\). А 00011000 — выдача 3-го байта сдвинутого кода из \\( RGA \\) в ОЗУ."
    },
    {
        "tag": "временная диаграмма выполнения сдвига",
        "text": "Временная диаграмма выполнения сдвига, соответствующая данному примеру, показана на рис. 5-14. Она построена при тех же временных параметрах, что и временная диаграмма выполнения операции вычитания (рис. 5-13). Время сдвига на один разряд здесь принято равным \\( t_{cAB} \\) на 1 разр = \\( 2t_n \\)."
    },
    {
        "tag": "структура тактов выполнения операции сдвига",
        "text": "Основу выполнения операции составляют повторяющиеся такты \\( t_2 \\), \\( t_3 \\). Их количество в общем случае равно \\( l - 1 \\). Эти основные такты дополняются тактом \\( t_1 \\) — прием и сдвиг 1-го байта исходного кода — и тактом \\( t_l \\) — выдача последнего байта с номером \\( l \\) сдвинутого кода в ОЗУ или «область регистров \\( R \\)». "
    },
    {
        "tag": "время выполнения сдвига кода",
        "text": "Время выполнения сдвига кода, состоящего из \\( l \\) байтов на \\( k \\) разрядов:\n\n\\[t_{cAB} \\text{ на } k \\text{ разр} = t_1 + (l - 1)t_2 + t_{l+1} \\approx l(2t_{обр} + kt_{cAB} \\text{ на 1 разр} + 2t_n).\\]"
    },
    {
        "tag": "алгоритм и время выполнения операции деления",
        "text": "Рассмотренные алгоритмы являются основой выполнения и длинных операций: умножения и деления. С помощью схемы AУППД, изображенной на рис. 5-12, возможно выполнение операции деления. При этом в \\( RGA \\) получают байты остатка \\( \\alpha_0 = [X]_A \\pm [Y]_A \\) и \\( \\alpha_t = 2\\alpha_{t-1} \\pm [Y]_A \\). Для хранения байтов делителя используется \\( RGB \\), а для запоминания кода байта частного \\( RGD \\). Сдвиг байтов остатка \\( \\alpha_t \\) осуществляется с помощью \\( RGA \\), \\( RGB \\) и \\( RGC \\).\n\nНа рис. 5-15 показана схема алгоритма выполнения операции деления над дополнительными кодами исходных чисел. Здесь два основных вычислительных процесса получения байтов остатка \\( \\alpha_t \\) и их сдвига дополнены операциями:\n\nанализа знаков делимого и делителя \\( (3_x и 3_y) \\) перед началом операции;\n\nанализа знаков остатка \\( (3_{\\alpha_t}) \\) и делителя \\( (3_y) \\) с формированием кода частного \\( Z_j \\) (\\( 1 \\leq j \\leq 8 \\)) и его запоминанием;\n\nпередачи на хранение полученного байта частного.\n\nВремя выполнения операции деления в основном определяется временем, необходимым на получение кода остатка \\( \\alpha_t \\), на выполнение его сдвига, и оценивается следующей формулой:\n\n\\[t_{дел} \\approx (t_\\pm + t_{сдв}) \\cdot 8l = 8l \\left[ l \\left( 3t_{обр} + t_S + t_n \\right) + \\frac{1}{2} \\left( 2t_{обр} + t_{сдв} \\text{ на 1 разр} + 2t_n \\right) \\right].\\]"
    },
    {
        "tag": "условия"}],
[{"tag":"таблица 5-2 типы АУ","text":"Таблица 5-2\n\n| Тип АУ | Код хранения чисел в ОЗУ |\n|---|---|\n|    | Примой    | Дополнительный    | Обратный    |\n| Параллельного действия | \\( t_{\\pm л} = t_{\\text{const}} + t_s \\) | \\( t^*_{\\pm л} = t^*_{\\pm o} = t_{\\text{const}} \\) |\n|    | \\( t^*_{\\pm o} = t_{\\text{const}} \\) |    |    |\n| Последовательного действия | \\( t'_{\\pm л} = t'_{\\pm o} = t'_{\\text{const}} + 2nt_{сл} \\) | \\( t^*_{\\pm л} = t'_{\\text{const}} + nt_{сл} \\) | \\( t'_{\\pm o} = t'_{\\text{const}} + 2nt_{сл} \\) |"},"{"tag":"статистика операций процессора","text":"Согласно статистическим данным, полученным при решении широкого класса задач на ЭВМ, на каждые 100 операций, выполняемых машиной, 25 раз выполняется умножение, 25 раз — сложение, вычитание, вычитание модулей, 1—2 раза — деление и приблизительно 50 раз — логические и прочие операции. Если при этом учесть, что \\( t_y = n (t_s + t_{\\text{cдв}}) \\) (при умножении с младших разрядов) больше чем в \\( n \\) раз превышает время выполнения сложения с фиксированной запятой, логических и прочих операций, то быстродействие процессора (арифметического устройства) в значительной степени определяется временем выполнения операции умножения."},{"tag":"логические методы повышения скорости умножения","text":"Повышение скорости умножения всегда приводит к включению дополнительного оборудования в схему АУ. Методы умножения, в которых количество дополнительного оборудования не зависит от разрядности перемножаемых чисел, получили название логических методов. Методы, в которых объем дополнительного оборудования пропорционален разрядности перемножаемых чисел, называются аппаратными.\n\nВторой характеристикой является зависимость сокращения времени выполнения операции от кодов сомножителей. В одних методах время умножения зависит от кодов чисел, участвующих в операции, другие, и их большинство, обеспечивают сокращение времени умножения независимо от кодов сомножителей."},{"tag":"умножение с пропуском такта суммирования","text":"Умножение с пропуском такта суммирования при нулевом коде множителя. Рассмотрим умножение чисел, представленных в прямом коде. Время выполнения операции умножения с младших разрядов множителя \\( t_y = n(t_s + t_{cAB}) \\). Для такой оценки при умножении на каждый разряд множителя \\( y_i \\) отводится \\( t_s \\). Но допустимо принять, что появление 0 или 1 в каждом разряде множителя равновероятно. Таким образом, есть объективные предпосылки исключения из времени умножения \\( t_s \\) при \\( y_i = 0 \\) и получения среднего времени умножения \\( t_y c_p = n\\left(\\frac{1}{2} t_s + t_{cAB}\\right) \\). В рассматриваемой методике сокращение времени умножения зависит от кодов множителя. Так, при \\( Y = 0,1 \\ldots 1 \\) время операции не уменьшается, а при \\( Y = 2^{-l} \\) (например, \\( Y = 0,010 \\ldots 0 \\) и т. д.) \\( t_y c_p = t_s + nt_{cAB} \\). Для количественной оценки сокращения времени выполнения операции удобно принять \\( t_s = k t_{cAB} \\) и получить отношение \\[\\frac{t_y c_p}{t_y} = \\frac{n\\left(\\frac{1}{2} t_s + t_{cAB}\\right)}{n(t_s + t_{cAB})} = \\frac{\\frac{1}{2} k + 1}{k + 1} = \\frac{k + 2}{2(k + 1)}.\\]\n\nПодставляя в полученное выражение значение \\( k \\), например \\( k = 2 \\) (\\( t_s \\) в 2 раза превышает \\( t_{cAB} \\)), получаем, что время выполнения операции в среднем сокращается на 34%."},{"tag":"умножение с прямыми и инверсными передачами","text":"Умножение с прямыми и инверсными передачами. Модуль любого кода множителя, состоящего из групп нулей или единиц, можно представить в виде разности двух кодов \\[|Y| = 0,000111100001111\\] \\[0,00100000010000\\] \\[0,00000100000001\\] \\[0,001000100010001\\]\n\nЗдесь же показано, что процедура вычитания двух кодов может быть представлена одним n-разрядным кодом, где \\( y_i = 1 \\) соответствует прямой передаче множимого (в сумматор передается \\(|X|\\)), а \\( y_i = 1 \\) соответствует инверсной передаче множимого (в сумматор передается \\(|-|X|_{j_0}\\)). Такая процедура позволяет уменьшить количество тактов суммирования при умножении.\n\nДанная методика является как бы развитием предыдущей, которую можно отнести к методике с «пассивным» сокращением количества тактов суммирования при умножении. Рассматриваемую следует отнести к методике с «активным» сокращением количества тактов суммирования. В ней не ограничиваются лишь сокращением тактов суммирования при \\( y_i = 0 \\) в исходном коде множителя и осуществляют его преобразование с целью получения в нем большего количества разрядов, имеющих нулевой код."},{"tag":"правила передачи при изолированных нулях и единицах","text":"Для того чтобы формализовать процедуру умножения по данной методике, назовем умножение на группу последовательных нулей множителя (\\( Y_i = . . . 0000 . . . \\)) режимом сдвига по нулям. Умножение на группу последовательных единиц (\\( Y_i = . . . 1111 . . . \\)) назовем режимом сдвига по единицам. Действительно, в этих случаях умножение заключается лишь в выполнении сдвигов. Но при переходе от группы последовательных нулей к группе последовательных единиц или наоборот необходимо выполнение передач множимого в сумматор. Правило выполнения этих передач:\n- если в режиме сдвига по нулям встречается 1, то осуществляются инверсная передача множимого в сумматор (с последующим сдвигом полученного частичного произведения в сумматоре) и переход на режим сдвига по единицам;\n- если в режиме сдвига по единицам встречается 0, то осуществляются прямая передача множимого в сумматор (с последующим сдвигом полученного частичного произведения в сумматоре) и переход на режим сдвига по нулям.\n\nНо такая процедура преобразования кода множителя оказывается неэффективной для некоторых частных случаев. Например, при коде \\( Y = 0,1010101 \\). Здесь количество передач не сократится, а увеличится, так как умножение будет выполняться в соответствии с преобразованным кодом множителя \\( Y_{\\text{пр}} = 1,1111111 \\).\n\nЧтобы избежать этого недостатка, введем понятия изолированного нуля и изолированной единицы, которые иллюстрируются следующими примерами:\n\\[\\begin{array}{ccc} 11111111 & 00000000 \\\\ 00010000 & 00010000 \\\\ 11101111 & 00010000 \\\\ \\end{array}\\]\n\nИзолированный нуль будем трактовать как сумму группы последовательных единиц и одной инверсной единицы. Изолированную единицу — как сумму группы последовательных нулей и одной единицы.\n\nРасширим вышесформулированное правило следующим дополнением:\n- если в режиме сдвига по нулям встречается изолированная единица, то осуществляется прямая передача множимого с сохранением режима сдвига по нулям;\n- если в режиме сдвига по единицам встречается изолированный нуль, то осуществляется инверсная передача множимого с сохранением режима сдвига по единицам.\n\nДля того чтобы уметь определять изолированную единицу или нуль, необходимо анализировать при умножении на каждый разряд множителя не только \\( y_i \\), но и \\( y_{i-1} \\). При этом всегда анализируется и третья двоичная переменная z, соответствующая режиму сдвига по нулям (\\( z = 0 \\)) или режиму сдвига по единицам (\\( z = 1 \\)).\n\nСледует заметить, что при такой методике минимальный объем групп последовательных нулей и единиц равен двум. Так что при исходном коде \\(|Y| = 0,1001010011\\) умножение будет производиться в соответствии с кодом \\(Y_{np} = 1,0101010101\\)."},"{"tag":"таблица 6-1 логика СУ","text":"Таблица 6-1\n\n| Входные сигналы | Выходные сигналы |\n|---|---|\n| \\(y_{i-1}\\) | \\(y_i\\) | \\(z\\) | \\(|X|\\) | \\([-|X|]_{n,0}\\) | \\(T_z\\) | \\(y\\) «0» | \\(y\\) «1» |\n| 0 | 0 | 0 | — | — | — | — | — | — |\n| 0 | 1 | 0 | + | — | — | — | — | — |\n| 1 | 0 | 0 | — | + | — | — | — | — |\n| 1 | 1 | 0 | — | + | — | — | — | — |\n| 0 | 0 | 1 | + | — | + | — | — | — |\n| 0 | 1 | 1 | — | + | — | — | — | — |\n| 1 | 0 | 1 | — | — | — | — | — | — |\n| 1 | 1 | 1 | — | — | — | — | — | — |\n\nВ табл. 6-1 определена логика работы основной части СУ (выработка сигналов второй группы). Эта таблица истинности составлена в полном соответствии с вышеприведенными правилами умножения с прямыми и инверсными передачами."},{"tag":"время выполнения умножения с прямыми и инверсными передачами","text":"Время выполнения умножения с прямыми и инверсными передачами уменьшается независимо от кодов множителя. Так, \\(t_y\\) макс \\(\\approx n \\left( \\frac{1}{2} t_s + t_{cab} \\right)\\) и будет определяться кодами типа \\(|Y| = 0,101010\\) или \\(|Y| = 0,11001100\\). Минимальное время — \\(t_y\\) мин = \\(2 t_s + n t_{cab}\\), что соответствует \\(Y = 0,1 \\ldots 1\\)."}],
[{"tag":"умножение в дополнительном коде","text":"Методика умножения с прямыми и инверсными передачами изложена применительно к прямым кодам исходных чисел. Распространять методику умножения чисел в дополнительном коде не имеет смысла. При умножении дополнительных кодов анализируется в каждом такте умножения \\\\([y_{n+2-i-1}-y_{n+1-i}]\\\\). Эта разность всегда будет равна 0 при группе последовательных единиц в коде \\\\([Y]_n\\\\). Исключая такт суммирования при нулевом коде этой разности, получают тот же эффект в сокращении времени выполнения операции, что и для перемножения прямых кодов социожителей с помощью прямых и инверсных передач."},{"tag":"аппаратные методы ускорения умножения","text":"6-2. Аппаратные методы повышения скорости выполнения умножения\n\nУмножение на два разряда одновременно. Этот метод рассмотрим на примере умножения с младших разрядов прямых кодов социожителей. Основа данного способа — умножение на каждую пару разрядов за время \\\\(t_s + t_{cдs}\\\\). Это возможно при одной передаче множимого в сумматор и наличии сдвига на два разряда при умножении на каждую пару разрядов."},{"tag":"умножение на два разряда одновременно","text":"Рассмотрим все комбинации кодов множителя в двух разрядах: 00, 01, 10 и 11. Код 00 — нет передачи множимого, код 01 — одна передача множимого, код 10 — также одна передача множимого, но со сдвигом \\\\((X \\cdot 2^{+1})\\\\). Код 11 можно образовать из кодов 100 и —01, так как\n\\\\[\\\\begin{array}{c} 100 \\\\\\\\ -01 \\\\\\\\ 11 \\\\end{array}\\\\]\nИз этого примера следует, что при умножении на код 11 можно осуществлять передачу множимого в соответствии с кодом — 01 (т. е. вычитать множимое)."},{"tag":"схема A^V","text":"Схема \\\\(A^V\\\\), реализующая данный способ, изображена на рис. 6-2. Здесь для каждого разряда \\\\(RG_{x_n}\\\\) предусмотрены три цепи передачи в сумматор в соответствии с кодами 01, 10 и —01. По шине умножения \\\\(III_y\\\\) подаются сигналы с периодом следования \\\\(t_s + t_{cдs}\\\\). Сдвиг осуществляется на два разряда одновременно. Оригинальной частью здесь является схема управления \\\\(CV\\\\), логика работы которой отражена в табл. 6-2."},{"tag":"время умножения на два разряда","text":"Время умножения в данном случае не зависит от перемножаемых кодов и равно:\n\\\\[t_y = \\\\frac{n}{2} (t_s + t_{\\\\text{сдв}}) + t_s.\\\\]"},{"tag":"умножение на три разряда одновременно","text":"**Умножение на три разряда одновременно.** Методика одновременного умножения на два разряда может быть распространена и на умножение на три разряда. Рассмотрим эту методику на примере умножения с младших разрядов прямых кодов исходных чисел.\n\nЗдесь необходимо обосновать алгоритм преобразования множителя, чтобы при умножении на любой трехразрядный код множителя была бы только одна передача множимого в сумматор.\n\nПроанализируем трехразрядные комбинации множителя: 000, 001, 010, 011, 100, 101, 110 и 111. Умножение на 001, 010 и 100 заключается в передаче в сумматор \\\\(X\\\\), \\\\(X \\cdot 2^{+1}\\\\) и \\\\(X \\cdot 2^{+2}\\\\) соответственно. Комбинация 111 может быть заменена кодом — 001, поскольку\n\\\\[\\\\begin{array}{c} 1000 \\\\\\\\ — 001 \\\\\\\\ 111 \\\\end{array}\\\\]\nс обязательным прибавлением 1 к следующим трем разрядам множителя."},{"tag":"схема AУ","text":"Умножение на 011, 110 и 101 требует усложнения схемы. В схему АУ вводится дополнительный регистр — \\\\(RG_{(X \\cdot 011)}\\\\), в котором перед началом операции будем получать код частичного произведения \\\\(X \\cdot 011\\\\). При этом умножение на 011 и 110 приведет к передаче с \\\\(RG_{(X \\cdot 011)}\\\\) в сумматор кода \\\\(X \\cdot 011\\\\) и \\\\((X \\cdot 011)^2\\\\) соответственно. Умножение на 101 будет выполняться в соответствии с кодом — 011, так как 1000 —011 101 с обязательным прибавлением к старшей тройке разрядов множителя. Все сказанное иллюстрируется следующим примером: если исходный код множителя \\\\(Y = 0,101 101 100 111\\\\), то умножение будет производиться в соответствии с преобразованным кодом \\\\(Y_{pr} = 1, — 011 110 — 011 — 001\\\\). Упрощенная схема АУ для умножения на три разряда одновременно приведена на рис. 6-3."},{"tag":"время умножения на три разряда","text":"Время умножения на три разряда одновременно равно:\n\\\\[ty = (st L) б\\\\]"},{"tag":"умножение в двухрядовом коде","text":"Умножение с использованием двухрядового кода. Этот метод в литературе часто встречается под другим названием — умножение с сохранением переноса. В этом методе исходные числа и результат представлены в однорядовом коде. Само умножение ведется в двухрядовом коде.\n\nРассмотрим пример выполнения умножения в двухрядовом коде над прямыми кодами исходных чисел. Допустим, \\\\([X]_n = 0,1111\\\\), а \\\\([Y]_n = 1,1011\\\\).\n\n\\\\[j = 1, \\; y_4 = 1 \\quad + \\quad 0 \\quad 0000 \\quad - \\text{исходное состояние сумматора}.\\\\]\n\n\\\\[\\\\begin{array}{c|cc} & 0 & 0000 \\\\\\hline 0 & 1111 & - |X| \\; y_4 \\\\\\ 0 & 1111 & - S^1 \\\\\\ 0 & 0000 & - P^1 \\\\\\end{array}\\\\]\n\n\\\\[i = 2, \\; y_3 = 1 \\quad + \\quad 0 \\quad 0111 \\quad 1 - S^1.2^{-1} \\quad - \\text{двухрядовый код перевозок частичного произведения } (A_1.2^{-1}).\\\\]\n\n\\\\[\\\\begin{array}{c|cc} & 0 & 1111 \\; - |X| \\; y_3 \\\\\\hline 0 & 1000 & 1 - S^2 \\\\\\ 0 & 0111 & - P^2 \\\\\\end{array}\\\\]\n\n\\\\[j = 3, \\; y_2 = 0 \\quad + \\quad 0 \\quad 0100 \\quad 01 - S^2.2^{-1} \\quad - \\text{двухрядовый код } A_2.2^{-1}.\\\\]\n\n\\\\[\\\\begin{array}{c|cc} & 0 & 0111 \\; - P^2 \\\\\\hline 0 & 0011 & 01 - S^3 \\\\\\ 0 & 0100 & - P^3 \\\\\\end{array}\\\\]\n\n\\\\[ j = 4, \\; y_1 = 1 \\\\\n\\\\[\\\\begin{array}{ccc} 0 & 0001 & 101 - S^3 \\cdot 2^{-1} \\\\\\ 0 & 0100 & -P^3 \\\\\\ + & 0111 & \\\\]"}],
[{"tag":"двухрядовый код умножения - шаги","text":"\\[- \\text{двухрядовый код} A_3 \\cdot 2^{-1}.\\]\\n\\[\\begin{array}{ccc} 0 & 1010 & 101 - S^4 \\\\ 0 & 0101 & -P^4 \\\\ \\end{array}\\]\\n\\[- \\text{двухрядовый код} A_4 = A_3 \\cdot 2^{-1} + |X| \\cdot y_1.\\]\\n\\[\\begin{array}{ccc} 0 & 0101 & 0101 - S^4 \\cdot 2^{-1} \\\\ 0 & 0101 & -P^4 \\\\ \\end{array}\\]\\n\\[- \\text{двухрядовый код произведения} A_4 \\cdot 2^{-1} = X \\cdot Y.\\]\\n\\[\\begin{array}{ccc} 0 & 1010 & 0101 \\\\ \\end{array}\\]\\n\\[- \\text{после распространения переноса однорядовый код произведения.}\\]\\nВ данном примере в каждом \\( i \\)-м такте умножения (кроме первого) суммируются три \\( n \\)-разрядных слагаемых \\( S^{i-1} \\cdot 2^{-1}, P^{i-1} \\times |X| y_{n+1-i} \\). Результат представляется двумя \\( n \\)-разрядными кодами:\\n\\[S^i = S^{i-1} \\cdot 2^{-1} \\oplus P^{i-1} \\oplus |X| y_{n+1-i} \\quad и\\]\\n\\[P^i = S^{i-1} \\cdot 2^{-1} \\land (|X| y_{n+1-i}) \\lor S^{i-1} \\cdot 2^{-1} \\land P^{i-1} \\lor P^{i-1} \\land \\land (|X| y_{n+1-i}).\\]"},{"tag":"аппаратная реализация схемы AV","text":"Для реализации такой процедуры удобно использовать в каждом разряде комбинационный сумматор \\( SM \\) и два элемента хранения. На рис. 6-4 изображена схема \\( AV \\) для умножения рассматриваемым методом. Здесь показаны два промежуточных разряда. Каждый разряд состоит из \\( SM \\) и двух синхронных триггеров. Парафазные выходы \\( SM \\) закоммутированы с установочными входами элементов хранения. Сдвиг двухрядового кода здесь осуществляется за счет косой передачи с выхода \\( T_i \\) на вход \\( SM_{i+1} \\). Все рассмотренное оборудование необходимо в каждом такте умножения для формирования двухрядового кода. Оборудование для распространения переноса, что необходимо для получения из двухрядового однорядового кода, здесь не показано."},{"tag":"оценка времени умножения и формулы T3 t_y","text":"Для выполнения умножения на каждый разряд подается один сигнал по \\( \\Pi_y \\). Этот сигнал передает код множимого, если \\( y_{n+1-i} = 1 \\), и безусловно обеспечивает передачу кодов \\( S^{i-1}_{i-1} \\) и \\( P^{i-1}_i \\) на входы SM. В каждом такте умножения с задержкой, равной \\( t_{sSM} + 2t_{sR} \\), относительно сигнала по Шу, подается сигнал по шине С. С помощью этого сигнала на синхронных элементах хранения устанавливается двухрядовый код А1. Время выполнения операции определяется суммарной задержкой T3 элементов, участвующих в формировании кода S1 и P1. Она равна сумме задержек четырех последовательно включенных элементов: двух конъюнкторов (один в схеме анализа кода \\( y_{n+1-i} \\), другой в цепи передачи с RGX на вход \\( y \\) SM) \\( 2t_{sR} \\), одноразрядного сумматора \\( t_{sSM} \\) и элемента хранения \\( t_{sT_i} \\), т. е.\\n\\[T_3 = 2t_{sR} + t_{sSM} + t_{sT_i}\\]\\nПри такой оценке можно считать, что минимально допустимый период следования сигналов, подаваемых по Шу, \\( t_{cn}(Шу) \\geq T_3 + t_{\\phi} \\), где \\( t_{\\phi} \\) — время установления кода на элементах хранения. Общее время умножения будет оцениваться следующей формулой:\\n\\[t_y = n(T_3 + t_{\\phi}) + t_S.\\]\\nЗдесь первая составляющая — время получения двухрядового кода произведения, а вторая составляющая \\( t_S \\) — время получения из двухрядового кода однорядового. В приведенной оценке времени выполнения умножения не отводится время на сдвиги кода частичных произведений. Как указывалось, эта операция выполняется за счет косой передачи. Таким образом, время умножения в двухрядовом коде сокращается по сравнению \\( c \\) \\( t_y = n(t_s + t_{cдв}) \\) на величину \\( \\Delta t_y \\approx n(t_p.п + t_{cдв}) - nT_3 \\), где \\( t_p.п \\) — время распространения переноса."},{"tag":"сравнение с другими методами умножения","text":"Если сравнение производить с умножением на основе использования сумматора со сквозным переносом, то \\( \\Delta t_y = n[(nt_s - T_3) + t_{cдв}] \\) представляет существенную величину, так как \\( nt_s \\gg T_3 \\). Сравнение с умножением на основе использования сумматора с одновременным переносом не дает такого эффекта, так как в данном случае\\n\\[t_p.п \\approx T_3.\\]\\nДанный метод находил широкое применение в машинах 2-го поколения. В машинах 3-го поколения он используется при умножении на все разря"}],
[{"tag":"процедура умножения этапов III‑IV‑V","text":"На этапе \\( III \\) происходит аналогичная процедура. Шесть слагаемых поступают на седьмую и восьмую линейки. В результате получаем четыре слагаемых (\\( S_7P_7 \\) и \\( S_8P_8 \\)). На этапе \\( IV \\) коды \\( S_7P_7S_8 \\) поступают на девятую линейку. На этапе \\( V \\) имеются только три слагаемых (\\( S_9P_9P_8 \\)), которые поступают на десятую линейку. На её выходе получаем двухрядовый код произведения. Рассмотренная процедура обеспечивает выполнение операции за \\( t_y = k t_{sSM} + t_s \\), где \\( k \\) — количество этапов, время выполнения каждого из них определяется \\( t_{sSM} \\). Вторая составляющая — \\( t_s \\) — здесь не изменяется. Число этапов \\( k \\) в зависимости от разрядности множителя приведено ниже: | Число разрядов множителя | Число этапов \\( k \\) | |---|---| | 3 | 1 | | 4 | 2 | | \\( 4<n\\leq6 \\) | 3 | | \\( 6<n\\leq9 \\) | 4 | | \\( 9<n\\leq13 \\) | 5 | | \\( 13<n\\leq19 \\) | 6 | | \\( 19<n\\leq28 \\) | 7 | | \\( 28<n\\leq42 \\) | 8 | | \\( 42<n\\leq63 \\) | 9 | Объём оборудования в данном случае по сравнению с ранее рассмотренной схемой практически остаётся без изменения. В том и другом случае при умножении, например, 12‑разрядных чисел требуется десять линеек сумматоров."},{"tag":"ускорение деления","text":"### 6-3. Повышение скорости выполнения деления Операция деления очень неудобна для повышения скорости выполнения. Количество разработанных методов повышения скорости деления невелико, большинство из них требует значительного объёма дополнительного оборудования и, как правило, не находит практического применения. Практический интерес представляет методика, в которой анализируется не только знак остатка, но и его значение. При этом в случае получения достаточно малого или достаточно большого по абсолютному значению остатка соответствующие разряды частного обязательно будут группой одинаковых цифр (нулей или единиц). Рассмотрим применение этой методики для деления со сдвигом остатка и автоматическим его восстановлением при условии, что исходные числа нормализованы и заданы в прямом коде. Допустим, на \\( t \\)-м шаге деления получили достаточно малый положительный остаток \\( \\alpha_t = 0, 0 \\ldots 0 a_{k+1} \\ldots a_n (\\alpha_t < 2^{-k}) \\). Можно утверждать, что в этом случае достаточно в разряды частного, начиная с \\( z_{t+1} \\), записать \\( k-1 \\) нуль и выполнить сдвиг \\( \\alpha_t \\) на \\( k \\) разрядов, т. е. \\( \\alpha_t \\cdot 2^k \\). Такой вывод очевиден. Действительно, если при таком остатке продолжать деление обычным способом, т. е. \\( 2\\alpha_t - Y = \\alpha_{t+1} \\) и т. д., получим \\( k-1 \\) отрицательный остаток, которому и соответствуют нулевые коды частного. Докажем, что количество нулей частного в данном случае не меньше \\( k-1 \\). Имеем остаток \\( 0 \\leq \\alpha_t = 0, 0 \\ldots 0 a_{k+1} \\ldots a_n \\leq 2^{-k} \\). Вычислим остаток \\( \\alpha_{t+1} = 2\\alpha_t - Y < 0 \\), здесь \\( 2\\alpha_t < 2^{-k+1} < 2^{-1} = Y_{\\text{н. мин}} (Y_{\\text{н. мин}} - минимальное значение нормализованного кода делителя}) \\). Вычислим остаток \\( \\alpha_{t+2} = 2\\alpha_{t+1} + Y = 2^2 \\alpha_t - Y \\), здесь \\( 2^2 \\alpha_t < 2^{-k+2} < 2^{-1} = Y_{\\text{н. мин}} \\) и \\( \\alpha_{t+2} < 0 \\), аналогично вычислим остатки \\( \\alpha_{t+3} \\ldots \\alpha_{t+k-2} \\). В конце вычислим остаток \\( \\alpha_{t+k-1} = 2^{k-1} \\alpha_t - Y \\), здесь \\( 2^{k-1} \\alpha_t < 2^{k-1} \\alpha_{t+k-2} = Y_{\\text{н. мин}} \\) и \\( \\alpha_{t+k-1} < 0 \\). Таким образом, мы показали, что все остатки от \\( \\alpha_{t+1} \\) до \\( \\alpha_{t+k-1} \\) меньше нуля и соответствующие им коды частного \\( z_{t+1} \\ldots z_{t+k-1} = 0 \\ldots 0 \\). Остаток, определяющий \\( z_{t+k} \\), т. е. \\( \\alpha_{t+k} = 2k\\alpha_t - Y \\), может иметь как положительное, так и отрицательное значение. Это очевидно из сравнения \\( 2^{-1} = 2^k \\alpha_t - 2^{k-1} \\alpha_{t+k-2} = 2^k \\alpha_t - 2^{k-1} \\alpha_{t+k-2} = 1 \\) и \\( 2^{-1} \\leq Y_{\\text{н}} < 1 \\). Случай малого по абсолютному значению отрицательного остатка аналогичен рассмотренному. В старших разрядах такого остатка будет находиться \\( k \\) единиц (отрицательный остаток \\( \\alpha_t < 2^{-k} \\) представлен в дополнительном или обратном коде). В этом случае достаточно в разряды частного с \\( z_{t+1} \\) записать \\( k-1 \\) единицу и выполнить сдвиг \\( \\alpha_t \\) на \\( k \\) разрядов, т. е. \\( \\alpha_t \\cdot 2^k \\). Рассмотрим обычную методику деления со сдвигом остатка, дополненную анализом малых остатков. Таким остатком соответствуют коды \\[\\begin{array}{cccc} 1, & 1 \\ldots 10 \\ldots & \\text{и} & 0, & 0 \\ldots 01 \\ldots \\\\ \\text{k единиц} & \\text{k нулей} \\\\ \\end{array}\\] Если ориентироваться на минимальный объём дополнительного оборота, то в каждом также делении необходимо анализировать три старших разряда остатка, включая знаковый. Алгоритм такого деления представлен в виде схемы на рис. 6‑9. В этой схеме наряду с обычными действиями, определёнными операторами \\( I, 2, 3, 4, 6 \\) и \\( 8 \\), предусмотрено выполнение дополнительных действий в соответствии с операторами \\( 5 \\) и \\( 9 \\). При этом в каждом \\( t \\)-м также проверяется наличие кода \\( 0,00 \\) или \\( 1,11 \\) в старших знаковых разрядах остатка \\( \\alpha_t \\). Если такие коды имеются, то формирование цифры частного \\( z_{t+1} \\) происходит без алгебраического суммирования. Затем осуществляется сдвиг остатка \\( \\alpha_t = 2\\alpha_{t-1} \\), после чего вновь переходим к выполнению оператора \\( 5 \\)."},{"tag":"пример деления прямых кодов","text":"Рассмотрим пример деления прямых кодов исходных чисел: 0,1001011    0,1010101 1,0101011 1,1110110 = \\alpha_0 < 0, z_0 = 0, в \\alpha_0 есть код 1,11 соответственно z_1 = 1, 1,1101100    выполняем сдвиг, вновь фиксируем наличие 1,11 и z_2 = 1, 1,1011000    выполняем сдвиг, коды 1,11 и 0,00 отсутствуют, 1,0110000    выполняем сдвиг с последующим суммированием, 0,1010101    получаем \\alpha_3 > 0 и z_3 = 1, 0,0000101 = \\alpha_3 определяем в \\alpha_3 код 0,00 и фиксируем z_4 = 0, 0,0001010    выполняем сдвиг, фиксируем код 0,00 и z_5 = 0"}],
[{"tag":"методика деления с анализом малых и больших остатков","text":"0,0010100    выполняем сдвиг, фиксируем код 0,00 и z₆ = 0,\n\n0,0101000    выполняем сдвиг, коды 0,00 и 1,11 отсутствуют,\n\n0,1010000    выполняем сдвиг с последующим вычитанием\n\n1,0101011\n\n1,1111011 = α₇ получаем α₇ < 0, фиксируем z₇ = 0, определяем в α₇ код 1,11 и фиксируем z₆ = 1.\n\nТаким образом, z = 0,1110001 (после округления). Для такой методики деления при условии, что все числовые комбинации кодов частного равновероятны, среднее время выполнения деления оценивается:\n\n\\[t_{дел.ср} = n \\left( \\frac{2}{3} t_S + t_{сд} \\right).\\]\n\nРассмотренная методика может быть дополнена анализом случаев достаточно больших по абсолютному значению остатков. Эти случаи возникают при условии, что \\(|α_i| \\approx Y\\). Например, α_i = 0,1...10 и Y = 0,1...1. Очевидно, и для этих случаев в разряды частного можно сразу записать группы единиц или нулей. Определить группу таких единиц можно следующим образом. Если 0 < α_i \\approx Y, то вначале получим: α_i' = α_i - Y. При этом в старших разрядах кода α_i будет находиться k единиц. Покажем, что количество единиц, которое необходимо записать в разряды частного, будет не менее k-1. Определим α_{i+1} = 2α_i - Y = 2α_i' + Y, так как α_i = α_i' + Y; здесь |2·α_i| < 2·2^{-k} < 2^{-1} = Y_{н.мин} и α_{i+1} > 0. Определим α_{i+2} = 2α_{i+1} - Y = 2^2·α_i' + Y, здесь |2^2·α_i'| < 2^2·2^{-k} < 2^{-1} = Y_{н.мин} и α_{i+2} > 0.\n\n156\n\nАналогично определим остатки \\( \\alpha_{i+3} \\ldots \\alpha_{i+k-2} \\), в конце определим \\( \\alpha_{i+k-1} = 2^{k-1} \\cdot \\alpha_i + Y \\); здесь\n\n\\[ |2^{k-1} \\cdot \\alpha_i| < 2^{k-1} \\cdot 2^{-k} = 2^{-1} = Y_{\\text{и. мин}} \\quad \\alpha_{i+k-1} > 0. \\]\n\nТаким образом, показано, что все остатки от \\( \\alpha_{i+1} \\) до \\( \\alpha_{i+k-1} \\) больше нуля и соответствующие им коды частного \\( z_{i+1} \\ldots z_{i+k-1} = 1 \\ldots 1 \\). Случай получения большого по модулю отрицательного остатка аналогичен рассмотренному.\n\n\\[\\begin{array}{c} I \\\\ \\downarrow \\\\ i:=0 \\\\ Z \\\\ X-Y=\\alpha_i \\end{array}\\]\n\n---\n\n3 Если \\( \\alpha_i \\geq 0 \\), то \\( z_i=1 \\) Если \\( \\alpha_i < 0 \\), то \\( z_i=0 \\)\n\n\\[\\begin{array}{c} \\text{Aa} \\\\ 4 \\\\ i<n+1 \\end{array}\\]\n\n\\[\\begin{array}{c} \\text{Окончание операции} \\\\ 5 \\\\ 0.00 или 11 \\\\ 6 \\alpha_i \\end{array}\\]\n\n\\[\\begin{array}{c} \\text{Нап} \\\\ 6 \\\\ i:=i+1 \\end{array}\\]\n\n\\[\\begin{array}{c} 7 \\\\ i:=i+1 \\end{array}\\]\n\n---\n\n8 \\(\\alpha_i := 2\\alpha_{i+1}+y\\), если \\( \\alpha_{i+1}<0 \\) \\(\\alpha_i := 2\\alpha_{i+1}-y\\), если \\( \\alpha_{i+1}\\geq 0 \\)\n\n9 \\(z_i=1\\), если \\( i,11 \\) \\(z_i=0\\), если \\( 0,00 \\) и \\( \\alpha_i = 2\\alpha_{i+1} \\)\n\nРис. 6-9. Схема алгоритма деления с анализом малых остатков\n\nТаким образом, чтобы дополнить методику деления с анализом малых остатков анализом больших остатков, необходимо в каждом такте деления предусмотреть: определение больших остатков на основе сравнения \\(|\\alpha_i| \\approx Y \\) с последующим получением \\( \\alpha_i' = \\alpha_i - Y (\\alpha_i \\geq 0) \\) или \\( \\alpha_i' = \\alpha_i + Y \\), если \\( \\alpha_i \\leq 0 \\); переход на циклическое исполнение операторов 5, 7 и 9, показанных на схеме рис. 6-9. Дополнение обычной методики ускорением анализа и больших остатков усложняет выполнение операции и оказывается не столь эффективным. Слабое влияние на уменьшение времени операции деления анализа больших остатков объясняется тем, что на группу одинаковых \\( k-1 \\) цифр частного требуется дополнительная операция алгебраического суммирования \\( \\alpha_i \\pm Y = \\alpha_i \\).\n\n157"},{"tag":"методы контроля арифметических устройств","text":"Глава седьмая\n\nОСНОВНЫЕ МЕТОДЫ КОНТРОЛЯ АРИФМЕТИЧЕСКИХ УСТРОЙСТВ\n\n7-1. Назначение и классификация методов контроля\n\nДля работы АУ и всей машины в целом характерно наличие отказов и сбоев, которые приводят к ошибкам в работе. Под отказом подразумевают событие, после появления которого нарушается правильное функционирование устройства. Восстановление правильной работы устройства возможно лишь в случае устранения причин, вызывающих отказы, что осуществляется заменой отказавшего оборудования или его ремонтом. Отказ приводит к систематическим ошибкам. Случайные ошибки являются следствием сбоя. Сбой — это отказ, действующий в ограниченный промежуток времени, после которого правильное функционирование устройства самовосстанавливается. Целью методов контроля работы АУ, получивших широкое распространение, является обнаружение ошибок. Таким образом, методы контроля не исключают (и не уменьшают) вероятность появления ошибок, а позволяют исключить влияние обнаруженных ошибок на правильность результатов, выдаваемых АУ. В том случае, когда ошибка произошла вследствие сбоя, исключение ее влияния на правильность результатов, выдаваемых АУ, достигается повторением участка вычислений, на котором эта ошибка обнаружена. При этом если ошибка порождена сбоем, то вероятность ее появления при повторении вычислений практически равна нулю. Если обнаруженная ошибка является следствием отказа, то осуществляется переход на выполнение диагностических процедур, с помощью которых обнаруживается отказавшая аппаратура. Таким образом, после обнаружения методом контроля ошибки, порожденной сбой или отказом, происходит либо восстановление искаженной информации (при сбое), либо восстановление отказавшей аппаратуры (при отказе). Контроль работы АУ и ЭВМ в целом весьма специфичен. Здесь невозможно осуществить контроль на основе широко распространенного в других областях техники сравнения результатов, выдаваемых АУ, с соответствующим эталоном. Таких эталонов нет, так как результаты, выдаваемые АУ, — это неизвестные величины. Специфичность в различных методах контроля проявляется по-разному. Наряду с отличием методов контроля по их существу для всех методов контроля характерно наличие избыточности. Она может проявляться в увеличении разрядной сетки передаваемых и обрабатываемых слов — информационная избыточность. Эта избыточность приводит к увеличению объема оборудования. Аппаратурная избыточность, которая в свою очередь скажется на увеличении времени выполнения операций, решения задачи — временная избы-"}],
[{"tag":"классификация методов контроля ЭВМ","text":"Методы контроля ЭВМ\\n\\nКонтроль породы Обнаружение и потребление Поправка парадигм, приравничения и логические преобразования\\n\\nОбнаружение и потребление Обнаружение и потребление\\n\\nПо мод. 2 Корректирую-щей кой-ленинная Корректирую-щая цикличе-ская коды Презданный Аппаратное Корректирующие приоритетные коды\\n\\nСчет в 2-3 руки Контроль основан-ной на стандарте решаемых задач Тестовый По мод. 2 По мод. 2 Различные базы резервирования\\n\\nС постоянными кодами С переменными кодами Двухпроводная логика\\n\\nРис. 7-1. Классификация методов контроля работы ЭВМ и ее устройств\\n\\n159"},{"tag":"группы методов контроля","text":"Рассмотрим классификацию методов контроля работы ЭВМ и ее устройств и выделим из них те, которые в настоящее время широко используются для контроля АУ. На рис. 7-1 все методы контроля подразделяются на две основные группы. Первая объединяет методы контроля передач, которые используются для контроля передач между накопителями на магнитных барабанах, дисках, лентах и других устройствах ЭВМ, для контроля передачи информации по каналам. Вторая группа объединяет методы, позволяющие контролировать выполнение арифметических и логических операций, а также и передач информации. Каждая из этих групп подразделяется на две подгруппы, которые объединяют либо методы, обеспечивающие лишь обнаружение ошибок, либо методы, обеспечивающие как обнаружение, так и исправление ошибок (корректирующие коды)."},{"tag":"тестовые и аппаратные методы обнаружения ошибок","text":"Для контроля работы АУ в настоящее время получили широкое распространение тестовые и аппаратные методы, обеспечивающие только обнаружение ошибок. Изложению этих методов в основном и посвящена данная глава."},{"tag":"корректирующие коды арифметические","text":"Методы, обеспечивающие обнаружение и исправление ошибок за счет применения арифметических корректирующих кодов, не нашли еще применения, так как их использование приводит к значительному усложнению алгоритмов контролируемых операций, увеличению объема оборудования и времени выполнения операций."},{"tag":"резервирование и мажоритарная логика","text":"В области специализированных ЭВМ, построенных на основе интегральной схемотехники, для обнаружения и исправления ошибок при выполнении арифметических и логических преобразований применяются различные виды резервирования, основанные на использование мажоритарной логики, логики с переплетениями и других видов. Такой подход к организации контроля является самостоятельным направлением и в данной книге не рассматривается."},{"tag":"тестовый контроль определение","text":"7-2. Тестовый контроль\\n\\nТест для проверки АУ — это испытательная программа, по правильному выполнению которой судят о пребывании устройства в работоспособном состоянии (отсутствуют отказы и сбои) в момент контроля."},{"tag":"требования к тестам АУ","text":"К тестам АУ предъявляются следующие требования: проверка максимального количества узлов, схем АУ в наиболее тяжелых режимах; минимум команд в тесте; многократное (циклическое) повторение теста; фиксация команд теста, при выполнении которых обнаруживаются ошибки."},{"tag":"тест с постоянными кодами организация","text":"Простейшая организация теста для проверка АУ заключается в следующем. Выбирается ограниченное количество n-разрядных двоичных кодов, и над отдельными парами кодов выполняются арифметические или логические операции с целью получения правильных результатов. Выбранные исходные (так называемые постоянные) коды и соответствующие им результаты арифметических и логических операций помещаются в ОЗУ ЭВМ."},{"tag":"схема программы теста","text":"Затем по специальной программе над определенной парой введенных кодов выполняется арифметическая операция и полученный результат в АУ\\n\\n160\\n\\nсравнивается с заранее введенным, правильным результатом. В случае совпадения сравниваемых кодов (правильного выполнения операции) указанная процедура повторяется для следующей операции и т. д. до тех пор, пока не будет проверено выполнение всех операций."},{"tag":"выбор кодов для теста сложения","text":"Выбор исходных кодов зависит от типа операции. Так, при контроле\\n\\nРис. 7-2. Схема программы теста с постоянными кодами\\n\\nоперации сложения целесообразно выбирать коды, обеспечивающие распространение переноса по всей разрядной сетке, а также коды, обеспечивающие выработку переноса в каждом разряде, т. е.\\n\\n\\\\[\\\\begin{array}{ccc} 101010101 & \\\\text{или} & + \\\\\\\\ 011101010 & & \\\\text{1111} \\\\ldots \\\\text{1111} \\\\\\\\ 001000000 & & \\\\text{1111} \\\\ldots \\\\text{1111} \\\\\\\\ \\end{array}\\\\]"},{"tag":"локализация неисправности","text":"161\\n\\nТакой выбор кода позволяет для некоторых операций с определенной степенью приближения локализировать место неисправности в случае обнаружения ошибки при выполнении операции. С помощью указанных тестов обнаруживается лишь часть ошибок, возникающих при отказах и сбоях. Этот тест субъективен, он работает с весьма ограниченным количеством двоичных кодов, и при этом часто имеет место следующая ситуация. Тест проходит без сбоев, а при выполнении программы конкретной задачи встречаются не только сбои, но и отказы. Обычно эти тесты обеспечивают лишь грубую проверку работоспособности устройства и используются на первых этапах отладки \\\\( A \\\\bar{Y} \\\\) в составе вновь создаваемой ЭВМ."},{"tag":"тест с переменными кодами","text":"Отмеченные недостатки тестов с постоянными кодами исключены в тестах с переменными кодами. Структурная схема программы такого теста показана на рис. 7-3. Здесь наряду с ранее разобранными операторами включена программа или оператор выработки случайных чисел. В практике ЭВМ широко используются программные методы, обеспечивающие получение псевдослучайных чисел. Для выработки одного \\\\( n \\\\)-разрядного кода требуется выполнение ограниченной последовательности команд ЭВМ (в машине «Минск-32» эта последовательность состоит из семи команд)."},{"tag":"генерация псевдослучайных кодов","text":"В этом тесте ликвидированы субъективность и ограниченность в выборе исходных кодов, с которыми работает испытательная программа. Тест работает с псевдослучайными кодами, совокупность которых весьма близка к информации, обрабатываемой в \\\\( A \\\\bar{Y} \\\\) при решении широкого класса задач на ЭВМ."},{"tag":"преимущества тестов с переменными кодами","text":"Отличие теста не ограничивается случайным (переменным) характером обрабатываемой информации. Существенно видоизменяется алгоритм проверки, т. е. нельзя заранее получить (знать) результат арифметической или логической операции над случайными кодами. Основой алгоритма проверки чаще всего является получение одного и того же результата двумя разными путями с последующим сравнением. Например, при проверке сложения получаем сумму дважды: \\\\[S_1 = X_1 + X_2, \\\\quad S_2 = X_2 + X_1.\\\\] За счет перемены местами комплектной проверки операция умножения. Используется проверка выполнения одной операции через другую (которая уже проконтролирована). Например, деление проверяется через умножение. Для проверки логических операций используются соотношения \\\\[X_1 \\\\sqrt{1} = X_1\\\\] или \\\\[X_1 \\\\sqrt{0} = X_1,\\\\] где \\\\[X_1 = \\\\text{"}],
[{"tag":"контроль по модулю 2 общие положения","text":"Общие положения. Этот вид контроля очень широко распространен в ЭВМ и часто встречается под другими названиями (контроль четности, контроль нечетности). В этом методе к \\( n \\)-разрядному двоичному слову \\[(x_1, x_2, \\ldots, x_{n-1}, x_n)\\] добавляется один контрольный, избыточный разряд \\( x_{n+1} \\). В этом разряде фиксируется код, соответствующий четному или нечетному количеству единиц, содержащихся в \\( n \\)-разрядном слове."},{"tag":"условие четности по модулю 2","text":"Код разряда \\( x_{n+1} \\) выбирается так, чтобы сумма \\[\\sum_{i=1}^{n+1} x_{i \\text{мод} 2} = x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_n \\oplus x_{n+1}\\] была бы четной (равна нулю) или нечетной (равна единице). При этом справедливы следующие эквивалентности."},{"tag":"формулы кода четности и нечетности","text":"162\n\nДля кода нечетности\n\n\\[x_{n+1} = \\sum_{i=1}^{n} x_i \\text{ мод 2 } \\cdots \\tag{7-1}\\]\n\nДля кода четности\n\n\\[x_{n+1} = \\sum_{i=1}^{n} x_i \\text{ мод 2 } \\cdots \\tag{7-2}\\]"},{"tag":"пример контроля четности и нечетности","text":"Например, имеем два кода 11010 и 11101. Если применить контроль по четности, избыточные коды имеют вид: 11010 1 и 11101 0, соответственно. При коде нечетности избыточные коды имеют вид: 11010 0 и 111010 1."},{"tag":"разрешенные и запрещенные коды","text":"При таком кодировании вся совокупность \\( (n + 1) \\)-разрядных слов делится на две группы. В одну группу входят так называемые разрешенные коды (имеющие, например, нечетное количество единиц в слове), а другая образуется из запрещенных кодов (для них характерно четное количество единиц в слове). С помощью таких кодов легко обнаруживаются при передачах как одиночные, так и пакет из нечетного количества ошибок (ошибки, происходящие в разрядах 3, 5, 7 и т. д.). Эти пакеты, как и одиночные ошибки, всегда будут переводить разрешенную комбинацию в запрещенную."},{"tag":"проверка полученного кода по модулю 2","text":"Сущность контроля передач по модулю 2 заключается в следующем. В канал передачи поступает избыточный код \\( x_1, x_2, \\ldots, x_n \\). Принятый, переданный код обозначим \\( x'_1, x'_2, \\ldots, x'_n \\),\n\n\\[\\begin{array}{c|c} x'_{n+1} & 3\\text{десь } x'_t \\\\ \\hline \\end{array}\\]\n\nобозначает код разряда, в котором при передаче может произойти ошибка. Для принятого кода из условия, что\n\n\\[\\sum_{i=1}^{n} x'_i \\text{ мод 2 } = x'_{n+1} \\]\n\nдля кода четности,\n\n\\[\\sum_{i=1}^{n} x'_i \\text{ мод 2 } = x'_{n+1} \\]\n\nдля кода нечетности,\n\nопределяется код \\( x'_{n+1} \\), который сравнивается с \\( x'_{n+1} \\). Если одиночной ошибки или пакета, состоящего из нечетного количества ошибок, не произошло, то \\( x'_{n+1} = x'_{n+1} \\)."},{"tag":"преимущества кода нечетности","text":"Эффективность контроля с помощью кода нечетности (7-1) и кода четности (7-2) одинакова, практически равноценна и их реализация. Некоторое предпочтение следует отдать коду нечетности. Он позволяет отличить нулевую информацию от потерянной. Так, \\( n \\)-разрядный нулевой код кодируется как 00 ... 00 1, а потерянная информация (например, в случае потери сигнала, обеспечивающего передачу кода с \\( n \\)-разрядного регистра) — 00 ... 00 0. Это преимущество особенно эффективно проявляется при последовательной передаче (без аппаратных и временных затрат определяется наличие кода 00 ... 00 в \\( n + 1 \\) разряде передаваемого кода)."},{"tag":"повышение эффективности контроля по модулю 2","text":"163\n\nЗффективность контроля по модулю 2 может быть повышена за счет контроля частей \\( n \\)-разрядного передаваемого кода. Так, в современных ЭВМ контроль по модулю 2 распространяется на байт передаваемой информации."},{"tag":"контроль работы сумматора","text":"Контроль работы сумматора. Несмотря на простоту, контроль по модулю 2 широко используется для контроля арифметических операций. Основой такого контроля является контроль работы сумматора, который позволяет проконтролировать как короткие (сложение, вычитание), так и длинные (умножение и деление) арифметические операции."},{"tag":"код четности суммы при сложении","text":"Рассмотрим операцию суммирования \\( n \\)-разрядных чисел в обратном коде:\n\n\\[x_1 x_2 \\ldots x_{n-1} x_n\\]\n\n\\[\\vdots\\]\n\n\\[y_1 y_2 \\ldots y_{n-1} y_n\\]\n\n\\[\\underline{S_1 S_2 \\ldots S_{n-1} S_n}\\]\n\nОпределим код четности суммы:\n\n\\[\\sum_{i=1}^{n} S_i \\text{ мод } 2 = S_1 \\oplus S_2 \\oplus \\ldots \\oplus S_{n-1} \\oplus S_n.\\]\n\nЗаменим \\( S_i = x_i \\oplus y_i \\oplus P_{i+1} \\), получим:"}]"}],
[
    {
        "tag": "идентичность контроля четности сумматора",
        "text": "\\[\\sum_{i=1}^{n} S_i \\text{ мод } 2 = (x_1 \\oplus y_1 \\oplus P_2) \\oplus (x_2 \\oplus y_2 \\oplus P_3) \\oplus \\ldots\\]\n\\[\\cdots \\oplus (x_{n-1} \\oplus y_{n-1} \\oplus P_n) \\oplus (x_n \\oplus y_n \\oplus P_1) = (x_1 \\oplus x_2 \\oplus \\ldots \\oplus x_n) \\oplus (y_1 \\oplus y_2 \\oplus \\ldots \\oplus y_n) \\oplus \\ldots\\]\n\\[\\cdots \\oplus (P_1 \\oplus P_2 \\oplus \\ldots \\oplus P_n) = \\sum_{i=1}^{n} x_i \\text{ мод } 2 \\oplus\\]\n\\[\\oplus \\sum_{i=1}^{n} y_i \\text{ мод } 2 \\oplus \\sum_{i=1}^{n} P_i \\text{ мод } 2 \\cdots\\]\n(7-3)"
    },
    {
        "tag": "контрольные коды четности",
        "text": "Обозначив контрольные коды четности буквами \\( k_S \\), \\( k_x \\), \\( k_y \\) и \\( k_p \\), получим тождество (7-3) в виде\n\n\\[k_S = k_x \\oplus k_y \\oplus k_p\\]\n\nили\n\n\\[k_S \\oplus k_x \\oplus k_y \\oplus k_p = 0 \\ldots\\]\n\n(7-4)"
    },
    {
        "tag": "схема контроля сумматора",
        "text": "Полученное тождество и определяет сущность контроля сумматора, контроля сложения двух чисел. Код четности суммы равен сумме по модулю 2 контрольных кодов слагаемых и контрольного кода переносов. Важным выводом из полученного контрольного соотношения является необходимость формирования и учета контрольного кода переноса. Контроль работы сумматора по коду четности иллюстрируется схемой, изображенной на рис. 7-4. Здесь наряду с традиционными \\( (n+1)-разрядными регистрами слагаемых \\( RG_{X_i} \\) и \\( RG_{Y_i} \\) и сумматором показаны схемы получения \\[ \\sum_{i=1}^n S_{i \\text{мод}2} = k_s \\] и \\[ \\sum_{i=1}^n P_i = k_p \\] и схема, реализующая контрольное соотношение (7-4). Появление сигнала в точке A свидетельствует о наличии ошибки."
    },
    {
        "tag": "пример 1 контроля сумматора",
        "text": "Пример 1.\n\n\\[P_i \\quad 0 \\quad 1 \\quad 0 \\quad 1 \\quad 1 \\quad 1 \\quad 0 \\quad 0 \\quad 1 = k_p\\]\n\n\\[x_i \\quad 0 \\quad 1 \\quad 0 \\quad 1 \\quad 1 \\quad 1 \\quad 0 \\quad 1 \\quad 0 = k_x\\]\n\n\\[y_i \\quad 0 \\quad 1 \\quad 0 \\quad 1 \\quad 0 \\quad 0 \\quad 1 \\quad 1 \\quad 0 \\quad 0 = k_y\\]\n\n\\[\\begin{array}{c} S_i \\quad 1 \\quad 0 \\quad 1 \\quad 1 \\quad 0 \\quad 0 \\quad 1 \\quad 1 \\quad 1 = k_S \\end{array}\\]\n\nОперация сложения выполнена правильно, что следует из контрольного соотношения (7-4), т. е. \\( k_S \\oplus k_x \\oplus k_y \\oplus k_p = 1 \\oplus \\oplus 0 \\oplus 0 \\oplus 1 = 0 \\)."
    },
    {
        "tag": "пример 2 контроля сумматора",
        "text": "Пример 2. Допустим, при сложении происходит одиночная ошибка B це- пях формирования суммы P, 010111100 1=k ‚ 010111101 0=k и 010100110 0=k S 101100001 0=k B данном случае ks ® & Dk, Dk, =0H0B0B1=1, что свидетельствует O наличии ошибки. Также будут обнаружены ошибки, возникающие в цепях формирования суммы в любом нечетном количестве разрядов."
    },
    {
        "tag": "пример 3 контроля сумматора",
        "text": "Пример 3. Допустим, ошибка произошла в цепях формирования переноса в третьем разряде (появился лишний импульс переноса) Р, Ol 11111 0=k х 0101111 1=k + и 0101001 1=k, S 1111000 0=k Возникшая ошибка He обнаруживается, Tak как ks Bk, D Dk, Dkp,=0D1PD1PH0=0. Это произошло потому, что ошибка, возникающая в цепи переноса в i-M разряде, приводит к ошибке B коде суммы (г + 1)-го разряда. Две такие ошибки контрольным соотношением (7-4) не обнаруживаются."
    },
    {
        "tag": "пример 4 контроля сум"}],
[
    {
        "tag": "дублирование переноса и контрольные коды",
        "text": "Дублирование переноса и его сравнение с основным в каждом разряде с помощью схемы сложения по модулю 2 отражены на схеме сумматора, показанной на рис. 7-5. На этой схеме отражены оборудование, необходимое для получения контрольных кодов четности переноса \\( k_p \\) и суммы \\( k_s \\), для контроля суммы в соответствии с контрольным соотношением (7-4), а также дизъюнктор на \\( n + 1 \\) вход. На выходе дизъюнктора в случае появления одиночной, нечетной ошибки в схемах, формирующих код суммы, или в случае одиночной или групповой ошибки в цепях переноса появляется сигнал ошибки."
    },
    {
        "tag": "первый вариант дублирования переноса",
        "text": "Схемное решение дублированного переноса \\( \\Pi_n \\) зависит от основного переноса \\( O_n \\). Это особенно проявляется в сумматорах с одновременным переносом. Здесь дублирование схем переноса потребует большого объёма дополнительного оборудования. Уменьшение затрат оборудования возможно за счёт введения дублированного переноса в каждом разряде в соответствии с уравнением (7-6). При этом одновременный перенос будет использоваться для формирования суммы, а дублированный только для обнаружения ошибок переноса. Существо обнаружения ошибок переноса, а также и‑ошибок суммы ТО же, что и B ранее рассмотренном сумматоре. Существует другое решение (второй вариант) построения сумматоров с контролем по модулю 2. Для него характерно некоторое упрощение логики контроля, что приводит к сокращению объёма оборудования. Основой этих решений является использование, как в первом варианте, дублирования переноса и несколько видоизменённого контрольного соотношения (7-4) в виде ks ФА ФА Ф kpz= s T _F—ljJ И 7 P : Каа owubru (7-7). В соотношении (7-7) используется контрольный код не OCHOB‑нного, а дублированного переноса."
    },
    {
        "tag": "второй вариант контроля по модулю 2",
        "text": "Второй вариант контроля по модулю 2 отражён на схеме рис. 7-6. Для переноса \\( P_t \\) и \\( P_{i-1} \\) имеют место отдельные схемы, логика которых определяется уравнениями \\[P_t = D_i \\sqrt{\\Sigma_i} \\wedge D_{t+1} \\sqrt{\\Sigma_i} \\wedge \\Sigma_{i+1} \\wedge D_{t+2} \\vee \\ldots \\]\\[\\vdots \\quad \\sqrt{\\Sigma_i} \\wedge \\Sigma_{i-1} \\wedge \\Sigma_{i+2} \\wedge \\ldots \\wedge \\Sigma_{n-1} \\wedge D_n;\\]\\[P_{i-1} = D_{i-1} \\sqrt{\\Sigma_{i-1}} \\wedge D_i \\sqrt{\\Sigma_{i-1}} \\wedge \\Sigma_i \\wedge D_{t+1} \\vee \\ldots \\]\\[\\vdots \\quad \\sqrt{\\Sigma_{i-1}} \\wedge \\Sigma_i \\wedge \\Sigma_{i+1} \\wedge \\ldots \\wedge \\Sigma_{n-1} \\wedge D_n.\\] Ошибки, возникающие в схемах, реализующих \\( D_i \\ldots D_n \\) и \\( \\Sigma_i \\ldots \\Sigma_n \\), приводят к ошибкам как в \\( P_t \\), так и \\( P_{i-1} \\). Но ошибки в схемах, реализующих функции конъюнкции и дизъюнкции в вышеприведённых уравнениях, автономны и могут распространяться только на \\( P_t \\) или на \\( P_{i-1} \\). Обнаружить такие ошибки возможно только путём сравнения \\( P_t \\) с \\( P_{i \\mu} \\) или \\( P_{i-1} \\) с \\( P_{(i-1) \\mu} \\). При этом достаточно проводить сравнения кодов основного и дублированного переноса не в каждом разряде, а в одном из разрядов каждой пары."
    },
    {
        "tag": "условие S_i = ψ_i ⊕ P_i и таблица истинности",
        "text": "Для работы сумматора, в котором \\( S_i = f(x_i, y_i, P_{i+1} \\text{ и } P_i) \\), необходимо выполнение условия \\[S_i = \\psi_i \\oplus P_i,\\] где \\( \\psi_i \\) является функцией от \\( x_i, y_i \\text{ и } P_{i+1} \\). Таблица истинности такой суммирующей схемы (табл. 7-1) выглядит так: \\[\\begin{array}{ccccc} x_i & y_i & P_{i+1} & \\Psi_i & P_i & S_i \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 1 & 0 & 1 \\\\ 1 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 1 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 1 & 1 & 0 \\\\ 1 & 0 & 1 & 1 & 1 & 0 \\\\ 1 & 1 & 1 & 0 & 1 & 1 \\\\ \\end{array}\\] Из таблицы следует, что \\[\\bar{\\psi}_i = \\bar{x}_i \\land \\bar{y}_i \\land \\bar{P}_{i+1} \\lor x_i \\land y_i \\land P_{i+1},\\] откуда \\[S_i = (\\bar{x}_i \\land \\bar{y}_i \\land \\bar{P}_{i+1} \\lor x_i \\land y_i \\land P_{i+1}) \\oplus P_i.\\] При использовании полученного уравнения для построения тракта формирования \\( S_i \\) в сумматоре и предполагая, что для формирования переноса \\( P_i \\) используется уравнение сквозного или одновременного переноса, необходимо учитывать, что недопустимо использовать одинаковые схемы для формирования идентичных составляющих в уравнениях \\( S_i \\) и \\( P_i \\). Нарушение этого условия может привести к чётной (двойной) ошибке в \\( S_i \\), которая не будет обнаружена контрольным соотношением (7-4)."
    },
    {
        "tag": "контроль операции сложения‑вычитания и преобразование кодов",
        "text": "Контроль операции сложения‑вычитания основан на методах контроля сумматора, но требует дополнения контролем преобразования кодов слагаемых из прямого кода в обратный или дополнительный и обратно. Коды чисел поступают из ОЗУ в прямом, обратном или дополнительном коде с соответствующими контрольными кодами. При вычитании или сложении они участвуют в преобразованном виде, что может изменить контрольный код. Рассмотрим преобразование \\( n \\)-разрядного кода (\\( n \\) включает и знаковый разряд) из прямого в обратный. Если \\( n \\) чётно, то \\( k_{ok} = k_{nk} \\), если \\( n \\) нечётно, \\( k_{ok} = k_{nk} \\). Аналогичные соотношения справедливы и для преобразования из обратного кода в прямой. При операции сложения‑вычитания преобразование может сопровождаться изменением знакового разряда (инвертируются все \\( n \\) разрядов). Например, при исходных \\([X]_0\\) и \\([Y]_0\\) требуется выполнить \\([X]_0 - [Y]_0 = [X]_0 + [-Y]_0\\). Здесь контрольный код инвертированных \\( n \\) разрядов \\( k_{nk} = k_{ok} \\), если \\( n \\) чётно, и \\( k_{nk} = k_{ok} \\), если \\( n \\) нечётно. Преобразование контрольного кода при переходе от прямого к дополнительному учитывает, что \\([X < 0]_n = [X]_"}],
[
    {
        "tag": "контрольные коды сдвинутого числа",
        "text": "Здесь контрольные коды сдвинутого числа или слова обозначены \\\\( k_{cAB} \\\\), исходного кода \\\\( k_{HCX} \\\\), введенных разрядов при сдвиге \\\\( k_{BBEД} \\\\) и выведенных разрядов \\\\( k_{BbHEД} \\\\)."
    },
    {
        "tag": "контроль логических операций",
        "text": "Контроль логических операций. К этой группе операций, выполняемых любой ЭВМ, относятся сложение по модулю, логическое умножение и сложение. Контроль таких операций основан на дублировании аппаратуры или на повторении операций."
    },
    {
        "tag": "минимизация оборудования для контроля",
        "text": "Если принимается за основу первый подход (дублирование аппаратуры), то необходимо использовать решение, минимизирующее объем дополнительного оборудования для контроля логических операций. Такое решение предусматривает максимальное использование оборудования, предназначенного для выполнения и контроля операции арифметического суммирования кодов."
    },
    {
        "tag": "схема одноразрядного сумматора и контрольные коды",
        "text": "На рис. 7-7 изображена схема одноразрядного сумматора (\\\\( SM_i \\\\)) с двумя n-разрядными схемами, связанными с выходами \\\\( P_i \\\\) и \\\\( S_i \\\\), на которых получаются контрольные коды\\\\n\\\\n\\\\[\\\\n k_p = \\sum_{i=1}^n P_i \\text{мод } i \\quad \\text{и } k_S =\\\\n\\\\]\\n\\\\n\\\\[\\\\n = \\sum_{i=1}^n S_i \\text{мод } i.\\\\n\\\\]"
    },
    {
        "tag": "логические уравнения сумматора",
        "text": "Логика работы данного сумматора описывается следующими логическими уравнениями:\\\\n\\\\[\\\\nP_i = x_i \\land y_i \\lor (x_i \\lor y_i) \\land p_{i+1};\\\\n\\\\]\\n\\\\n\\\\[\\\\nS_i = (x_i \\oplus y_i) \\land \\overline{P}_{i+1} \\lor (x_i \\oplus y_i) \\land P_{i+1}.\\\\n\\\\]"
    },
    {
        "tag": "дополнительное оборудование для дублирования",
        "text": "К этому основному добавлено оборудование, позволяющее продублировать выполнение и осуществить контроль логических операций. Это оборудование показано на рис. 7-7 пунктиром."
    },
    {
        "tag": "коммутация по шинам A B C",
        "text": "Коммутация оборудования на выполнение и контроль той или иной операции осуществляется подачей сигнала на одну или две шины из трех: \\\\( A(x_i + y_i), B(x_i \\oplus y_i) \\\\) и \\\\( C(x_i \\land y_i) \\\\)."
    },
    {
        "tag": "контроль через шину A (сложение)",
        "text": "При подаче сигнала только по шине \\\\( A \\\\) происходит суммирование исходных кодов \\\\( x_i \\\\) и \\\\( y_i \\\\), вырабатываются коды \\\\( S_i \\\\) и \\\\( P_i \\\\)."
    },
    {
        "tag": "контроль через шину C (логическое умножение)",
        "text": "Подача сигнала только по шине \\\\( C \\\\) обеспечивает выполнение и контроль \\\\( x_i \\land y_i \\\\). В данном режиме на выходе \\\\( P_i = x_i \\land y_i \\\\) и на выходе \\\\( S_i = x_i \\land y_i \\\\). Соответственно на выходах \\\\( k_p = k_{x_i \\land y_i} \\\\) и \\\\( k_S = k_{x_i \\land y_i} \\\\). Сравнивая \\\\( k_p = k_s \\\\), осуществляем контроль операции логического умножения."
    },
    {
        "tag": "реализация контроля XOR",
        "text": "Реализация выполнения и контроля \\\\( x_i \\oplus y_i \\\\). Эта операция заключается в следующем:\\\\n\\\\[\\\\n\\\\begin{array}{cccc} x_1 & x_2 & \\cdots & x_n \\\\ \\oplus & y_1 & y_2 & \\cdots & y_n \\\\ \\end{array}\\\\n\\\\]\\n\\\\n\\\\[(x_1 \\oplus y_1) (x_2 \\oplus y_2) \\cdots (x_n \\oplus y_n)\\\\n\\\\]\\n\\\\nи контрольный код этого результата\\\\n\\\\[\\\\n\\sum_{i=1}^n (x_i \\oplus y_i)_{мод} = (x_1 \\oplus y_1) \\oplus (x_2 \\oplus y_2) \\oplus \\cdots \\oplus (x_n \\oplus y_n) = (x_1 \\oplus \\cdots \\oplus x_n) \\oplus (y_1 \\oplus \\cdots \\oplus y_n) = k_x \\oplus k_y.\\\\n\\\\]"
    },
    {
        "tag": "контроль XOR через шину B",
        "text": "Подавая сигнал только по шине \\\\( B \\\\), на выходе \\\\( S_i = x_i \\oplus y_i \\\\) и на выходе \\\\( k_s = k_{x_i \\oplus y_i} \\\\). Имея контрольный код результата и контрольные коды исходных чисел \\\\( k_x \\\\) и \\\\( k_y \\\\), с помощью уравнения \\\\( k_{x_i \\oplus y_i} \\oplus k_x \\oplus k_y = 0 \\\\) контролируем выполнение операции. Это одна из логических операций, где для контроля не требуется дублирования аппаратуры."
    },
    {
        "tag": "контроль операции OR",
        "text": "Рассмотрим выполнение и контроль \\\\( x_i \\lor y_i \\\\). Здесь используются следующие эквивалентности: \\\\((x_i \\oplus y_i) \\lor (x_i \\land y_i) = (x_i \\oplus y_i) \\oplus (x_i \\land y_i) = k_x \\oplus k_y\\\\).\\\\n\\\\nА \\\\( y_i \\\\) = \\\\( (x_i \\lor y_i) \\\\). Подавая сигналы по двум шинам \\\\( B \\\\) и \\\\( C \\\\), получаем на выходе \\\\( P_i = x_i \\land y_i \\\\) и \\\\( k_p = k_{x_i \\land y_i} \\\\) и на выходах \\\\[S_i = (x_i \\oplus y_i) \\lor (x_i \\land y_i) = x_i \\lor y_i \\quad \\text{и} \\quad k_S = k_{x_i \\lor y_i}.\\\\]\\nКонтроль операции осуществляется по следующему соотношению: \\\\[k_{x_i \\lor y_i} = k_x \\oplus k_y \\oplus k_{x_i \\land y_i}.\\\\]"
    },
    {
        "tag": "схемы получения контрольного кода (свертка по модулю 2)",
        "text": "- **Схемы получения контрольного кода и оценка времени выполнения контроля.** В практике ЭВМ схемы получения контрольного кода называются схемами свертки по модулю 2. Логика работы этих схем определяется уравнениями (7-1) и (7-2). В арифметических устройствах параллельного и параллельно-последовательного действия применяются другие схемы сверток. Работа последовательной схема свертки для параллельного кода иллюстрируется схемой, изображенной на рис. 7-8. Здесь код\\\\n\\\\[\\\\n\\\\begin{array}{ccc} &  &  \\\\ \\text{Рис. 7-8. Схема последовательной свертки параллельного кода по модулю 2} & \\text{Рис. 7-9. Два варианта реализации схем по модулю 2} \\\\ \\end{array}\\\\n\\\\]\\n\\\\n\\\\( n \\)-разрядного регистра как бы управляет последовательно соединенными схемами, на выходе которых отрабатываются сигналы \\\\[a_n = x_{n+1} = \\sum_{i=1}^n x_i \\log_2 (\\text{код четности}) \\quad \\bar{a}_n = x_{n+1} = \\sum_{i=1}^n x_i \\log_2 (\\text{код нечетности}).\\\\]\\nНа каждый разряд регистра (за исключением первых двух) используется одна схема М2. Логика работы этих схем определяется следующим образом. Коды четности и нечетности первых двух разрядов"
    }
],
[{"tag":"выражение XOR через AND и OR","text":"\\[x_1 \\oplus x_2 = x_1 \\land \\bar{x}_2 \\lor \\bar{x}_1 \\land x_2 = a_2;\\] \\[x_1 \\oplus x_2 = x_1 \\land \\bar{x}_2 \\lor \\bar{x}_1 \\land \\bar{x}_2 = a_2;\\]"},{"tag":"выражение XOR трех разрядов","text":"первых трех разрядов \\[\\begin{aligned} x_1 \\oplus x_2 & \\oplus x_3 = a_2 \\oplus x_3 = a_2 \\land \\bar{x}_3 \\lor \\bar{a"}]]
