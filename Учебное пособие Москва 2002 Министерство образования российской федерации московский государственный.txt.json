[
[{"tag":"","text":"Архитектура, структура и организация вычислительного процесса в ЭВМ типа IBM PC\nУчебное пособие\nМосква 2002 Министерство ОБРАЗОВАНИя РОССИЙСКОЙ ФЕДЕРАЦИИ\nМОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ ИНЖЕНЕРНО-ФИЗИЧЕСКИЙ ИНСТИТУТ (ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ)\nГуров В.В., Ленский О.Д., Соловьев Г.Н., Чуканов В.О. СТРУКТУРА И ОРГАНИЗАЦИЯ ВЫЧИСЛИТЕЛЬНОГО ПРОЦЕССА В ЭВМ\nПод редакцией Г.Н.Соловьева\nУчебное пособие\nМосква   2003 УДК 681.34 5БК\n© Гуров В.В., Ленский О.Д., Соловьев Г.Н., Чуканов В.О. Структура и организация вычислительного процесса в ЭВМ./ Под ред. Г.Н.Соловьева. Уч. пособие. М.: МИФИ,2003. –  108 с."},{"tag":"обзор учебного пособия","text":"В пособии подробно рассмотрены  принципы работы ЭВМ фон-неймановского типа на примере изучения функционирования ЭВМ типа IBM PC. Представлены общие  понятия архитектуры ЭВМ (формат и поля команды, представление данных, режимы адресации операндов), кодирование и декодирование команд"}],
[
    {
        "tag": "принудительный и естественный порядок выполнения команд, счетчик команд",
        "text": "Работа ЭВМ заключается не только в выполнении команд,  но  и  в управлении последовательностью выполнения команд, составляющих программу. Во время выполнения программы команды расположены в ОП. После завершения выполнения  очередной  команды устройство управления (УУ) ЭВМ должно располагать информацией о расположении в ОП следующей команды, то есть о ее адресе. Существуют два подхода к организации порядка следования команд: явное и неявное указание адреса следующей выполняемой команды. ЭВМ, в командах которых явным образом задается адрес  следующей команды, называются ЭВМ с принудительным порядком следования команд. Применение явной адресации следующей команды позволяет располагать команды  программы в оперативной памяти в произвольном порядке. Однако этот способ адресации выполняемых команд ведет к увеличению разрядности  команд.  Этот  подход  не получил распространения в современных ЭВМ. При неявной адресации следующей выполняемой команды все команды программы располагаются последовательно,  занимая одну или несколько ячеек памяти. Поэтому упрощается процедура определения адреса следующей команды.  Зная адрес выполненной команды и  ее размер,  УУ достаточно определить,  сколько  последующих ячеек памяти необходимо пропустить, а затем выбрать следующую команду.  ЭВМ с таким способом расположения программы  в  ОП  называют  ЭВМ с естественным порядком следования команд.  Задача еще более упрощается,  если размеры  всех команд одинаковы, например равны размеру одной ячейки памяти. В этом случае формирование адреса следующей выполняемой команды осуществляется с помощью специального счетчика,  называемого  счетчиком  команд (СК), или программным счетчиком (ПС). Первоначально операционная  система  (ОС) или оператор с пульта ЭВМ заносят в этот счетчик начальный адрес программы, подлежащей выполнению (адрес первой команды программы). Перед выборкой для выполнения очередной команды значение СК автоматически  увеличивается  на постоянную величину,  соответствующую  размеру команды,  например на единицу. Таким образом, СК будет содержать адрес следующей  команды программы. Практика программирования не исчерпывается последовательным выполнением команд.  Часто возникает необходимость в изменении естественного порядка выполнения программы. Это вызовы подпрограмм и возврат из них, организация циклов обработки данных, ветвящиеся алгоритмы. При этом значение СК должно изменяться не естественным  образом, а принудительно заменяться на новое значение.  Для этого служат специальные команды передачи управления (переходов) разных  типов.  Адресная часть  этих  команд содержит адрес или указание о способе его формирования той команды,  которая должна выполняться после текущей. УУ при  распознавании такой команды заменяет содержимое СК на значение адреса следующей команды,  извлеченное или сформированное из содержимого адресной  части команды перехода.  Возможно,  такая замена осуществляется только при выполнении определенных  условий  (команды условных переходов)."
    },
    {
        "tag": "представление данных и организация оперативной памяти",
        "text": "Вся информация в ЭВМ хранится в виде цепочек бит, то есть комбинаций  0  или 1.  Числа ассоциируются с двоичными комбинациями в соответствии с числовыми форматами, а символьный код устанавливает соответствие букв и других символов двоичным комбинациям. Для чисел имеется три числовых формата: • двоичный с фиксированной точкой; • двоичный с плавающей точкой; • двоично-кодированный десятичный (BCD). Форматы с фиксированной и плавающей точкой соответствуют  типам целых  и вещественных чисел в языках программирования высокого уровня. В двоичном  формате с фиксированной точкой числа имеют размер 8 бит (1 байт) или 16 бит (1 слово). Числа могут быть представлены без знака (коды) или со знаком. Для представления чисел со знаком применяется дополнительный код.  Старший бит числа со знаком используется для записи знака числа: 0 - положительное, 1 - отрицательное. Таким образом, целые числа без знака имеют диапозон от 0 до 2^8-1 при  байтовом формате и от 0 до 2^16-1 при формате слова,  а целые со  знаком от -2^7(-2^15) до +(2^7-1) (+(2^15-1)) соответственно. Хотя операции в ЭВМ осуществляются над  двоичными числами,  для записи их в языках программирования и в документации часто используют более удобные восьмиричные, шестнадцатиричные и десятичные эквиваленты. В двоично-кодированном десятичном формате десятичные цифры хранятся  в виде 4‑битных двоичных эквивалентов (код 8421).  Существуют две основные разновидности этого формата: упакованный и неупакованный.  В  упакованном  BCD-формате цепочка десятичных цифр хранится в виде последовательности 4-битных групп. Например, число 3904 - в виде 0011 1001 0000 0100.  В неупакованном BCD-формате каждая десятичная цифра находится в младшей тетраде 8-битной группы (байте), а содержимое старшей тетрады несущественно.  То же число в неупакованном формате будет иметь вид: xxxx0011 xxxx1001 xxxx0000 xxxx0100 . Формат с плавающей точкой,  как и двоичный удлиненного  формата, реализован в  арифметическом сопроцессоре и здесь не рассматривается. Среди символьных  кодов  преобладают  код EBCDIC,  используемый фирмой IBM,  и код ASCII, который применяется почти всеми остальными производителями. Для кодирования  символов  в первом используется 8 бит (1 байт),  а во втором - 7 бит,  но восьмой бит используется как признак четности при передаче информации. Таким образом, все символы, включая служебные,  представляются в ЭВМ в виде двоичного числа длиной в 1 байт. Символьные коды  являются основным средством взаимодействия центральной части  ЭВМ  с устройствами ввода-вывода. Последовательность символов, а, следовательно, их  двоичных  эквивалентов, может рассматриваться как связанная цепочка символов. ОП является основной памятью для хранения информации. Она организована как одномерный массив ячеек памяти размером в 1 байт.  Каждый из байтов имеет уникальный 20‑битный физический адрес в диапазоне от 00000 до FFFFF (здесь и далее для записи адресов используется шестнадцатиричная система счисления). Таким образом, размер адресного пространства  ОП составляет 2^20 =1Мбайт. Любые два смежных байта в памяти могут рассматриваться как 16-битовое слово. Младший байт слова имеет меньший адрес, а старший - больший. Так шестнадцатеричное число 1F8A,  занимающее слово, в памяти будет расположено в последовательности 8A,  1F. Адресом слова считается адрес его младшего байта. Поэтому 20‑битовый адрес памяти может рассматриваться и как  адрес байта, и как адрес слова. Команды, байты и слова данных можно размещать по любому адресу, что позволяет  экономить память вследствие ее более полного заполнения. Однако для экономии времени выполнения  программ  целесообразно размещать слова данных в памяти по четным адресам, так как микропроцессор передает такие слова за один цикл работы шины. Слово с четным адресом называется выравненным по границе слов. Невыравненные слова данных с нечетным адресом допустимы, но для их передачи требуется  два цикла шины,  что снижает производительность ЭВМ."
    },
    {
        "tag": "сегментная адресация в IBM PC",
        "text": "Адресное пространство ОП делится на сегменты.  Сегмент состоит из  смежных ячеек ОП и является независимой и отдельно адресуемой единицей памяти, которая в базовой архитектуре IBM PC имеет фиксированную емкость 2^16 = 64К байт. Каждому сегменту назначается начальный (базовый) адрес,  являющийся адресом первого байта сегмента в адресном поле ОП.  Значение физического адреса  складывается из адреса сегмента и смещения ячейки памяти относительно начала сегмента (внутрисегментное смещение). Для хранения значений адреса сегмента и  смещения  используются  16-битовые  слова. Чтобы  получить 20-битовый физический адрес микропроцессор автоматически осуществляет следующие операции. Значение базового адреса сегмента умножается на 16 (сдвиг на  4 разряда влево)  и  суммируется  со значением  смещения  в  сегменте. В результате получается 20-битовое  значение  физического адреса. При  суммировании может возникнуть перенос из старшего бита, который игнорируется. Это приводит к тому, что ОП оказывается как бы организованной по кольцевому принципу. За ячейкой с максимальным адресом FFFFF следует ячейка с адресом 00000. Сегменты физически не привязаны к конкретному адресу ОП, и каждая ячейка памяти может принадлежать одновременно нескольким сегментам,  так как базовый адрес сегмента может определяться любым 16-битовым значением. Сегменты могут быть смежными,  неперекрывающимися, частично или полностью перекрывающимися. Вместе с тем,  в соответствии  с  алгоритмом вычисления физического адреса,  начальные адреса сегментов всегда кратны 16."
    },
    {
        "tag": "структура микропроцессора IBM PC, регистры и флаги",
        "text": "В упрощенном виде структура базовой ЭВМ типа IBM PC включает микропроцессор, состоящий из операционного (исполнительного) устройства, устройства сопряжения с системной шиной (шинный  интерфейс ШИ) и устройства управления (УУ), оперативную память ОП и устройства ввода-вывода (УВВ), к которым относятся также  жесткие и гибкие магнитные диски. Наиболее важные составляющие  микропроцессора представлены на рис.2.3. Операционное устройство  содержит  группу регистров общего назначения (РОН),  арифметическо-логическое устройство (АЛУ) и  регистр флагов, или слово состояния процессора (PSW). АЛУ состоит из комбинационного сумматора, с помощью  которого выполняются арифметические операции, набора комбинационных схем для выполнения логических операций, схем для выполнения операций сдвигов, а также регистров для временного хранения операндов и результата. Восемь 16-битовых  РОН  могут выполнять различные функции.  Регистры AX,  BX, CX, DX, в основном, используются для хранения данных. Все эти регистры допускают раздельное использование их младших байтов AL, BL, CL, DL и старших байтов AH, BH, CH, DH. BX  может служить базовым регистром при вычислении адреса, CX в ряде команд организации циклов выступает в качестве неявного счетчика, а в DX при операциях ввода-вывода хранится адрес порта ввода-вывода. Регистры SP, BP, SI, DI предназначены, главным образом, для хранения адресной информации. При этом SP и BP часто используются в качестве указателей стека и базы, а SI и DI - для хранения индексов и указателей цепочек символов. Поэтому SI и DI могут служить вместе с базовыми регистрами BX и BP для сложной адресации, хотя допускается их самостоятельное применение. 16-битовый регистр флагов F (встречается обозначение PSW) предназначен для фиксации признаков выполнения определенных  операций  и управляющей информации. Значения  флагов  используются микропроцессором при выполнении условных переходов и реализации определенных режимов  работы. Назначение арифметических флагов: CF - флаг переноса; PF - флаг паритета; AF - флаг  вспомогательного переноса; SF - флаг знака; ZF - флаг нуля; OF - флаг  переполнения. Пример: в команде выполняется сложение +0101 0100 0011 1001 0100 0101 0110 1010 1001 1001 1010 0011. В результате установятся следующие значения флагов: SF=1, ZF=0, PF=1, CF=0, AF=1, OF=1. Признаки управления микропроцессором: DF - флаг направления; IF - флаг разрешения прерывания; TF - флаг трассировки."
    },
    {
        "tag": "режимы адресации процессора I80x86",
        "text": "Процессор I80x86 имеет все режимы адресации, общая схема которых была рассмотрена выше. Непосредственная адресация предполагает,  что операнд занимает одно из полей команды и выбирается из оперативной памяти одновременно с ней. При непосредственной адресации операнд может иметь длину 8 или 16 бит (data8, data16). К регистровой памяти допускается лишь прямая регистровая адресация, где в команде указывается номер регистра, содержащего операнд. Адресация оперативной памяти использует сегменты и сегментные регистры. 16‑разрядный адрес, получаемый в блоке формирования адреса операнда, называется эффективным адресом (EA). 20‑разрядный адрес, получаемый сложением EA и умноженного на 16 значения соответствующего сегментного регистра, называется физическим адресом (FA). Эффективный адрес может формироваться различными режимами: прямая, регистровая косвенная, регистровая относительная, базово‑индексная, базово‑индексная с смещением и др. Примеры вычисления адресов: при прямой адресации EA=disp16, FA=EA+(DS)*16; при регистровой косвенной EA=значение регистра (BX, SI, DI); при регистровой относительной EA=(BX)+disp16 и т.д."
    },
    {
        "tag": "форматы команд микропроцессора I80x86",
        "text": "Команда должна содержать всю необходимую информацию о действии процессора, об используемых операндах и месте размещения результата. Длина любой команды в IBM PC кратна байту и составляет от 1 до 6 байт. Формат двухоперандной команды включает код операции (КОП) в первом байте, а второй байт (post‑byte) определяет регистр‑операнд (reg), режим адресации другого операнда (md) и поле r/m. При md=11 второй операнд находится в регистровой памяти. При md=00 и r/m=000‑011 задаётся базово‑индексный режим, при r/m=110 – прямая адресация. При необходимости к post‑byte добавляются байты смещения (disp8, disp16) или непосредственного операнда (dataL, dataH). Признаки d и w в первом байте указывают, куда помещать результат и длину операндов соответственно. Признак s в командах с непосредственным операндом определяет, как интерпретировать его (расширение знаком). Специальные форматы команд включают однобайтовые команды без операндов (например PUSHF, WAIT) и однооперандные команды (например INC R). Таблица 3.3 содержит машинные коды типовых команд: ADD, SUB, AND, OR, XOR, MOV, CMP, INC, DEC, TEST, XCHG, JMP и условные переходы (JZ, JNZ, JL, JG и др.)."
    }
],
[{"tag":"общий формат ассемблерной команды","text":"Будем рассматривать машинное представление команды  на  примере  операции сложения: S=a+b.  При этом символами обозначим местоположение  операндов и приемника результата. Так как в системе команд IBM PC результат операции записывается  на место первого операнда, то данная операция будет иметь вид: a=a+b. Рассмотрим выполнение такой команды при различных режимах адресации a и b. Для наглядного представления команды будем пользоваться ее  символической записью, приближенной к записи на языке Ассемблер.  Общий формат ассемблерной команды имеет следующий вид: Метка: Мнемоника Операнд,Операнд; Комментарий Метка - это идентификатор,  присваиваемый адресу первого байта команды. Наличие метки в команде необязательно. При отсутствии метки двоеточия быть не должно. Во всех командах необходимо наличие мнемоники, обозначающей выполняемую команду. Наличие и количество (один  или  два) операндов зависит от команды.  В случае двух  операндов они разделяются запятой, при этом первым указывается  операнд-приемник, а вторым - операнд-источник.  Примеры обозначения операндов при различных режимах адресации будут рассмотрены ниже. Поле комментария предназначено для пояснения программы и  может содержать любую комбинацию символов. При отсутствии комментария точка с запятой не ставится."},{"tag":"пример 3.3.1","text":"Пример 3.3.1. Оба операнда  находятся в регистрах общего назначения:  (AX)=a; (CX)=b.  Для обращения к операндам используется  прямая  регистровая  адресация. Символическая запись команды: ADD AX,CX Согласно табл.3.3, машинное представление этой команды имеет вид: 000000dw md reg r/m По условию операнды занимают  полноразрядные регистры, следовательно, необходимо установить w=1. Так как оба операнда располагаются в регистрах общего  назначения, то любой из них можно закодировать в поле reg.  Поэтому команда  может иметь два различных представления в машинном коде: коп  dw  md reg r/m 00000011  11 000 001 b = 03C1h AX CX операнд - слово операнд, заданный в поле reg, - приемник или                коп  dw  md reg r/m 00000001  11 001 000 b = 01C8h AX CX операнд - слово операнд, заданный в поле reg, - источник Здесь и  далее  в записи команд b означает двоичное представление, h - 16-ое. После выполнения  команды в AX будет записана сумма  содержимого AX и CX, а указатель команды IP увеличится на длину  выполненной  команды и будет указывать на следующую команду. Здесь и далее представление  информации  будем  осушествлять  в 16-м виде, если другое не оговорено особо. Если перед  началом  выполнения  команды  (AX)=0C34,  (CX)=1020, (IP)=0012, то после ее выполнения (AX)=1C54, (CX)=1020, (IP)=0014."},{"tag":"пример 3.3.2","text":"Пример 3.3.2. Операнд a  находится  в  AX, b - непосредственный опранд, равный  06B3h. Символическая запись команды: ADD AX,06B3h Машинное представление: коп   sw md коп r/m     data L       data H 10000001 11 000 000 10110011 00000110b = 81C0B306h AX операнд - слово длины операндов равны Если непосредственный операнд имеет величину, которая может быть  закодирована в одном байте, например, 77 (в  десятичной  системе), то при представлении  в дополнительном коде дает 1011 0011b=B3h,то за счет использования признака s удается сократить длину команды: коп  sw  md коп r/m    data L 10000011 11 000 000 10110011b = 81C0B3h AX операнд - слово расширение знаком до 16 разрядов Данное представление команды построено по  общей  схеме  команд суммирования любого регистра с непосредственным операндом. Так как в нашем случае непосредственный операнд суммируется с  регистром-аккумуляторм, то команда  может  быть  записана  в  специальном формате и  иметь меньшую длину: коп     w    data L      data H 00000101 10110011 00000110b = 05B306h для операнда 06B3h. Возможность использования признака s в этом формате отсутствует. Пусть перед  началом  выполнения команды (AX)=03A4,  (IP)=0012. Тогда результатом выполнения команды     ADD AX,06B3h будет:  (AX)=0A57,  (IP)=0016,  а   результатом  выполнения  команды  ADD  AL,B3h  будет:    (AX)=0A57, (IP)=0015. Отметим, что в  последнем  случае  действие  выполняется  лишь с  младшим байтом регистра AX, то есть с регистром AL,  и его  результат не влияет на AH."},{"tag":"пример 3.3.3","text":"Пример 3.3.3. Операнд a  находится  в  AX, операнд b - в оперативной памяти по  прямому адресу 3474h. Символическая запись команды: ADD AX,[3474h] Ее машинное представление: коп    dw md reg r/m      disp L        disp H 00000011 00 000 110  01110100 00110100b = 03067434h AX прямая адресация операнд - слово операнд, заданный в поле reg, - приемник Пусть перед выполнением команды (AX)=1234, [3474]=1A, [3475]=25, (IP)=0012. Напомним, что адрес слова в оперативной памяти - это адрес его младшего байта. Тогда после выполнения команды: (AX)=374E, (IP)=0016."},{"tag":"пример 3.3.4","text":"Пример 3.3.4. Если операнд a находится в оперативной памяти по прямому адресу 3474h, а операнд b представляет собой непосредственный операнд, равный  06B3h, то символическая запись команды имеет вид: ADD [3474h],06B3h а ее машинное представление: коп  sw mdкопr/m  dispL    dispH      dataL    dataH 10000001 00000110 01110100 00110100 10110011 00000110b=81067434B306h прямая адресация операнд - слово длины операндов равны При тех же исходных данных, что и в примере 3.3.3, результатом операции будет: [3474]=CD, [3475]=2B, (IP)=0018."},{"tag":"пример 3.3.5","text":"Пример 3.3.5. Операнд a находится в слове оперативной  памяти, адрес которого  хранится в  регистре  BX, а операнд b - в регистре AX.  В этом случае  адресация операнда a -регистровая косвенная. Символическая запмсь команды: ADD [BX],AX Машинное представление: коп    dw  md reg r/m 00000001  00 000 111 b = 0107h AX косвенная адресация через регистр BX операнд - слово операнд, заданный в поле reg, - источник Если перед выполнением команды (AX)=1234, (BX)=3474, [3474]=D7, [3475]=11, (IP)=0012, то  в результате выполнения команды произойдут следующие изменения: [3474]=0B, [3475]=24, (IP)=0014."},{"tag":"пример 3.3.6","text":"Пример 3.3.6. Операнд a находится в AX. Операнд b является  элементом  массива, первый элемент  которого  помечен  меткой MAS, а положение операнда b в массиве определяется содержимым регистра BX (рис.3.12.). Символическая запись команды: ADD AX,MAS[BX] При ассемблировании  программы  метке  ставится  в соответствие  смещение относительно начала сегмента. Таким образом, операнд b будет  определяться в данном случае с помощью регистровой относительной адресации (суммирование значения смещения и содержимого регистра). Пусть начало массива MAS имеет смещение в 3000h бай­тов от начала сегмента DS. Тогда машинный код команды будет иметь вид: ­ коп   dw  md reg r/m      disp L        disp H 00000011 10 000 111 00000000  00110000b = 03870030h AX (BX)+disp16 операнд - слово операнд, заданный в поле reg, - приемник Если перед выполнением команды (AX)=1234, (BX)=0074, [3474]=E6, [3475]=64, (IP)=0102, то результатом будет: (AX)=771A, (IP)=0106. Если начало массива располагается со смещением  70h  байтов  от  начала сегмента DS, то программа Ассемблера сформирует более короткий  машинный код команды: коп   dw  md reg r/m     disp L 000000 11  01 000 111  01110000b = 034770h AX (BX)+disp8 операнд - слово операнд, заданный в поле reg, - приемник Если исходное состояние элементов хранения совпадает с предыдущим, за исключением (BX)=3004, то и результат будет таким же, за исключением (IP)=0105."},{"tag":"пример 3.3.7","text":"Пример 3.3.7. Операнд a находится в регистре AL. Операнд b является элементом  массива, начальный адрес которого находится в регистре BX.  Положение элемента в массиве определяется регистром DI (рис.3.13).  В этом случае обращение к операнду b происходит  посредством  базово-индексной  адресации. Символическая запись команды имеет вид: ADD AL,[BX+DI] Так как первый операнд находится в регистре AL, то он имеет длину 1 байт. Поэтому в машинном представлении команды w=0, и она выглядит следующим образом: коп    dw  md  reg  r/m 000000 10  00 000 001 b = 0201 h AL (BX)+(DI) операнд - байт операнд, заданный в поле reg, - приемник Если до   начала   выполнения   команды  (AX)=25B7,  (BX)=3000, (DI)=0474, [3474]=77,  (IP)=2519, то после ее  выполнения  произойдут следующие изменения:  (AX)=252E,  (IP)=251B. Обратим внимание на то,  что содержимое регистра AL представляет собой младший байт  регистра  AX. Так  как  операция  проводится  над байтами, то перенос в старший  байт регистра AX блокируется."},{"tag":"пример 3.3.8","text":"Пример 3.3.8. Операнд a находится в регистре AH. Операнд b является элементом двумерного массива, первый элемент которого помечен меткой MAS. Длина (в байтах) от начала массива до  начала  строки, в  которой  расположен  операнд, хранится в регистре BX, а в регистре DI хранится количество  байт от начала текущей строки до операнда b (рис.3.14). Символическая запмсь команды: ADD AH,MAS[BX+DI] Машинный код  команды будет зависеть от того, как далеко относительно начала сегмента располагается начало массива  (см. пример  3.3.6). Если это смещение занимает 2 байта и равно, например, 1D25, то машинный код команды имеет вид: коп  dw md reg r/m      disp L       disp H 00000010 10 100 001 00100101 00011101b = 02A1251Dh AH (BX)+(DI)+disp16 операнд - байт операнд, заданный в поле reg, - приемник Если смещение  более короткое и может быть записано в одном байте, например, 2D, то машинное представление команды следующее: коп   dw  md reg r/m      disp L 00000010  01 100 001  0010 1101 b = 02612D h AH (BX)+(DI)+disp8 операнд - байт операнд, заданный в поле reg, - приемник При (AX)=84A3,  [(BX)+(DI)+disp8]=A4, (IP)=0110 результат будет (AX)=283A, (IP)=0114 в первом случае и (IP)=0113 во втором."},{"tag":"пример 3.3.9","text":"Пример 3.3.9. Операнд a находится в  оперативной  памяти  по  прямому  адресу 3474.  Адрес  операнда  b, также находящегося в опе­ра­тивной памяти, содержится в регистре SI. Сложение этих операндов невозможно выполнить одной командой, так как система команд не предусматривает сложения  формата  \"память-память\". Поэтому  одним  из  возможных вариантов решения этого примера может быть: MOV AX,[SI]    ; AX=b ADD [3474h],AX  ; a=a+b Кодирование этих команд проводится по рассмотренным выше правилам."},{"tag":"восстановление символической записи команды","text":"3.4. Восстановление символической записи команды по ее машинному представлению Для специалиста, работающего  с компьютером как на аппа­ратном, так и на  программном уровне,  иногда возникает не­обходимость  идентифицировать  командную  ин­фор­ма­цию, хранящуюся в оперативной памяти, например, в случае программно-аппаратного сбоя, причину и место которого  трудно определить традиционными методами и средствами тестирования  и отладки.  Так как исполняемый модуль прог­раммы хранится в памяти в машинном представлении, то для лучшего понимания действий, выполняемых в данный момент компьютером,  целесообразно преобразовать команду к символическому  виду.  Программы,  выполняющие  такое преобразование, называются дизассемблерами. Рассмотрим несколько примеров подобных преобразований. Для правильной интерпретации  команды необходимо знать положение ее первого байта. В рассматриваемых примерах будем полагать, что оно известно."},{"tag":"пример 3.4.1","text":"Пример 3.4.1. Представить символическую запись команды, имеющей следующую  машинную форму: 0000h. Так как поля команды определяются с точностью до бита, то  необходимо сначала перейти от 16-го к 2-му представлению команды и, исходя из общих принципов кодирования команд, определить назначение всех ее разрядов: коп   dw  md reg r/m 0000 h = 000000 00  00 000 000 b По таблице машинного предствления команд (см. табл.3.3) определим,  что КОП=000000 b соответствует общему формату операции сложения ADD.  Тогда два младших бита первого байта кодируют признаки  d и w,  а второй байт является постбайтом.  Значение полей в постбайте   позволяет   определить, что  операндами  будут  регистр  AL  (reg=000,w=0)  (см. табл. 3.1) и байт памяти, адресуемый с помощью базово-индексной  адресации  через  регистры  BX и SI (md=00, r/m=000) (см. табл.3.2).  Значение d=0  указывает, что регистр AL является операндом-источником. Следовательно, символическая запись команды имеет вид: ADD [BX+SI],AL"},{"tag":"пример 3.4.2","text":"Пример 3.4.2. Представить символическую запись команды, имеющей следующую  машинную форму: 81475D398B h. Переходим к двоичному представлению команды: коп   sw  md коп r/m    disp L         data L         data H 100000 01  01 000 111 01011101  00111001  10001011 Первый байт, согласно таблице машинного представления команд, соответствует команде сложения с непосредственным операндом.  Постбайт в этом случае кодирует местоположение лишь одного  операнда, которое определяется полями md и r/m:  (BX)+disp8 (см. табл.3.2),  а среднее поле постбайта является расширением кода операции. Адресация операнда требует указания в команде 8-разрядного смещения. Оно помещается сразу же за постбайтом.  Остальные байты команды кодируют непосредственный операнд. Значение sw=01 в первом байте команды указывает  на  то, что  непосредственный операнд - 16-разрядный. Учитывая, что при кодировании  в  команде  двухбайтовых  величин сначала записывается их младший байт,  получим следующую символическую запись команды: ADD [BX+5D],8B39h"},{"tag":"пример 3.4.3","text":"Пример 3.4.3. Пусть машинная форма представления команды следующая: 0445 h. Тогда ее двоичный вид: коп   w      data L 0000010 0  0100 0101 b По таблице  машинного представления команд определяем,  что это  команда специального формата,  обеспечивающая суммирование аккумулятора с непосредственным операндом. Так как w=0,  то непосредственный операнд имеет длину 1 байт, а в качестве  аккумулятора  используется младший байт регистра AX,  то есть регистр AL. При этом команда имеет следующий вид: ADD AL,45h"},{"tag":"команды переходов и циклов","text":"3.5. Команды переходов и циклов Изменение естественного  порядка  выполнения  команд  программы    осуществляется с помощью команд передачи управления. К ним относятся    команды переходов, циклов, вызова подпрограммы  и  возврата из нее, а  также некоторые другие. Мы рассмотрим лишь первые две группы команд. В микропроцессорах IBM PC с базовой архитектурой физический адрес  команды определяется  содержимым указателя команд IP и сегментного регистра команд CS. Команды, меняющие значение обоих этих регистров, называются командами межсегментных переходов, а меняющие только значение IP, - командами внутрисегментных переходов. Команды безусловных переходов  производят модификацию регистра IP или регистров IP и CS  без предварительного анализа каких-либо условий. Существует пять команд безусловных переходов.  Все  они  имеют   одинаковую мнемонику JMP и содержат один операнд.  Конкретный формат  команды определяется соответствующим префиксом и представлен в общей  таблице машинного  представления команд (см.  табл.3.3).  Рассмотрим  действие этих команд подробнее. При безусловном внутрисегментном прямом переходе  новое значение IP равно сумме 8- или 16-разрядного смещения и текущего значения IP. В качестве  текущего значения IP используется адрес команды, записанной вслед за командой перехода.  Схема выполнения операции представлена на  рис.3.15, где  предполагается, что перед вычислением адреса  перехода содержимое IP уже указывает на команду, следующую за  командой перехода. Команда, имеющая 8-разрядное смещение, называется командой короткого перехода и имеет в символической записи после мнемоники команды  префикс short.  Смещение записывается в дополнительном коде, который  перед сложением с текущим значением IP расширяется знаком до 16 разрядов. Таким образом, диапазон адресов переходов для ко­манды короткого перехода составляет -128...+127 байтов относительно текущего значения IP."},{"tag":"пример 3.5.1","text":"Пример 3.5.1. Команда JMP short L  осуществляет  передачу  управления  команде, помеченной меткой L. Пусть эта команда перехода записана по адресу 010A.  Тогда если  метке L  соответствует, например, адрес 011A, то смещение в команде перехода будет равно: 011A-(010A+2)=011A-010C=011A+FEF4=0E Здесь операция вычитания заменена  сложением  с  использованием  дополнительного кода  отрицательного числа.  Перенос за пределы разрядной сетки в операциях, связанных с вычислением смещения, игнорируется. Машинное представление команды следующее: коп            disp 11101011  00001110 b = EB0E h Обратим внимание на то, что в качестве текущего значения IP взят адрес команды перехода, увеличенный на 2, так как длина самой команды перехода"}],
[{"tag":"пример программы","text":"Пример программы\\nТаблица 3.5 Символическая запись\\tКоммен-тарий IP\\tМашинное представление 2-й код\\t16-й код\\nMOV  CX,[31A4h;\\tCX = l\\t0100\\t10001011 00001110 10100100 00110001\\t8B 0E A4 31\\nSUB  AX,AX;\\tS = 0\\t0104\\t00101001 11000000\\t29 C0\\nMOV  SI,AX;\\ti = 0\\t0106\\t10001011 11110000\\t8B F0\\nCYC: ADD AX,[SI+3116h;\\tS = S+a[i]\\t0108\\t00000011 10000100 10100110 00110001\\t03 84 A6 31\\nADD  SI,2;\\ti = i+1\\t010C\\t10000011 11000110 00000010\\t83 C6 02\\nDEC  CX;\\tl = l+1\\t010F\\t01001001\\t49\\nJNZ  CYC;\\tперейти, если l = 0\\t0110\\t01110101 11110110\\t75 F6\\nMOV  [3000h],AX;\\tSUM = S\\t0112\\t10100001 00000000 00110000\\tA1 00 30"},"{\"tag\":\"оценка времени выполнения программ\",\"text\":\"ОЦЕНКА ВРЕМЕНИ ВЫПОЛНЕНИЯ ПРОГРАММ\\n\\nВремя выполнения  программы  складывается  из времен выполнения каждой команды программы. Время выполнения команды можно определить,  умножая  число тактов синхронизации,  необходимых для выполнения команды,  на длительность такта. Это время можно выразить в виде суммы  базового времени выполнения (которое зависит от команды и режима адресации) и времени вычисления эффективного адреса,  если  выбирается  операнд из памяти.  Базовое время предполагает,  что выполняемая команда уже выбрана из памяти и находится в очереди команд.  В противном случае требуется учесть длительность  дополнительных тактов синхронизации,  необходимых для выборки команды. Базовые времена выполнения некоторых команд приведены в табл. 4.1. Время вычисления эффективного адреса (ЕА) зависит от режима адресации (табл. 4.2). Последний столбец в табл. 4.1 показывает число обращений к памяти,  необходимых для выполнения команды. Чтобы определить время выполнения команды,  следует учесть выравнивание операнда,  то есть его расположение в оперативной памяти.  Обращение к однобайтному операнду не требует дополнительных тактов  синхронизации.  Время  обращения к   слову памяти зависит от его адреса.  Если слово имеет нечетный адрес, то его передача из оперативной памяти занимает 2 цикла шины, длящихся  по  4 такта синхронизации каждый.  Следовательно,  каждое обращение к слову с нечетным адресом требует 4 дополнительных тактов синхронизации. Если при вычислении физического адреса производится замена сегментного регистра (вместо заданного по умолчанию используется другой, определенный префиксом замены),  то время выполнения команды  увеличивается на 2 такта. Базовое время  выполнения  некоторых  команд  зависит также от  значения операндов.  Типичными примерами этого Базовые времена выполнения некоторых команд       Таблица 4.1 Команды\\tАдресация\\tЧисло тактов\\tЧисло обращений к памяти\\nADD,SUB, AND,OR\\tRR RS SR RI, AI SI\\t3 9+EA 16+EA 4 16+EA\\t0 1 2 0 2\\nMOV\\tSA,AS RR RS SR RI SI\\t10 2 8+EA 9+EA 4 10+EA\\t1 0 1 0 1\\nMUL\\tмн-ль 8 бит –R мн-ль 16 бит –R мн-ль 8 бит –S мн-ль 16 бит -S\\t70…77 118…133 (76…83)+EA (124…139)+EA\\t0 0 1\\nCMP\\tRR RS, SR RI, AI SI\\t3 9+EA 4 10+EA\\t0 1 0 1\\nINC,DEC\\t16 бит – R 8 бит – R S\\t2 3 15+EA\\t0 0 2\\nУсловные переходы, кроме JCXZ\\tнет перехода есть переход\\t4 16\\t0 0\\nLOOP\\tнет перехода есть переход\\t5 17\\t0 0\\nJMP\\tкороткий внутрисегментный прямой косвеный регистровый межсегментный прямой косвеный\\t15\\n\\n15 18+EA 11\\n15 24+EA\\t0\\n\\n0 1 0\\n\\n0 2\\n\\nПримечание: R - адресация к регистру; A - к аккумулятору; S - к памяти; I - непосредственная адресация\\n\\nВремя вычисления эффективного адреса                   Таблица 4.2\\n\\nРежим адресации\\tЧисло тактов синхрони­зации для вычисления EA\\nПрямой\\t6\\nКосвенный\\t5\\nОтносительный\\t9\\nБазово-индексный (BP)+(DI) или (BX)+(SI) (BP)+(SI) или (BX)+(DI)\\t7 8\\nОтносительный базово-индексный (BP)+(DI)+disp или (BX)+(SI)+disp (BP)+(SI)+disp или (BX)+(DI)+disp\\t11 12\\n\\nслужат команды умножения,  деления (см. табл. 4.1). Так время выполнения команды умножения,  реализованной по алгоритму умножения дополнительных кодов с пропуском такта суммирования, определяется количеством пар соседних несовпадающих разрядов (01 или 10),  так как при комбинациях 00 или  11 такт суммирования с нулевым слагаемым отсутствует. Поэтому, например, для 8-разрядных операндов максимальное время умножения будет  при значении множителя 01010101, а минимальное при ненулевом множителе 10000000.  То есть в первом случае команда умножения будет выполняться на 7 тактов суммирования дольше, что соответствует табл. 4.1. Для команд условного перехода в табл. 4.1 приведено два  времени:  меньшее соответствует случаю,  когда условие не выполняется и переход не производится,  а большее соответс­твует реализации перехода.  Во  втором  случае  учитывается н­еобходимость нового заполнения  очереди команд и выборки следующей команды. Это же относится и к командам циклов.\\n\\nПример 4.1 ADD ES:[BX],DX Команда формата \"память-регистр\". Базовое время: 16+EA. Время вычисления EA (регистровая косвенная адресация): 5 тактов. Обозначение \"ES:\"  в  символической записи команды показывает, что в процессе формирования физического адреса операнда  происходит замена сегментного регистра.  Вместо используемого по умолчанию при  данном режиме адресации сегментного регистра  DS  используется  регистр ES. Эта операция требует 2 тактов синхронизации. Команда обрабатывает слово. Если слово имеет нечетный адрес, то Т=16+5+2+2*4=31(такт)=3.1(мкс) Если слово имеет четный адрес, то Т=16+5+2=23(такта)=2.3(мкс)\\n\\nПример 4.2 MUL [BX] Умножение без знака содержимого AL на операнд,  адрес которого задан в команде. Операнд находится в памяти. Базовое время: (76...83)+EA. Время вычисления EA (регистровая косвенная адресация): 5 тактов. Т=(76...83)+5 = (81...88)тактов = (8.1...8.8)мкс\\n\\nПример 4.3 JZ MET ; перейти на MET, если \"ноль\" Базовое время: 4 такта, если нет перехода, и 16 тактов, если переход выполняется. Других затрат времени нет. Т=4такта=0.4мкс    перехода нет. Т=16тактов=1.6мкс  переход выполняется.\\n\\nПример 4.4 JMP dword ptr [SI+15] ; межсегментный косвенный переход. Базовое время: 24+EA. Время вычисления EA (регистровая относительная адресация): 9 тактов. Имеются 2 обращения к памяти за новыми значениями IP и CS. Если адрес слова четный, то Т=24+9=33(такта)=3.3(мкс). Если адрес слова нечетный, то Т=24+9+2*4=41(такт)=4.1(мкс).\\n\\nВремя выполнения линейного участка  программы равно сумме времен  выполнения всех команд этого участка. Оценим время выполнения ветвящейся программы  на примере следующей задачи: 5, если A > B; y= 6, если A ≤ B. Ниже представлен текст соответствующей программы в  предположении, что A, B и y - переменные длиной 1 байт, имеющие идентификаторы  MA,  MB и MY соответственно. Здесь и далее полагаем, что используемые адреса в сегменте данных - четные. Рядом с каждой командой указано количество тактов синхронизации, необходимое для ее выполнения  (идентификаторы соответствуют прямому режиму адресации): MOV\\tBL,5\\t; 4 MOV\\tAL,MA\\t; 10 CMP\\tAL,MB\\t; 15 JG\\tOUT\\t; 4/16 INC\\tBL \\t; 3 OUT:\\tMOV\\tMY,BL\\t; 15 Таким образом, если A>B, то программа выполняется за 60 тактов,   в противном случае - за 51 такт. Если оба случая равновероятны, то Тср = (Т1+Т2)/2 = 55.5 (такта). В общем случае для данной программы Тср = 4+10+15+16*Р1+(4+3)*Р2+15=44+16*Р1+7*Р2. где Р1  и Р2 - вероятности перехода в команде JG в случае выполнения и невыполнения условия соответственно (Р1+Р2=1). Если известна  количественная  или  хотя бы качественная оценка соотношения Р1 и Р2,  то можно минимизировать среднее время выполнения данного фрагмента программы. Пусть известно, что A>B при 90% различных исходных данных. Тогда при такой структуре программы : Тср = 44+0.9*16+0.1*7=59.1 (такта). При обратном соотношении, то есть при Р1=0.1: Тср = 44+0.1*16+0.9*7=51.9 (такта). Следовательно, при  Р1=0.1 быстрее будет выполняться программа, меняющая условие перехода: MOV\\tBL,6\\t; 4 MOV\\tAL,MA\\t; 10 CMP\\tAL,MB\\t; 15 JNG\\tOUT\\t; 4/16 DEC\\tBL\\t; 3 OUT:    MOV \\tMY,BL\\t; 15 Она дает  то  же  самое  среднее время выполнения программы при Р1=Р2, но выигрыш при P1>P2 и проигрыш при P1<P2.\\n\\nВ циклических программах  тело цикла выполняется многократно.  В силу этого целесообразно, по возможности, минимизировать этот  участок  программы даже  за счет увеличения времени выполнения подготовительных операций и операций обработки результатов циклического участка. Рассмотрим это положение на следующем примере. Пусть необходимо  вычислить произведение двух целых положительных чисел длиной в слово  (S=M*N), не используя команду умножения.  Предполагаем, что операнды  располагаются в памяти по эффективным адресам, вычисляемым как  [SI+2A] и  [1148h],  а  результат также  не  превышает  одного слова и должен быть записан в  память по адресу [BX+SI]. Предполагаем также, что все адреса в сегменте данных четные. Решать задачу будем по следующей схеме: M*N=M+M+...+M. Рассмотрим несколько возможных вариантов решения.\\n\\nВариант 1. MOV   [BX+SI],0   ; 17 MOV   AX,[1148h]  ; 10 CYCLE:    ADD   [BX+SI],AX  ; 23 DEC   [SI+2A]     ; 24 JNZ   CYCLE       ; 4/16\\n\\nВариант 2. MOV   AX,[1148h]  ; 10 MOV   CX,[SI+2A]  ; 17 SUB   DX,DX       ; 3 CYCLE:    ADD   DX,DX       ; 3 DEC   CX          ; 2 JNZ   CYCLE       ; 4/16 MOV   [BX+SI],DX  ; 16\\n\\nВариант 3. MOV   AX,[1148h]  ; 10 MOV   CX,[SI+2A]  ; 17 SUB   DX,DX       ; 3 CYCLE:    ADD   DX,AX       ; 3 LOOP  CYCLE       ; 15/17 MOV   [BX+SI],DX  ; 16\\n\\nВариант 1 использует минимальное общее количество ко­манд. В варианте 2 обработка идет в регистрах общего на­­значения, но не используется специальная команда цикла, которая использована в варианте 3. Сравнительные характеристики этих вариантов представлены в табл. 4.3.\\n\\nСравнительные характеристики вариантов решения        Таблица 4.3 Вариант\\tКоличество команд\\tДлина программы, (байт)\\tВремя выполнения, (такт)\\n1\\t5\\t14\\t63N+15\\n2\\t7\\t15\\t21N+34\\n3\\t6\\t14\\t20N+34\\n\\nТаким образом,  даже несмотря на  некоторое  увеличение  длины, программа, реализованная в вариантах 2 и 3, при достаточно больших N  выполняется почти втрое быстрее, чем реализованная в варианте 1. Так как  время  выполнения  этих  программ зависит от величины  лишь одного сомножителя,  то в том случае, когда известны относительные величины сомножителей, это время можно минимизировать, используя  в  качестве счетчика наименьший из сомножителей."},{"tag":"взаимодействие устройств ЭВМ","text":"Взаимодействие основных устройств ЭВМ при автоматическом исполнении команды\\n\\nРассмотрим автоматическое выполнение трехадресной команды с прямой адресацией. Выполнение такой команды состоит из следующих этапов. Допустим, в ОЗУ находится программа решаемой задачи. Фрагмент этой программы в виде команды представлен на структурной схеме ЭВМ (рис.5.1) справа. При каждом обращении к ОЗУ выбираются все поля команды. Все команды программы имеют одинаковую длину. Рассмотрим этапы выполнения команды, код которой находится в ОЗУ в ячейке с адресом k+i, этот адрес зафиксирован на счётчике команд (СК). Первый этап - выборка кода выполняемой команды из ОЗУ. Для реализации этого этапа необходимо код (СК) = k+i передать в ОЗУ, обратиться в ячейку ОЗУ с адресом k+i  и код этой ячейки, являющийся кодом этой команды, то есть (k+i) = ОП abc, передать на регистр команд (РК). Соответствующие передачи отражены на схеме рис.5.1. Они отмечены цифрой 1. Это передача кода СК на РА (регистр адреса ОЗУ), передача (k+i) из ОЗУ в РК. На этом этапе после приема кода команды на РК, коммутатор операций (КОП), дешифрируя операционную часть выполняемой команды, определяет тип команды. Если команда не связана с изменением естественного порядка выполнения программы (не выполняются команды безусловного или условного переходов), то реализуется следующая последовательность этапов как продолжение первого. Второй этап - выборка первого операнда – (a). Необходимо код поля адреса первого операнда - a из РК передать в ОЗУ, произвести обращение к ячейке с адресом a в оперативную память и код этой ячейки передать в АЛУ. Соответствующие передачи обозначены на схеме рис.5.1 цифрой 2. Это – передача кода a из РК на РА и передача (a) из ОЗУ в АЛУ. Третий этап - выборка второго операнда – (b). Он аналогичен второму этапу. Соответствующие передачи на схеме рис.5.1 отмечены цифрой 3. Это – передача кода b из РК на РА и передача (b) из ОЗУ в АЛУ. Четвёртый этап - выполнение операции в соответствии с кодом операции команды. Еще в конце первого этапа КОП определил тип выполняемой команды. Этот сигнал коммутирует оборудование блока управления операциями (БУОП) таким образом, что на выход БУОП проходят те сигналы с датчика сигналов (ДС), которые необходимы для автоматического выполнения операций в АЛУ. Соответствующие передачи и взаимодействия блоков обозначены на схеме рис.5.1 цифрой 4. Пятый этап  – обращение к ОЗУ и запись по адресу c результата операции. Здесь код поля c регистра команд передается в ОЗУ на РА. Затем в ячейку ОЗУ с адресом c записывается результат операции, находящийся в АЛУ. Соответствующие передачи обозначены на схеме рис.5.1 цифрой 5. Шестой этап  – формирование адреса ячейки ОП, где находится следующая команда программы. При естественном порядке выполнения программы необходимо изменить код в СК, то есть (СК)ст = (СК)нов. Выполнение этого этапа может совмещаться с выполнением предшествующих этапов, что и реализовано в ряде ЭВМ. На этом заканчивается выполнение команды: в СК сформирован адрес следующей команды k+i+1. Приведённая последовательность этапов повторяется и в дальнейшем для каждой из последующих команд программы, что и обеспечивает её автоматическое выполнение. Если выполняются команды безусловного или условного переходов, то вышеизложенная последовательность этапов выполнения команды нарушается. Допустим, в конце выполнения первого этапа КОП зафиксировал выполнение команды безусловного перехода. Эту ситуацию можно представить так: (k +i) = БП k + j, то есть код выполняемой команды выбран из ячейки с адресом k +i, это команда безусловного перехода, которая должна передать управление на выполнение команды, находящейся по адресу k + j. В данном случае выполнение этапов со второго по четвёртый блокируется, и выполнение команды БП заключается в передаче кода k +i из адресного поля РК в СК. При команде условного перехода нарушение естественного порядка выполнения программы (то есть передача кода k + j в СК) происходит только при выполнении определённого условия. Это условие характеризует результат команды, полученный перед выполнением команды условного перехода. Такое условие может быть, например, отрицательный результат или результат, равный нулю, и т.д. Изменим исходные данные (предпосылки). Рассмотрим автоматическое выполнение команд на ЭВМ со структурой, подобной структуре IBM PC. При таких условиях в состав ЭВМ"}],
[
    {
        "tag": "режимы адресации операнда",
        "text": "В табл.6.2 представлен порядок определения режима адресации операнда в зависимости от кода в пост‑байте. Режимы адресации в расширенной архитектуре указаны в таблице с полями r/m, w=1, w=0 и соответствующими регистрами и формами адресации."
    },
    {
        "tag": "SIB‑байт",
        "text": "Значение r/m=100 показывает, что после постбайта в команде следует SIB‑байт. SIB‑байт удобен для представления сложных структур памяти, для которых обычные возможности постбайта оказываются узкими. В этих случаях значение 100 в поле r/m постбайта сигнализирует о наличии дополнительного байта – SIB. Формат SIB‑байта представлен на рис.6.2: здесь ss – поле масштаба, задающее масштабный множитель согласно табл. 6.3; поле base задает базовые регистры согласно табл. 6.4; поле index задает индексные регистры согласно табл. 6.5."
    },
    {
        "tag": "вычисление эффективного адреса",
        "text": "Эффективный адрес при наличии SIB‑байта вычисляется следующим образом: EA = (base)+(index)*scale+displacement, где (base) – значение базового регистра, (index) – значение индексного регистра, scale – величина масштабного множителя, displacement – значение смещения, закодированного в самой команде."
    },
    {
        "tag": "защищенный режим и сегментация",
        "text": "Оперативная память. При работе микропроцессора в защищённом режиме механизм формирования физического адреса принципиально меняется. Прежде всего, изменяется механизм использования сегментной организации памяти. Сегменты в защищённом режиме могут иметь произвольную длину и располагаться в памяти, начиная с произвольного адреса. Каждый сегмент снабжается рядом атрибутов (базовый адрес, длина, уровень защиты и т.п.), хранящихся в дескрипторе сегмента, который используется блоком управления памятью при формировании физических адресов."
    },
    {
        "tag": "страничный механизм памяти",
        "text": "Помимо изменений в сегментации памяти при работе в защищённом режиме появляется возможность использования так называемого страничного механизма организации памяти. Страница – это раздел памяти фиксированной длины (4K байт). Страничная организация служит основой виртуальной памяти и обеспечивает более эффективное, по сравнению с сегментной, использование памяти. При включённом страничном механизме после сегментного преобразования блок управления памятью проводит ещё страничное преобразование адресов."
    },
    {
        "tag": "многозадачность",
        "text": "Многозадачность. Мультипрограммным режимом работы (многозадачностью) называется способ организации системы, при котором в её памяти одновременно содержатся программы и данные для выполнения нескольких процессов. Операционная система моделирует несколько процессоров, предоставляя каждой задаче \"виртуальный процессор\" и переключая реальный процессор между ними с помощью специальных команд межсегментной передачи управления и прерываний."
    },
    {
        "tag": "защита памяти",
        "text": "Защита. Средства защиты памяти делятся на защиту при управлении памятью и защиту по привилегиям. Управление памятью проверяет превышение эффективным адресом длины сегмента, права доступа (чтение/запись/исполнение) и объединяет защиту сегментов и страниц. Защита по привилегиям определяет уровни (0‑3) и контролирует, какие операции разрешены процессору в текущей задаче."
    },
    {
        "tag": "особенности функционирования расширенной архитектуры",
        "text": "Особенности функционирования. Основные особенности ЭВМ на микропроцессорах расширенной архитектуры обусловлены изменениями в регистровой памяти, формате команд, блоке формирования адреса операнда, сумматорах для получения физических адресов и блоке формирования очереди команд. Главное отличие в режимах адресации – наличие байта SIB, позволяющего реализовать базовую индексную адресацию с отклонением, масштабированием и их комбинациями."
    },
    {
        "tag": "домашнее задание",
        "text": "7. ДОМАШНЕЕ ЗАДАНИЕ. Составить программу, реализующую алгоритм, представленный на рис.7.1. В программе должны быть использованы все возможные режимы адресации операндов в линейных командах (ЛК), а также специальный формат ЛК, использующий аккумулятор. Требуется обработать байтовый и словный операнды, добавить команды CMP или TEST к MOV/XCHG, реализовать оба типа безусловных внутрисегментных переходов (прямой и косвенный) и т.д. Пример выполнения задания дан в таблице 7.1."
    },
    {
        "tag": "контрольные вопросы",
        "text": "Контрольные вопросы и задания. 1) Какое количество операндов может быть задано в команде? 2) Определите все возможные форматы команд для двухадресной ЭВМ... 3) Имеются ли в системе команд IBM PC команды без операндов? 4) Что такое \"эффективный адрес\"? Какова его разрядность? 5) Что такое \"физический адрес\"? Какова его разрядность? Как формируется физический адрес? 6) Перечислите используемые в процессоре IBM PC режимы адресации операндов... 7) Сравните различные режимы адресации... 8) Чем определяется использование того или иного сегментного регистра при формировании физического адреса? Можно ли его изменить? 9) При каком значении сегментного регистра будет сформирован физический адрес 2934Ah... 10) Что такое постбайт? Каково назначение его полей? ... 30) Каковы последовательность этапов и их содержание при автоматическом выполнении команды ADD [BX+disp],AX?"
    },
    {
        "tag": "литература",
        "text": "Список литературы: 1) Казаринов Ю.М., Номоконов В.Н., Подклетнов Г.С. и др. Микропроцессорный комплект К1810: Структура, программирование, применение. 2) Лю Ю-Чжен, Гибсон Г. Микропроцессоры семейства 8086/8088. 3) Орловский Г.В. Введение в архитектуру микропроцессора 80386. 4) Бродин В.Б., Шагурин И.И. Микропроцессор i 486. 5) Григорьев В.Л. Микропроцессоры i486. 6) Гук М. Процессоры Intel: от 8086 до Pentium II."
    }
]]
