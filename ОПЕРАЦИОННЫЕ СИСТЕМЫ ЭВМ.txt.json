[
[
  {
    "tag": "bibliographic data",
    "text": "f. H. Соловьев, В. Д. Никитин\\n\\nОПЕРАЦИОННЫЕ СИСТЕМЫ ЭВМ\\n\\nДопущено Государственным комитетом СССР по народному образованию в качестве учебного пособия для студентов высших учебных заведений, обучающихся по специальностям «Электронные вычислительные машины, системы, комплексы и сети», «Автоматизированные системы обработки информации и управления»\\n\\nScan Pirat\\n\\nВВ Москва «Высшая школа» 1989\\n\\nБ И Б Л Щ У Е Н А МОСКОВ-КОС РАДИОТЕХНИ: 78 г. АКМУЛЬ\\n\\nББК 32.973 С 60 УДК 681.3\\n\\nРецензенты: чл.-кор. АН СССР, проф. Б. А. Бабаян; кафедры «Автоматизированные системы обработки информации и управления» (зав. кафедрой проф. Б. Я. Советов) и «Вычислительная техника» (зав. кафедрой проф. В. Б Смолов) Ленинградского электротехнического института им. В. И Ульянова (Ленина)\\n\\nСоловьев Г. Н., Никитин В. Д. С60 Операционные системы ЭВМ: Учеб. пособие для студентов вузов, обучающихся по спец. «ЭВМ, сист., компл. и сети» и «Автом. сист. обр. инф. и. упр.» — М.: Высш. шк., 1989.— 255 с.: ил.\\n\\nISBN 5-06-000131-8\\n\\nВ книге рассмотрены операционные системы (ОС), различные по назначению, технологии обработки данных и организации вычислительного процесса, изложены причины появления ОС, их характеристики, описаны основные подсистемы ядра ОС мультипрограммной ЭВМ виртуальная память, механизм стековой памяти как средство организации вычислительного процесса, механизм управления процессами\\n\\n|    | 2404090000(4309000000)—262 | 194—89 | ББК 32.973 | |---|---|---|---| |    | 001(01)—89    |    | 6Ф7.3 |\\n\\nISBN 5-06-000131-8 © Издательство «Высшая школа», 1989"
  },
  {
    "tag": "предисловие",
    "text": "ПРЕДИСЛОВИЕ\\n\\nИнформатизация современного общества стала одним из главенствующих факторов успешного развития не только науки, техники и производства, но и социально-экономической структуры самого общества. В СССР принята развернутая программа решения проблемы информатизации. В ее основе лежит перспективный план оснащенности средствами вычислительной техники, программа достижения всеобщей «компьютерной грамотности». Высшая школа призвана готовить специалистов в области вычислительной техники, которые должны стать лидерами в решении задач информатизации, способствовать более быстрому и эффективному решению проблемы.\\n\\nВ каждой вычислительной машине существует программная система, с которой обязан работать любой пользователь. Речь идет об операционной системе (ОС) — предмете изложения данной книги. По определению ГОСТ под ОС понимают систему программ, предназначенную для обеспечения определенного уровня эффективности вычислительной системы за счет автоматизированного управления ее работой и предоставляемых пользователям определенного рода услуг. Одну из особых категорий пользователей составляют специалисты, которых интересуют не только услуги, предоставляемые ОС, но и то, каким образом эти услуги реализуются. Такого рода знания необходимы для успешного проектирования и эксплуатации как ЭВМ, так и автоматизированных систем.\\n\\nВ настоящее время издано большое количество литературы по проблематике ОС. Однако существует потребность издания отдельного пособия, в котором необходимо раскрыть в должной степени аспекты функционирования, проектирования и использования ОС. Такую задачу и поставили перед собой авторы.\\n\\nНесмотря на огромное число различных версий ОС, используемых на практике, можно выделить достаточно стабильный состав инвариантных принципов, заложенных в организацию ОС, блоков и механизмов, из которых системы конструируются и реализуются. Именно такого рода общие принципы и механизмы явились основой изложения материала книги.\\n\\nВ качестве базовых систем, иллюстрирующих отдельные положения, выбраны ОС ЕС ЭВМ, система UNIX ОС МВК «Эльбрус».\\n\\nПредполагается, что читатели книги должны иметь опыт программирования, достаточный для понимания алгоритмов, записанных на подмножестве языка Паскаль.\\n\\nАвторы считают своим приятным долгом выразить благодарность коллективам кафедр «Автоматизированные системы обработки информации и управления» (зав. кафедрой проф. Б. Я. Советов) и «Вычислительная техника» (зав. кафедрой проф. В. Б. Смолов) Ленинградского электротехнического института им. В. И. Ульянова (Ленина), а также чл.-кор. АН СССР, проф. Б. А. Бабаяну, взявшим на себя труд по рецензированию рукописи и сделанным ряд ценных замечаний, способствовавших улучшению содержания книги.\\n\\nОтзывы о книге просим направлять по адресу: 101430, Москва, ГСП-4, Неллиная ул., 29/14, издательство «Высшая школа»."
  },
  {
    "tag": "введение",
    "text": "ВВЕДЕНИЕ\\n\\nСтремительное развитие вычислительной техники в настоящее время во многом обусловлено работами в области математического обеспечения ЭВМ. Неотъемлемой частью каждой ЭВМ стала операционная система (ОС). Она предназначена для организации и управления работой ЭВМ. По сути ОС — это интерфейс между пользователем ЭВМ и ее аппаратной частью. Поэтому необходимо изучение ОС всеми лицами, которые так или иначе работают с ЭВМ и, в частности, будущими специалистами в области разработки ЭВМ и использования их в различных системах управления. Вычислительную технику отличает не только беспрецедентный темп развития, но и множество проблем и противоречий, возникающих при этом. Операционные системы в этом смысле не являются исключением. История развития операционных систем повторила историю развития языков программирования, что привело к негативным последствиям — чрезвычайной разобщенности работ в области создания ОС, появлению огромного числа отдельных ОС и их вариантов. Последнее усложнило работу пользователей ЭВМ. Развитие вычислительной техники предполагает быструю сменяемость различных ЭВМ, а это автоматически предполагает и сменяемость ОС. Пользователям приходится основательно переучиваться, чтобы войти в контакт с ЭВМ. Кроме того, возникают весьма существенные трудности при попытках перенесения программ с одной машины на другую, снабженную другой ОС. Проблему во многом можно решить, если ввести определенный стандарт на операционные системы. Такие работы в настоящее время интенсивно ведутся. Например, операционная система UNIX является наиболее вероятной для признания ее «стандартной ОС». Однако у стандартизации есть скептики и противники. Их аргументы вполне обоснованы: печальный опыт разработки языков программирования, которые позволяли бы делать «все для всех», предостерегает от аналогичных попыток в области операционных систем. В особенно трудном положении находятся студенты. Возникает вопрос: что и как изучать из области ОС? Вопрос этот совсем не простой и носит методологический характер. По сути стоит вопрос: делать ли студента «узкоспециализированным» и поэтому изучать подробно только одну ОС либо давать некоторые общие представления, принципы построения ОС, предполагая дальнейшее развитие специалиста при работе с конкретной системой? Авторы являются сторонниками последнего подхода. При написании книги была сделана попытка вести изложение в некотором «промежуточном варианте», т. е. не слишком абстрактно, но и не слишком детально. Пособие состоит из двух частей. В первой части изложены общие концепции, свойственные большинству ОС, во второй — представлен материал для углубленного изучения рассмотренных в первой части основных механизмов в ОС по управлению ресурсами и процессами. Как отмечалось, материал книги проиллюстрирован в основном тремя операционными системами: ОС ЕС ЭВМ, ОС МВК «Эльбрус» и UNIX. Такой выбор из множества различных ОС, на наш взгляд, вполне оправдан. Операционная система ЕС ЭВМ — это классическая система. Хотя она по принципам построения и относится к «старым», заслуженно критикуется за эклектичность и громоздкость, но знание данной системы, на наш взгляд, необходимо студентам. Не следует забывать, что это одна из тех систем, которая задала концептуальный тон в развитии других более совершенных систем. Система UNIX по большинству свойств является антиподом ОС ЕС ЭВМ. Вместе с тем бурное развитие и внедрение этой системы, создание ОС, подобных UNIX (например, в отечественной практике — система ИНМОС), и, наконец, упомянутое стремление сделать эту ОС «стандартной» обусловили наш выбор. Операционная система МВК «Эльбрус» — наиболее удачная в идеологическом отношении. Она является, с одной стороны, строгой и последовательной в реализации современных принципов и решений, принятых в ОС, а другой — несмотря на свою многофункциональность, достаточно проста для восприятия как ее архитектуры в целом, так и составных частей. Хотя данная система не будет иметь широкого применения, необходимо знать основные элементы этой уникальной отечественной ОС. При написании пособия авторы столкнулись со значительными трудностями из-за отсутствия единой терминологии. По возможности придерживались терминологии, сложившейся в результате развития машин серии IBM и ЕС ЭВМ. В ряде случаев пришлось вводить новые понятия во избежание путаницы, неоднозначности трактовки одних и тех же терминов в разных системах."
  },
  {
    "tag": "",
    "text": "Ч а с т ь І\\n\\nВВЕДЕНИЕ В ОПЕРАЦИОННЫЕ СИСТЕМЫ\\n\\nГ л а в а 1. НАЗНАЧЕНИЕ, ОСНОВНЫЕ ПРИНЦИПЫ ПОСТРОЕНИЯ ОС ЭВМ\\n\\n§ 1.1. Однопрограммные и мультипрограммные системы обработки данных. Развитие операционных систем"
  }
],
[{"tag":"организация обработки программ в вычислительной машине","text":"Работа вычислительной машины во многом напоминает непре- рывное производство. Каждая программа проходит одну и ту же технологическую цепочку обработки: поступает на вход в некото- ром исходном языковом представлении (символьном виде) и скла- дируется в накопителе первого этапа обработки. Первый этап — это трансляция программы, после чего уже в преобразованном виде (объектном представлении) она либо поступает непосредственно на вход следующего этапа обработки — на редактирование, либо вновь складируется для последующей отсроченной обработки. На этапе редактирования происходит «сборка» изделия — устанавли- ваются связи между отдельными комплектующими деталями про- граммы, т. е. программными модулями, если программа имеет мо- дульную структуру или использует некоторые стандартные модули. Полученные в результате редактирования «продукт» — загрузоч- ный модуль либо складируется, либо непосредственно поступает в сферу исполнения загрузочного модуля.\n\nТакая обработка программ на машине идет непрерывно. При- чем она может происходить одновременно на одной или нескольких технологических цепочках, которые работают как автономно, так и в зависимости друг от друга. Чтобы это производство работало ритмично, в соответствии с заданной технологией и выполняло план, требуется соответствующая система управления. Помимо управления непрерывным производством необходимо поставлять исходные данные для исполняемых программ, обеспечивать про- граммы необходимыми ресурсами и учитывать их расход, обеспе- чивать вывод полученных результатов и т. д."},{"tag":"таблица времени выполнения операций","text":"| Операции    | Время выполнения операций, мин.    |\n|---|---|\n| Системы ориентированные    | Пакетная обработка    |\n| на перфокарты    | на МЛ    |\n| I    | II    | III    | IV    |\n| Ввод    | 2,5    | 2,5    | 0,05    | 0,05    |\n| Вывод    | 5    | 5    | ~0,1    | 0,1    |\n| Внутрисистемное управление    | 4,5    | 4,5    | 4,5    | 0,01    |\n| Вычисления    | 13    | 0,26    | 0,26    | 0,26    |\n| Всего на исполнение    | 25    | 12,26    | 4,91    | 0,42    |\n| Процент использования процессора    | 52    | 2,1    | 5,3    | 62,00    |"},{"tag":"системы, ориентированные на перфокарты","text":"**Системы, ориентированные на перфокарты.** Пользователь для решения задачи, выраженной в программной форме, заказывал интервал машинного времени. Перед выходом на машину данные и программа пользователя, представленная в машинных кодах (машины М-20, «Минск-22»), заранее помещались на перфокарты. В назначенное время пользователь входил в машинный зал и регистрировал в специальном машинном журнале время начала работы. Далее с помощью устройства считывания с перфокарт и пульта управления вводил программу и данные в память. Затем, манипулируя клавишами пульта управления, запускал и останавливал свою программу по мере надобности. После получения результатов с устройства печати (если таковые имелись) и истечения отведенного для пользователя времени он регистрировал свой уход с машины. Его сменял другой пользователь и повторял действия в той же последовательности, но, разумеется, со своей программой.\n\nВ каждый момент рабочего времени машина использовалась только для решения одной прикладной программы. Поэтому такой режим работы машины назвали однопрограммным. Бюджет времени на интервале исполнения одной программы пользователя приведен в колонке I табл. 1.1.\n\nЭтот бюджет определен при условии, что операция ввода осуществлялась устройством считывания с перфокарт (ПК). Вводилось 500 записей с 500 ПК со скоростью 200 ПК/мин. По мере ввода процессор никакой работы не выполнял, т. е. простаивал.\n\nВывод результатов работы программы осуществлялся цифровечатающим устройством. Выводилось 750 строк текста результатов со скоростью 150 стр/мин. При выводе процессор также простаивал. Операция внутрисистемного управления выполнялась пользователем и включала в себя действия по регистрации прихода и ухода, действия за пультом машины по управлению программой и внешними устройствами. По мере выполнения этой операции процессор также простаивал. Процессор работал только при операции «Вычисление», когда выполнялись команды программы пользователя. Допустим, что время работы процессора (время вычисления) равнялось 13 мин. В данном случае процессор работал только 52% времени. Машина работала в темпе работы пользователя. Он был хозяином на машине. При этом основная эксплуатационная характеристика ЭВМ — количество выполненных программ в секунду, или пропускная способность ЭВМ (обозначена далее П) определяется прежде всего операциями, выполняемыми медленно действующими устройствами ввода — вывода и операциями, выполняемыми пользователем вручную.\n\nПредположим, что администрацию не удовлетворил полученный бюджет времени из-за малого числа обработанных"}],
[{"tag":"каналы и их функции","text":"Изменилась организация работы ВУ. В состав ЭВМ включены новые устройства — каналы, их несколько. Каждый канал управляет определенным набором ВУ. В состав набора могут входить накопители на магнитных лентах и дисках различных типов. В другой набор ВУ могут входить различные типы устройств ввода — вывода с перфокарт, перфолент; устройства печати; дисплеи. Канал, являясь автономным устройством, обеспечивает выбор и подготовку к обмену, управление выполнением обмена тем или иным ВУ. В силу этих свойств канала обеспечивается его одновременная работа с процессором. Канал, обеспечивая обмен, осуществляет определенную обработку данных, подлежащих обмену: изменение форматов перемещаемых данных, формирование адресов, контроль количества передаваемых байтов и т. д."},{"tag":"сложность реализации каналов","text":"О сложности функций, выполняемых каналом, свидетельствует сложность его реализации. В многопрограммных ЭВМ канал реализуется на специальной аппаратуре, выполняющей функции управления с использованием части ОП, либо на специальном процессоре с памятью и даже на мини- и микроЭВМ."},{"tag":"взаимодействие процессора и канала","text":"Работа процессора и канала взаимосвязана. Процессор прекращает счет программы, если этой программе требуются данные, находящиеся не в оперативной памяти, а на внешнем устройстве. В этом случае выполнение программы прерывается и процессор передает управление одному из каналов по подготовке и выполнению обмена. Пока готовится и выполняется этот обмен (это, например, время \\( t_{A(B-B)} \\) на рис. 1.1, б), процессор приступает к обработке следующей программы. После завершения обмена канал выдает соответствующую информацию процессору."},{"tag":"система управления многопрограммной ЭВМ","text":"Реализация многопрограммного принципа привела к включению в состав ЭВМ отдельной системы управления. Ее назначение обеспечивать одновременную автоматическую работу процессора, оперативной памяти, каналов, внешних устройств. Эта система управления не исключает, а существенно дополняет систему управления процессора, обеспечивающую автоматическое выполнение команд и программы в процессоре."},{"tag":"структура и стоимость многопрограммных ЭВМ","text":"Структура многопрограммной ЭВМ значительно сложнее структуры однопрограммной ЭВМ. Эта сложность проявляется не только в том, что в составе ЭВМ появилось несколько новых устройств, а прежде всего в организации одновременной работы процессора, оперативной памяти, каналов, внешних устройств, осуществляющейся автоматически. Попытки реализовать структуру многопрограммной ЭВМ только на основе использования аппаратных решений приводят к резкому повышению стоимости машин данного класса. Многопрограммные ЭВМ с приемлемой стоимостью состоят из двух частей."},{"tag":"аппаратное и программное обеспечение, размер ОС","text":"Первая часть — аппаратура (процессор, оперативная память, каналы, внешние устройства); вторая часть — операционная система (основная часть системного программного обеспечения ЭВМ, куда кроме ОС входят трансляторы и другие системные программы), обеспечивающая управление многопрограммной ЭВМ. Две части многопрограммной ЭВМ в зарубежной терминологии получили названия: аппаратура — hardware, программное обеспечение, включая ОС, — software, т. е. твердый и мягкий товар. Современные ОС — очень сложный и дорогостоящий программный комплекс. Для ЭВМ общего назначения, например для моделей ЕС ЭВМ средней производительности, ОС содержит до \\(3,5 \\cdot 10^6\\) команд."},{"tag":"компромисс аппаратуры и ОС","text":"Итак, в результате реализации многопрограммной ЭВМ только на основе аппаратуры получается очень дорогая ЭВМ, обладающая, однако, высокой пропускной способностью. Реализация ЭВМ на основе аппаратуры и ОС позволяет получить ЭВМ с приемлемой стоимостью, но с меньшей пропускной способностью. Уменьшение пропускной способности объясняется тем, что на работу системного программного обеспечения необходимо тратить иногда значительный объем машинного времени. Такой компромисс между аппаратурой и ОС в виде системной программы является временным. На существование такого компромисса оказывает влияние развитие интегральной схемотехники с ее постоянным ростом степени интеграции и снижением стоимости. Эта тенденция создает объективные предпосылки реализации все большего количества функций ОС с помощью аппаратуры. Признавая такую постановку вопроса реальной, необходимо отметить, что программная реализация системы управления многопрограммной ЭВМ не только обеспечивает приемлемую стоимость, но и имеет ряд других положительных качеств. Например, программную реализацию операционной системы можно легко развить, модернизовать."},{"tag":"генерация операционных систем","text":"Для операционной системы характерно понятие генерации, т. е. для каждой конкретной системы, которая характеризуется определенными параметрами процессора, оперативной памяти, количеством и типом каналов, режимом работы ЭВМ, а также принимаемыми эксплуатационными требованиями, создается (программно генерируется) своя ОС."},{"tag":"перспективы аппаратной реализации ОС","text":"Достижение таких качеств в аппаратной реализации ОС весьма затруднительно, практически невозможно (аппаратная реализация не \"мягкий\", а \"твердый\" товар). Поэтому в перспективе аппаратная реализация найдет широкое применение для: типовых модулей (программ) ОС, входящих в состав практически любой генерируемой системы; операционных систем специализированных ЭВМ, где исключение затрат времени ЭВМ на выполнение программ ОС имеет принципиальное значение."},{"tag":"пакетный режим и режим разделения времени","text":"Представленная схема работы ЭВМ наиболее типична для ЭВМ третьего поколения. Известным классическим представителем ОС мультипрограммного пакетного режима является ОС ЕС ЭВМ. Но такой режим и соответствующие ему ОС не являются единственными. Так, существует и широко применяется на практике режим разделения времени (PPB) и соответствующая ему организация вычислительного процесса и ОС. Цели пакетного режима и PPB разные. Пакетный режим обеспечивает увеличение пропускной способности и максимальную загрузку процессора и ОП. В этом режиме пользователь не имеет непосредственного доступа к ЭВМ. В режиме разделения времени каждый пользователь (а их много) имеет непосредственный доступ к ЭВМ через свой терминал. Цель этого режима — обслужить каждого пользователя, обеспечив допустимое время реакции ЭВМ на"}],
[
    {
        "tag": "принцип модульности",
        "text": "Рассмотренный принцип модульности положительно проявляется при генерации ОС. Он существенно упрощает настройку ОС на требуемую конфигурацию вычислительной системы."
    },
    {
        "tag": "принцип функциональной избыточности",
        "text": "Принцип функциональной избыточности. Этот принцип учитывает возможность проведения одной и той же работы различными средствами. Например, ОС ЕС ЭВМ обладает функциональной избыточностью при организации пакетной мультипрограммной обработки. Она допускает три альтернативных конфигурации ОС: МFT — ОС, обеспечивающая мультипрограммирование с фиксированным числом задач; МVT — ОС, обеспечивающая мультипрограммирование с переменным числом задач; SVC — ОС, обеспечивающая мультипрограммирование с переменным числом задач на основе использования виртуальной памяти. В этом смысле является избыточной и ОС РАФОС СМ ЭВМ. В ее состав входят пять типов мониторов. Монитор — это управляющая программа ОС. Каждый монитор предполагает свою организацию обработки пользовательских программ и альтернативен другим. Наличие нескольких типов мониторов позволяет пользователям быстро адаптировать ОС к определенной конфигурации машины, обеспечить максимально эффективную загрузку технических средств при решении конкретного класса задач. Можно проиллюстрировать и более узкие сферы использования данного принципа. Например, в той же ОС ЕС ЭВМ система управления данными построена как функционально избыточная с целью достижения универсальности и большей гибкости при работе пользователей с данными. Система имеет несколько методов доступа к данным. Пользователям предоставляется возможность работы с данными с помощью одного или нескольких из них. В МВК «Эльбрус» избыточен способ общения пользователя с ОС при исполнении его программы. Вызов требуемой системной программы из пользовательской программы может быть произведен либо как обыкновенный дистанционный вызов процедуры, либо с помощью выработки сигнала прерывания по инициативе прикладной программы."
    },
    {
        "tag": "принцип по умалчиванию",
        "text": "Принцип «по умалчиванию». Применяется для облегчения организации связей с системой как на стадии генерации, так и при работе с уже готовой ОС. Принцип основан на хранении в системе некоторых базовых описаний структур процессов, модулей, конфигураций оборудования и данных, определяющих прогнозируемые объемы требуемой ОП, времени счета программ и т. д., которые характеризуют пользовательские программы и условия их выполнения. Эту информацию ОС использует в качестве заданной, если пользователь, оператор или администрация забудет или сознательно не конкретизирует ее. В данном случае ОС сама установит соответствующие значения. Конкретные значения этой информации, назначаемые по умолчанию, определяются соглашениями, принимаемыми в вычислительном центре. Эти соглашения определяются как возможностями ЭВМ вычислительного центра, так и характеристиками программ пользователей. При необходимости к «умолчиваемым» параметрам могут быть добавлены новые или изменены имеющиеся. В целом использование принципа позволяет сократить число параметров, устанавливаемых пользователем, когда он общается с системой."
    },
    {
        "tag": "принцип перемещаемости",
        "text": "Принцип перемещаемости. Этот принцип предусматривает построение модулей, исполнение которых не зависит от места расположения в оперативной памяти. Настройка текста модуля в соответствии с его расположением в памяти может осуществляться специальными механизмами либо непосредственно перед исполнением программы, либо по мере ее исполнения. Настройка заключается в определении фактических адресов, используемых в адресных частях команд модуля, и определяется используемым в конкретной машине способом адресации (например, базовая адресация в ЕС ЭВМ), а также алгоритмом распределения оперативной памяти, используемым в составе ОС. Программный модуль, обладающий свойством перемещаемости, может после настройки выполняться в любом месте оперативной памяти. Принцип может быть распространен как на ОС, так и на прикладные программы."
    },
    {
        "tag": "принцип защиты",
        "text": "Принцип защиты. Этот принцип определяет необходимость разработки мер, ограждающих программы и данные пользователей от искажений или нежелательных влияний друг на друга, а также пользователей на ОС и наоборот. Программы должны быть гарантировано защищены как при своем исполнении, так и в режиме хранения. Способы влияния, как умышленных, так и неумышленных, чрезвычайно много. Не все их можно предотвратить чисто техническими средствами. Особенно трудно обеспечить защиту, когда используется разделение ресурсов. Несмотря на сложность используемых механизмов, принцип защиты реализуется в той или иной форме в каждой мультипрограммной ОС. Весьма многочисленны по принципам и формам реализации механизмы защиты данных и текстов программ, находящихся в оперативной памяти. Такие механизмы являются производными алгоритмов распределения памяти, используемых в ОС. Самый совершенный вид защиты такого рода — контекстная защита. Наиболее простая форма такой защиты определяется известным адресным пространством непрерывной области оперативной памяти, куда помещаются программы и данные, относящиеся к одному пользователю. Преднамеренный или непреднамеренный выход за границы этой области запрещен и контролируется при выработке каждого адреса при исполнении программ. Механизмы контроля реализуются аппаратными средствами и основаны на использовании граничных регистров либо ключей памяти. Весьма разнообразны способы защиты долговременно хранимых данных (файлов). Традиционный способ защиты — давать пользователю или группе пользователей некоторый пароль. Способы задания и изменения паролей, идентификации по паролю прав доступа пользователя к файлам весьма разнообразны. Например, над файлом в системе UNIX можно выполнять три типа операций: чтение, запись и выполнение. Это могут потенциально делать владелец файла, группа лиц, куда входит и владелец файла, остальные пользователи. С помощью специальных команд каждому уровню привилегий могут быть поставлены в соответствие требуемые операции над файлом. Пользователь может определять режимы доступа только для тех файлов, которыми он владеет."
    },
    {
        "tag": "двухконтекстность работы процессора",
        "text": "Двухконтекстность работы процессора. В каждый момент времени процессор может исполнять либо программу из состава ОС, либо какую-то прикладную или служебную программу, не входящую в состав ОС. Поскольку в составе ОС реализован централизованный принцип распределения всех ресурсов системы, необходимо гарантировать невозможность непосредственного доступа к любому разделяемому ресурсу со стороны пользовательских и служебных программ. Это осуществляется путем включения в состав команд машины команд, называемых привилегированными, управляющих распределением и использованием ресурсов. При этом запрещается использование привилегированных команд в составе программ пользователей. Они выполняются только в системных программах ОС. Наиболее часто такое решение сопровождается контролем, осуществляемым аппаратными средствами. Всякий раз, когда исполняются пользовательские или служебные программы, процессор переводится в специальный (непривилегированный) режим. Программа может выполнять все команды, кроме привилегированных. При попытке выполнить команду такого рода возникает прерывание и процессор аппаратно переводится в новый режим (привилегированный). В этом режиме работают программы ОС, которые и отрабатывают прежде всего прерывания и поступающие от пользователей запросы на распределение и освобождение ресурсов. При очередном выделении какой-либо пользовательской программе процессора он автоматически устанавливается в непривилегированный режим."
    },
    {
        "tag": "принцип независимости от внешних устройств",
        "text": "Принцип независимости программ от внешних устройств. Этот принцип позволяет одинаково осуществлять операции управления внешними устройствами независимо от их конкретных физических характеристик. Принцип заключается в том, что связь программ с конкретными устройствами производится не на уровне трансляции программы, а в период планирования ее исполнения. Перекомпиляция при работе программы с новым устройством, на котором располагаются данные, не требуется. Например, программе, содержащей операции обработки последовательного набора данных, безразлично на каком носителе эти данные будут располагаться. Смена носителя и данных, размещаемых на них (при неизменности структурных характеристик данных), не несет каких-либо изменений в программу, если в системе реализован принцип независимости. Наиболее последовательно данный принцип реализован в ОС UNIX."
    },
    {
        "tag": "принцип открытой и наращиваемой ОС",
        "text": "Принцип открытой и наращиваемой ОС. Открытая ОС доступ"}],
[{"tag":"порождение процессов","text":"В любой ОС по требованию существующего или существовавшего процесса проводится работа по порождению процессов. Процесс, задающий данное требование, называют *порождающим*, а создаваемый по требованию — *порождённым*. Если порожденный процесс на интервале своего существования в свою очередь выдает требование на порождение другого процесса, то он одновременно становится и порождающим."},{"tag":"траса процесса","text":"При управлении процессами важно обеспечить воспроизводимость результатов работы каждого процесса, учитывать и управлять той ситуацией, которая складывалась при развитии процесса. Например, для пользователя, работающего ежедневно за дисплеем со своей программой, требуется при каждом разовом сеансе получать правильный результат счета за приемлемое время. Поэтому операционная система должна рассматривать результативность работы процесса в более широком смысле. Важен не только результат счета, но и каким образом этот результат достигается. С этих позиций ОС должна быть способна сравнивать процессы по динамическим свойствам. Сравнение можно производить, используя понятие «трасса» — порядок и длительность пребывания процесса в допустимых состояниях на интервале существования."},{"tag":"эквивалентные процессы","text":"Два процесса, которые имеют одинаковый конечный результат обработки одних и тех же исходных данных по одной и той же или даже различным программам на одном и том же или на различных процессорах, называют *эквивалентными*. Трассы эквивалентных процессов в общем случае не совпадают. Если в каждом из эквивалентных процессов обработка данных происходит по одной и той же программе, но трассы при этом в общем случае не совпадают, то такие процессы называют *томедественными*. При совпадении трасс у тождественных процессов их называют *равными*. Во всех остальных случаях процессы всегда различны."},{"tag":"временные отношения процессов","text":"Проблематичность управления процессами заключается в том, что в момент порождения процессов их трассы неизвестны. Кроме того, требуется учитывать, каким образом соотносятся во времени интервалы существования процессов. Если интервалы двух процессов не пересекаются во времени, то такие два процесса называют *последовательными* друг относительно друга. Если на рассматриваемом интервале времени существуют одновременно два процесса, то они на этом интервале являются *параллельными* друг относительно друга. Если на рассматриваемом интервале найдется хотя бы одна точка, в которой существует один процесс, но не существует другой, и хотя бы одна точка, в которой оба процесса существуют одновременно, то такие два процесса называют *комбинированными*."},{"tag":"внутренние и внешние процессы","text":"В операционной системе принято различать процессы не только по времени, но и по месту их развития, т. е. на каком из процессоров исполняется программа процесса. Точкой отсчета принято считать центральный процессор (процессоры), на котором развиваются процессы, называемые *программными* или *внутренними*. Такое название указывает на возможность существования в системе процессов, называемых *внешними*. Это процессы, развитие которых происходит под контролем или управлением ОС на процессорах, отличных от центрального. Ими могут быть, например, процессы ввода — вывода, развивающиеся в канале. Деятельность оператора, который обслуживает машину и общается с ОС, также можно рассматривать как внешний процесс. Более того, деятельность любого пользователя ЭВМ, который в том или ином виде вводит посредством ОС информацию, требуемую для исполнения одной или нескольких программ, можно рассматривать как внешний процесс."},{"tag":"системные и пользовательские процессы","text":"Программные процессы принято делить на системные и пользовательские. При развитии системного процесса исполняется программа из состава операционной системы. При развитии пользовательского процесса исполняется пользовательская (прикладная) программа."},{"tag":"взаимосвязанные и изолированные процессы","text":"Процессы независимо от их вида могут быть взаимосвязанными или изолированными друг от друга. Два процесса являются взаимосвязанными, если между ними поддерживаются с помощью системы управления процессами какого-либо рода связи: функциональные, пространственно-временные, управляющие, информационные и т. д. В противном случае они являются изолированными. Более точно последний вид процессов следовало бы назвать процессами со слабыми связями, так как при отсутствии явных связей они могут быть связаны косвенно и определенным образом влиять на развитие друг друга. Например, процесс ввода информации через селекторный канал с некоторого внешнего устройства может повлиять на темп развития другого внутреннего процесса, никак не связанного с этой вводимой информацией. Внешний процесс в данном случае может изменить состав трассы внутреннего процесса и в результате увеличить интервал его существования."},{"tag":"информационно-независимые, взаимодействующие и конкурирующие процессы","text":"При наличии между процессами управляющей связи устанавливается отношение вида «порождающий — порождаемый», рассмотренное выше. Если два взаимосвязанных процесса при развитии используют совместно некоторые ресурсы, но информационно между собой не связаны, т. е. не обмениваются информацией, то такие процессы называют информационно-независимыми. Связь между такими процессами может быть либо функциональная, либо пространственно-временная. При наличии информационных связей между двумя процессами их называют взаимодействующими, причем схемы, а следовательно, и механизмы установления таких связей могут быть различными. Особенность, во-первых, обусловлена динамикой процессов (т. е. являются ли взаимодействующие процессы последовательными, параллельными или комбинированными); во-вторых, выбранным способом связи (явным, с помощью явного обмена сообщениями между процессами, или неявным, с помощью разделяемых структур данных). Когда необходимо подчеркнуть связь между взаимосвязанными процессами по ресурсам, их называют конкурирующими."},{"tag":"синхронизирующие правила","text":"Управление взаимосвязанными процессами в составе ОС основано на контроле и удовлетворении определенных ограничений, которые накладываются на порядок выполнения таких процессов. Данные ограничения определяют виды отношений, которые допустимы между процессами, и составляют в совокупности синхронизирующие правила."},{"tag":"отношение предшествования","text":"Отношение предшествования. Для двух процессов это отношение означает, что первый процесс должен переходить в активное состояние всегда раньше второго."},{"tag":"классификация процессов","text":"Пр а ц е с о ы\n\nПо принадлежности к ЦП По принадлежности к ВС По генералом-местной практики По результатам личности По данным-местной практики По обязанности\n\nВнутренние С"}],
[
    {
        "tag": "классификационная схема ресурсов в ОС",
        "text": "Рис. 2.3. Классификационная схема ресурсов в ОС\\nданного класса — действий по учету и распределению ресурсов, устранению конфликтов в их использовании и т. п. Объединять ресурсы в тот или иной класс можно по-разному: по одному или другому признаку или их совокупности. Описываемые далее свойства ресурсов и их определения взяты из \\[10, 14, 18, 22, 23, 27, 30, 31\\] и весьма разнятся в терминологическом отношении. Ниже приведено описание одной из возможных классификационных схем свойств ресурсов (рис. 2.3). Рассмотрение этой схемы дано в определенном порядке. Вначале рассмотрены свойства наиболее абстрактные в отношении природы и сути ресурса, дальнейшее рассмотрение более детализировано в отношении реализации и использования этих свойств."
    },
    {
        "tag": "реальность существования ресурсов",
        "text": "Первый классификационный признак — «реальность существования». Он может показаться странным, поскольку касается факта существования ресурса. Факт разделения ресурсов на физические и виртуальные (минные) — самый распространенный и перспективный способ в распределении ресурсов. Под физическим понимают ресурс, который реально существует и при распределении его между пользователями обладает всеми присущими ему физическими характеристиками. Виртуальный ресурс схож многими своими характеристиками с некоторым физическим, но по многим свойствам и отличиям. По сути — это некоторая модель физического ресурса. Виртуальный ресурс не существует в том виде, в котором он проявляет себя пользователю."
    },
    {
        "tag": "виртуализация ресурсов",
        "text": "Свойство виртуализации ресурсов — одной из важнейших при построении систем управления ресурсами. По значимости — это одна из важнейших концепций при построении современных ОС. Предварительно дадим лишь некоторые общие замечания относительно этого свойства. Выделение пользователю виртуального ресурса в известной мере схоже с ситуацией, когда пользователю вместо реального объекта предоставляют его модель. Если пользователь, работая с моделью, получает требуемые для него параметры объекта, то ему безразлично, что ему выделено — модель или объект. Виртуальный ресурс — это своеобразная модель конкретного ресурса. Как модель, он реализуется в некоторой программно-аппаратной форме. В этом смысле виртуальный ресурс существует. Однако виртуальный ресурс может предоставить пользователю при работе с ним не только часть тех свойств, которые присущи объекту моделирования, т. е. физическому ресурсу, но и свойства, которые ему не присущи."
    },
    {
        "tag": "пример шахматной аналогии",
        "text": "Для иллюстрации этого утверждения обратимся к шахматам. Сравним две схемы игры в шахматы. В первой схеме просмейстер дает сеанс одновременной игры десяти шахматистам-второразрядникам. По второй схеме десять просмейстеров играют с десятью шахматистами-второразрядниками. В первом случае каждый второразрядник имеет дело с «виртуальным» просмейстером. Реальный просмейстер распределяет свой интеллект между второразрядниками последовательно, по кругу переходит от доски к доске, делая очередной ход. Такое переключение внимания реального просмейстера от доски к доске никак не отражается на игре второразрядников. Уровень их мастерства гораздо ниже просмейстерского и требует времени на обдумывание очередного хода, соизмеримого с интервалом времени, через которое просмейстер в очередной раз подходит к доске каждого из них. У каждого второразрядника складывалось впечатление непрерывной игры с просмейстером. Гросмейстер в данном случае работает с полной нагрузкой, т. е. его ресурс, рассматриваемый как запас мастерства, был использован в максимальной степени. По второй схеме игра каждого из просмейстеров проходит уже не так интенсивно. Если каждый из десяти просмейстеров играет с единственным противником‑второразрядником, то просмейстеры будут больше отдыхать, чем играть. Ресурс каждого из них будет использован незначительно. В отношении второразрядников первая и вторая схемы практически не различимы. Темп их игры практически совпадает как в первом, так и во втором случае. Итак, эффект игры в шахматы с точки зрения второразрядников, каждый из которых являлся пользователем ресурса гроссмейстера, получился один и тот же. Но какой разной ценой! В первом случае был привлечен только один гроссмейстер (один физический ресурс), во второй ситуации — десять гроссмейстеров, т. е. десять физических ресурсов."
    },
    {
        "tag": "признак возможность расширения свойств (эластичность)",
        "text": "Признак «возможность расширения свойств» характеризует ресурс с точки зрения возможности построения на его основе некоторого виртуального ресурса. Физический ресурс, который допускает «виртуализацию», т. е. воспроизведение и (или) расширение своих свойств, называют элластичным. Неэлластичным или жестким ресурсом называют физический ресурс, который по своим внутренним свойствам не допускает виртуализации. Гроссмейстер относится к разряду элластичных ресурсов, так как на основе использования запаса его мастерства и особой организации его действий каждому второразряднику был предоставлен собственный виртуальный ресурс — непрерывная игра с гроссмейстером. А второразрядник не может быть рассмотрен в качестве кандидата на ведение сеанса одновременной игры с остальными десятью второразрядниками. У него недостаточно внутренних возможностей (мастерства) для предлагаемой организации игры с той же результативностью. Поэтому его можно назвать жестким ресурсом."
    },
    {
        "tag": "признак степень активности",
        "text": "В соответствии с признаком «степень активности» различают активные и пассивные ресурсы. При использовании активного ресурса он способен выполнять действия по отношению к другим ресурсам (или даже в отношении себя самого) или процессам, которые в общем случае приводят к изменению последних. Пассивный ресурс не обладает таким свойством. Над таким объектом можно проводить допустимые для него действия, которые могут привести к изменению его состояния, т. е. к изменению его внутренних или внешних характеристик. Центральный процессор представляет собой пример активного ресурса. Область памяти, выделяемая по требованию, — это пример пассивного ресурса, так как над этой областью можно выполнять операции записи или считывания информации."
    },
    {
        "tag": "признак время существования",
        "text": "Различие ресурсов по признаку «время существования» обусловлено динамикой ресурсов в отношении процессов, использующих их. Если ресурс существует в системе до момента порождения процесса и доступен для использования на всем протяжении интервала существования процесса, то такой ресурс рассматривают как постоянный для данного процесса. Временный ресурс может появляться и (или) уничтожаться в системе динамически в течение времени существования рассматриваемого процесса. Причем создание и уничтожение может проводиться как самим процессом, так и другими процессами — системными или пользовательскими."
    },
    {
        "tag": "признак степень важности",
        "text": "Необходимость различия ресурсов по признаку «степень важности» обусловлена двумя причинами: обеспечение должной работоспособности и увеличение гибкости управления процессами и распределением ресурсов. Для этого различают главные и второстепенные ресурсы. Ресурс является главным по отношению к конкретному процессу, если без его выделения процесс принципиально не может развиваться. К таким ресурсам относятся прежде всего центральный процессор и оперативная память. Ресурсы, которые допускают некое альтернативное развитие процесса, если они не будут выделены, являются второстепенными. Например, для хранения набора данных могут быть использованы МЛ или МД."
    },
    {
        "tag": "разделение ресурсов по стоимости и избыточности",
        "text": "Разделение ресурсов на *дорогие* и *дешевые* связано с реализацией принципа функциональной избыточности при распределении ресурсов. В большинстве случаев цена за использование ресурсов при выполнении процесса является функцией времени. Чаще всего система предлагает разный сервис, т. е. различные условия использования одного и того же ресурса, либо предлагаются альтернативные ресурсы. В обоих случаях перед пользователем стоит задача выбора — получить быстро требуемый ресурс и дорого заплатить за такую услугу либо подождать выделения требуемого ресурса и после его использования заплатить более дешево."
    },
    {
        "tag": "структурный признак ресурсов",
        "text": "Структурный признак устанавливает наличие или отсутствие у ресурса некой структуры. Ресурс является простым, если не содержит составных элементов и рассматривается при распределении как единое целое. Составной ресурс характеризуется некоторой структурой. Он содержит в своем составе ряд однотипных элементов, обладающих, с точки зрения пользователей, одинаковыми характеристиками. При каждом разовом распределении составного ресурса пользователь может получить один или более таких составных элементов."
    },
    {
        "tag": "состояния ресурса",
        "text": "Простой по структуре ресурс может быть либо «занят», когда он выделен для использования какому-либо процессу, либо «свободен». Составной ресурс находится в состоянии «свободен», если ни один из его составных элементов не распределен для использования. Если же все элементы такого ресурса выделены для использования, то он находится в состоянии «занят». Если часть элементов распределена, а остальные (известно какие) нет, то ресурс находится в промежуточном состоянии «частично занят». В любой ОС для каждого вида ресурса имеются, в зависимости от его структурной организации, механизмы учета состояний ресурса и перевода его из состояния в состояние."
    },
    {
        "tag": "действия над ресурсом (запрос‑использование‑освобождение)",
        "text": "При централизованном распределении ресурсов соответствующими механизмами ОС в отношении каждого ресурса предполагается, что процесс‑пользователь выполняет три типа действий: ЗАПРОС, ИСПОЛЬЗОВАНИЕ, ОСВОБОЖДЕНИЕ. При выполнении действия ЗАПРОС в ответ на требование процесса‑пользователя система выделяет ресурс либо отказывает в распределении. Отказ может быть вызван тем, что распределяемый ресурс находится в состоянии «Занят» либо обусловлен какой‑то другой причиной. Выполняется действие ИСПОЛЬЗОВАНИЕ. Действие ОСВОБОЖДЕНИЕ выполняется по требованию процесса и сводится в результате к переводу ресурса в состояние «Свободен»."
    },
    {
        "tag": "воспроизводимый и потребляемый ресурсы",
        "text": "Если при распределении системой ресурса допускается многократное выполнение действий в последовательности ЗАПРОС — ИСПОЛЬЗОВАНИЕ — ОСВОБОЖДЕНИЕ, то такой ресурс называют воспроизводимым. В отношении ресурсов такого рода уместна аналогия с пунктом проката. Всякий ресурс по мере использования неким процессом возвращается в «пункт проката», после чего он доступен для использования его другим процессом. В отношении определенной категории ресурсов правомерно использование действий в следующем порядке: ОСВОБОЖДЕНИЕ — ЗАПРОС — ИСПОЛЬЗОВАНИЕ, после чего ресурс, который в данном случае называют потребляемым, изымается из сферы потребления."
    },
    {
        "tag": "последовательное и параллельное использование ресурсов",
        "text": "Природа ресурса и (или) используемое правило распределения ресурса обусловлены параллельной или последовательной схемой использования распределяемого между несколькими процессами ресурса. Последовательная схема предполагает, что в отношении некоторого ресурса, который называют последовательно используемым, допустимо строго последовательное во времени выполнение цепочек действий «ЗАПРОС — ИСПОЛНЕНИЕ — ОСВОБОЖДЕНИЕ» каждым процессом‑потребителем этого ресурса. Для параллельных процессов такие цепочки действий являются критическими областями и должны выполняться так, чтобы удовлетворять правилу взаимного исключения. Поэтому последовательно используемый ресурс, разделяемый несколькими параллельными процессами, чаще называют критическим ресурсом. Параллельная схема предполагает параллельное, т. е. одновременное, использование одного ресурса, который поэтому называют параллельно используемым более чем одним процессом."
    },
    {
        "tag": "твердые и мягкие ресурсы",
        "text": "По форме реализации различают «твердые» и «мягкие» ресурсы. Под «твердыми» понимают аппаратные компоненты машины, а также человеческие ресурсы. Все остальные виды ресурсов относятся к разряду «мягких». Существенно разным для твердых и мягких ресурсов помимо сложности и стоимости является их подверженность сбойным или отказным ситуациям и последующее восстановление работоспособности."
    }
]"}],
[{"tag":"различие твердых и мягких ресурсов","text":"В отличие от «твердых» «мягкие» ресурсы не могут стать неработоспособными из-за их усталостного отказа. Действительно, любая программа или какой-либо массив информации не может износиться при сколь угодно большом количестве раз их правильного использования. А центральный процессор, например, может выйти из строя через некоторое время его эксплуатации. Большая часть «мягких» ресурсов может быть легко тиражирована, т. е. может быть получено любое число ресурсов-копий с полной идентичностью свойств с ресурсом-оригиналом. В том числе тиражируются и внутренние ошибки или неточности, которые были допущены при построении оригинала «мягкого» ресурса. Если некоторый программный модуль содержит невыявленную ошибку, то и все модули-копии будут содержать эту же ошибку. Поэтому способ замены отказавшего ресурса его функционально-эквивалентной копией для обеспечения работоспособности системы естественная «твердых» ресурсов и неприемлем для «мягких». Следовательно, методы, а соответственно и механизмы восстановления работоспособности этих видов ресурсов должны быть различными. При этом различными являются и механизмы контроля работоспособности."},{"tag":"типы мягких ресурсов","text":"В классе «мягких» ресурсов выделяют два типа — программные и информационные. Деление это достаточно условно."},{"tag":"программные и информационные мягкие ресурсы","text":"Если «мягкий» ресурс допускает копирование и эффект от использования ресурса-оригинала и ресурса-копии идентичен, то такой ресурс называют программным «мягким» ресурсом. В противном случае его следует отнести к информационному типу. Примером «мягких» программных ресурсов могут служить программные модули, все возможные информационные структуры: массивы, файлы, дескрипторы процессов и др."},{"tag":"информационные мягкие ресурсы","text":"«Мягкие» информационные ресурсы либо принципиально не допускают копирования, либо допускают копирование, но оно является функцией времени. Это различного вида потребляемые ресурсы: сообщения, сигналы и пр., сигналы прерывания, запросы к ОС на различного рода услуги, сигналы синхронизации. Такие сообщения и сигналы информационно значимы (доступны и ценны, как ресурс) только в течение некоторого конечного интервала времени."},{"tag":"пример копирования сообщений","text":"Например, если в некоторую ячейку памяти записываются периодически некое сообщения, то возможно копирование конкретного поступившего сообщения от момента записи его в эту ячейку до момента поступления туда нового сообщения. Последующее копирование уже дает другой результат от использования выбранного сообщения."},{"tag":"классификация ресурсов","text":"На рис. 2.3 приведена итоговая схема классификации ресурсов по рассмотренным признакам. Необходимо еще раз подчеркнуть, что эта одна из возможных схем, в которой выделены наиболее общие для различных ОС признаки ресурсов и которая может служить основой построения системы распределения ресурсов. При этом требуется расставить определенные приоритеты среди рассматриваемых признаков. Выделить один, обобщить другие и, возможно, добавить новые при построении конкретной системы."},{"tag":"концепция виртуализации","text":"Построение виртуальных ресурсов, их распределение и использование свойственны любой операционной системе. Концепция виртуальности в той или иной форме реализации развивается и рассматривается в ОС как средство: уменьшения конфликтов при управлении процессами и при распределении ресурсов, облегчения работы пользователя с системой, освобождения пользователя от рутинных процедур (а их большое количество) при обращении его к тем или иным ресурсам. Как было установлено при классификации ресурсов, виртуализация того или иного ресурса достигается на основе использования централизованной схемы распределения ресурсами. При такой организации работы распределителя обеспечиваются две формы «обмана» пользователей на машине: либо пользователь обеспечивается при обслуживании своего процесса ресурсом, который реально не существует или существует, но с ухудшенными характеристиками, либо для нескольких параллельных процессов создается иллюзия одно-временного использования того, что одновременно в реальной системе существовать не может. Подобный «обман» преследует вполне благородные цели — предоставить пользователям ресурсы с характеристиками, в наибольшей степени их устраивающие, и снять ограничение на количество распределяемых ресурсов, что позволит увеличить скорость развития процессов и гибкость по их управлению в том или ином виде мультипрограммной обработки."},{"tag":"история виртуализации магнитных лент","text":"Принято считать, что одна из первых форм реализации виртуального ресурса обеспечивалась не программно-аппаратными средствами в составе ОС, а оператором машины. Имеется в виду следующее. Программы, при работе обращающиеся к магнитной ленте, писались с использованием не физических, а логических адресов лентопротяжек. При запросе от программы оператор монтировал требуемую магнитную ленту на любой свободный магнитофон, а затем с помощью переключателей на коммуникационной панели связывал конкретные физические адреса накопителей с соответствующими логическими адресами. В результате пользователи получали возможность работать с виртуальными магнитофонами. Виртуальность проявлялась в том, что с точки зрения пользователя магнитофонов могло быть любое количество и от пользователя не требовалось знания физических адресов магнитофона. Видимость виртуальности магнитофонов создавал в данном случае оператор."},{"tag":"виртуализация таймера","text":"Распространенным приемом в операционных системах является построение на основе одного интервального таймера произвольного числа виртуальных таймеров, каждый из которых предоставляется, по мнению любого из пользователей, в его монопольное пользование. Такой иллюзии, классифицируемой как «обман второго рода», можно достигнуть за счет использования следующей организации распределителя единственного интервального таймера. Обыкновенный таймер — это устройство, которое может воспринимать значение интервала времени, по истечении которого (с момента подачи на таймер) вырабатывается сигнал прерывания. К распределителю интервального таймера выстраивается очередь запросов от отдельных процессов. Элемент очереди определяет процесс, который ожидает прерывания от таймера, а также время, когда этот сигнал должен возникнуть. Элементы в очереди расположены в порядке возрастания требуемых времен генерирования сигналов прерываний. В этом смысле значение указанного времени можно рассматривать как приоритет процесса на использование ресурса интервального таймера. После очередного прерывания на интервальный таймер устанавливается интервал, равный разности между моментом времени, когда должно произойти следующее прерывание, и временем возникновения текущего прерывания. Установка интервала на таймер, помещение нового элемента в соответствующее место очереди и извлечение элемента при каждом прерывании из очереди происходит средствами соответствующего распределителя интервального таймера."},{"tag":"виртуализация канала","text":"Такой же подход используется при разделении такого дорогого ресурса в машине, как канал. С помощью распределителя реального канала, который чаще всего реализуется аппаратными средствами, осуществляется его мультиплекснование по определенной дисциплине (переключение во времени) среди набора устройств, подсоединенных к каналу. Для каждого такого устройства создается иллюзия использования собственного канала, но не реального, а виртуального. Канал, который разделяется подобным образом, называют *мультиплексным*. Все устройства, работающие через такой канал, не ощущают такого рода обмана. Они работают с номинальными для них скоростями."},{"tag":"виртуализация периферийных устройств","text":"Наиболее часто на практике используют виртуализацию периферийных устройств. Причем проявление виртуальности может быть самым различным. Часто с помощью соответствующих средств на базе реального устройств воспроизводится работа устройства с другими характеристиками. Например, на основе использования определенных алгоритмов управления запоминающим устройством на МД (устройство с прямой выборкой) можно воссоздать в отношении пользователя иллюзию, что он работает не с диском, а с накопителем на магнитной ленте. Именно на основе такого подхода к виртуализации в системе UNIX драйверы различных (по видам доступа) периферийных устройств создают для пользователя видимость, что они работают с устройствами, которые обеспечивают передачу и хранение прямoadресующих блоков данных по 512 байт. Под драйвером здесь и далее понимают специальную управляющую системную программу, предназначенную для управления периферийным устройством конкретного типа."},{"tag":"нуль‑устройство","text":"В этой же системе используют еще один эффект виртуализации. Каждый пользователь имеет возможность получить в свое распоряжение при необходимости так называемое «нулевое устройство». Это устройство реально не существует, а воссоздается видимость его существования соответствующими средствами. При направлении на него данных они поглощаются. Когда происходит чтение с такого устройства, то сразу получают признак «конец файла». Это позволяет при необходимости организовать в процессах псевдоввод или псевдовыход, т. е. выводить данные «в никуда» или осуществлять вывод, ничего не получив. Это может быть полезным при отладке, когда необходимо «заглушить» ввод или вывод некоторых данных."},{"tag":"спиринг","text":"В любой мультипрограммной системе используется та или иная форма процесса обработки входных и выходных данных, названного *спирингом*. Основу такого процесса составляет виртуализация периферийных устройств, которые по типу являются последовательно используемыми ресурсами. Это прежде всего вводное устройство для считывания с перфокарт и выводное печатающее устройство. Число этих устройств в машине ограничено и вместе с тем они активно должны использовать, по сути, каждым из процессов, развивающихся параллельно друг другу. Вводить же и выводить информацию с таких устройств можно только последовательно функционально законченными частями. Поэтому эти устройства ввода — вывода могут стать узким местом при организации параллельного развития процессов, если не предпринять каких-либо мер. Виртуализация устройства считывания с перфокарт и печатающего устройства является наиболее действенной мерой. Каждый процесс или совокупность процессов, составляющая автономную работу, получает при необходимости собственное (виртуальное) устройство ввода или вывода, откуда происходит ввод или вывод требуемой информации без влияния других процессов. Причем в конечном счете данные будут вводиться в определенном порядке с одного реального устройства ввода, а выводиться на печать также на одно устройство печати. При этом на листинге печатающего устройства каждый пользователь получит свои функционально обособленные в поле листинга тексты, а на некоторую смесь произвольно чередующихся строк текстов, выдаваемых из разных процессов."},{"tag":"буферизация ввода‑вывода","text":"Реализация спутника в своей основе достаточно проста. Каждое виртуальное устройство моделируется некоторой областью внешней памяти, как правило дисковой. По смыслу каждая такая область представляет собой буфер между реальным устройством ввода‑вывода и соответствующим процессом. Как правило, входной буфер заполняется данными, читаемыми с реального устройства считывания с перфокарт еще до инициализации соответствующей работы. Выходной буфер накапливает данные по мере выполнения процессом команд вывода. По этим командам данные пересылаются не на печатающее устройство, а в выходной буфер. Однако для соответствующего процесса возникает иллюзия того, что он осуществлял выдачу на реальное устройство. Фактическая передача информации на печатающее устройство производится только после того, как закончится процесс (или совокупность процессов), являющийся поставщиком информации в выходной буфер. При мультипрограммной обработке в системе существует одновременно несколько входных и выходных буферов. Причем их заполнение, моменты готовности использования процессами входных буферов и моменты окончания процессами заполнения выходных буферов постоянно изменяются. Поэтому входные и выходные буферы связывают в соответствующие очереди, которые обслуживаются в определенном порядке."},{"tag":"результаты виртуализации ввода‑вывода","text":"В результате использования виртуализации для организации спутника добиваются весьма ощутимых результатов в работе ОС. Операции ввода‑вывода (виртуальные по своей сути) выполняются быстрее и не задерживают развитие процесса из-за недоступности реального устройства ввода‑вывода. Наконец, можно спланировать и обеспечить равномерную загрузку устройств ввода и печати."},{"tag":"общий пример виртуальных ресурсов","text":"Приведенные примеры иллюстрируют возможность построения и использования виртуальных ресурсов на базе реальных ресурсов. В конечном счете каждый виртуальный ресурс подобного рода моделируется некоторым процессом. Управление таким процессом производится в составе специальной системы, являющейся по смыслу распределителем элластичного ресурса, на базе которого строится один или более виртуальных ресурсов. Для построения виртуальных ресурсов используются дополнительные ресурсы, которые распределяются специальным образом в зависимости от назначения виртуальных ресурсов. Если строится не один, а более виртуальных ресурсов, то в составе распределителя реализуются дисциплины распределения таких ресурсов среди процессов‑пользователей."},{"tag":"виртуальная память","text":"Наиболее характерным представителем виртуального ресурса, построенного на базе элластичного пассивного ресурса, является виртуальная память. Ранее не приводились особенности построения и проявления виртуальности у памяти. Эта задача является одной из важнейших при построении мультипрограммных систем, многоплановая в принципах и формах реализации, поэтому вопросы виртуализации памяти рассмотрены в отдельной главе."},{"tag":"виртуальная машина","text":"Наиболее законченным и естественным проявлением концепции виртуальности является понятие виртуальной машины. По сути любая операционная система, являясь средством распределения ресурсов и организуя по определенным правилам управление процессами на базе скрытой аппаратной части, создает у пользователей видимость виртуальной машины. Степень восприятия характеристик виртуальной машины у пользователей может быть существенно отличной. Некоторые из них видят и используют виртуальную машину как некое устройство, способное воспринимать его программы, написанные на определенном языке программирования, выполнять их и выдавать результаты. При таком языковом представлении пользователя совершенно не интересует структура машины, способы эффективного использования ее частей. Он мыслит и работает с машиной в терминах используемого им языка."},{"tag":"характеристики виртуальной машины","text":"Чаще виртуальная машина, предоставляемая пользователю, воспроизводит архитектуру реальной машины, но архитектурные элементы в таком представлении выступают с новыми или улучшенными характеристиками. Характеристики могут быть произвольными, но чаще всего пользователи желают иметь собственную «идеальную» по архитектурным характеристикам машину в следующем составе: бесконечная по объему память с произвольно выбираемым, наиболее удобным для пользователя способом доступа к объектам, хранимым в памяти; один или несколько процессоров, способных выполнять действия, выражаемые пользователем в терминах некоторых удобных для него языков программирования; произвольное количество внешних устройств с удобным способом доступа и представления информации, передаваемой через эти устройства или хранимой ими без каких-либо ощутимых ограничений на объем информации."},{"tag":"пример виртуальной машины Эльбрус","text":"В качестве примера приведем обобщенные характеристики виртуальной машины, которую может получить любой пользователь на мультипрограммном вычислительном комплексе «Эльбрус» [2, 3, 6]. В состав виртуальной машины входят: 1. Единообразная по логике работы память (виртуальная) практически неограниченного объема. Среднее время доступа соизмеримо со значением этого параметра оперативной памяти. Организация работы с информацией в такой памяти производится в терминах обработки данных — в терминах работы с сегментами данных на уровне выбранного пользователем языка программирования. 2. Произвольное количество процессоров (виртуальных), способных работать параллельно и взаимодействовать во время работы. Способы управления процессорами, в том числе синхронизация и информационные взаимодействия, реализованы и доступны пользователям с уровня используемого языка в терминах управления процессами. 3. Произвольное количество внешних устройств (виртуальных), способных работать с памятью виртуальной машины параллельно или последовательно, асинхронно или синхронно по отношению к работе того или иного виртуального процессора, которые инициируют работу этих устройств. Информация, передаваемая или хранимая на виртуальных устройствах, не ограничена допустимыми размерами. Доступ к такой информации осуществляется на основе либо последовательного, либо прямого способа доступа в терминах системы управления файлами. Предусмотрено расширение информационных структур данных, хранимых на виртуальных устройствах. Каждый пользователь может получить виртуальную машину с указанными свойствами. Причем семейство таких машин реализуется одновременно на единственной аппаратной конфигурации, которая характеризуется фиксированным составом: оперативная память объемом до 4,6 Мбайт.; центральные процессоры — до 10; внешняя память на дисках, барабанах и лентах; процессоры ввода‑вывода — до 4; процессоры передачи данных — до 16."},{"tag":"мониторы как распределители ресурсов","text":"Концепция виртуальности нашла широкое применение при проектировании и реализации операционных систем. Наиболее рационально представить структуру системы в виде определенного набора планировщиков процессов и распределителей ресурсов. Последние часто называют мониторами. В данном случае под монитором понимаем распределитель некоторого ресурса, который может на основании некоторой организации работы обеспечить ту или иную степень виртуальности при распределении элластичного ресурса."},{"tag":"монитор как средство виртуализации","text":"Модуль, реализованный в системе как монитор, является не только средством виртуализации ресурса, скрытого в модуле, но и средством «крупномасштабного программирования». Внесение изменений в организацию распределения ресурса не сопряжено в системе с видимыми затруднениями. Меняться должен только один модуль (его внутреннее содержание) при неизменности интерфейса с ним. Окружающую среду, т. е. процессы, взаимодействующие с модулем, такие изменения никак не затрагивают. Это дает возможность автономно разрабатывать отдельные мониторы в составе ОС и, если это необходимо, достаточно просто вносить при эксплуатации ОС требуемые изменения."},{"tag":"иерархия виртуальных машин","text":"Использование концепции виртуальности положено в основу восходящего метода проектирования и разработки операционных систем. ОС строят как иерархию вложенных друг в друга виртуальных машин. Низшим уровнем иерархии являются аппаратные средства машины. Следующий уровень — программный, который совместно с сопрягаемым нижним уровнем обеспечивает достижение машиной новых свойств. Получается виртуальная машина первого уровня. Далее относительно этой, уже виртуальной машины разрабатывается новый программный слой. В результате получается виртуальная машина второго уровня. Такое последовательное, все большее абстрагирование относительно аппаратной части дает возможность построить виртуальную машину требуемого уровня. Каждый новый уровень при данном способе построения ОС дает возможность расширять функциональные возможности по обработке данных, позволяет достаточно просто организовать доступ к низшим уровням."}]"}],
[{"tag":"иерархический метод уровней абстракции","text":"Первое систематическое использование данного метода на прак- тике было осуществлено при разработке операционной системы THE коллективом под руководством Э. Дейкстры [33]. Использова- ние метода иерархического упорядочения виртуальных машин по- мимо преимуществ, связанных прежде всего с систематичностью проекта, увеличением надежности сложной программной системы, каковой является ОС, уменьшением сроков разработки, привело к довольно существенным проблемам. Основная из них — определе- ние свойств и количества уровней абстракции, определение правил вынесения на каждый уровень необходимых частей ОС. Наиболее последовательно свойства уровней абстракции определены Г. Майерсом [22]. 1. На каждом уровне ничего неизвестно о свойствах (и даже о существовании) более высоких уровней. 2. На каждом уровне ничего неизвестно о внутреннем строении других уровней. 3. Каждый уровень представляет собой группу модулей, неко- торые из которых являются внутренними для уровня, т. е. недо- ступны для других уровней. Имена остальных модулей известны на следующем, более высоком уровне и представляют собой сопря- жение с этим уровнем. 4. Каждый уровень располагает определенными ресурсами и либо скрывает от других уровней, либо предоставляет другим уровням некоторые их абстракции (виртуальные ресурсы). 5. Каждый уровень может обеспечивать некоторую абстракцию данных в системе. 6. Предположения, которые на каждом уровне делаются относительно других уровней, должны быть минимальны. 7. Связь между уровнями ограничена явными аргументами, передаваемыми с одного уровня на другой. Недопустимо совместное использование несколькими уровнями глобальных данных. Желательно полностью исключить использование глобальных данных. Под глобальными понимают данные, которые не описаны в модуле, но доступны для использования. 8. Каждый уровень должен иметь высокую прочность и слабое сцепление с другими уровнями. Всякая функция, выполняемая уровнем абстракции, должна быть представлена единственным входом. Таким образом, концепция виртуальности в современном ее толковании стала одной из ведущих как при построении отдельных механизмов, так и всей операционной системы в целом. Последовательное ее использование является основой в достижении как системной, так и пользовательской эффективности при организации мультипрограммной работы ЭВМ."},{"tag":"взаимодействие пользователя с ЭВМ, задачи и задания","text":"§ 2.4. Средства взаимодействия пользователя с ЭВМ\n\nПредварительно рассмотрим некоторые понятия, принятые, например, в ЕС ЭВМ. Здесь пользователь обращается к ЭВМ для решения своей проблемной задачи не в виде отдельного процесса, а в виде некоторого их объединения. Это объединение имеет определенное функциональное назначение. Такие объединения в разных ЭВМ называются по-разному: в МВК «Эльбрус» — задача, в ЕС ЭВМ — задание. Задание — это основная единица работы ЭВМ, с которой пользователь и обслуживающий персонал обращается к ЭВМ. Задания не зависимы друг от друга. Именно это качество позволяет обрабатывать их в многопрограммном режиме. Задания состоят из отдельных шагов. Шаги задания, как правило, зависимы друг от друга. Каждый шаг связан с выполнением отдельной программы, реализуется в виде одного или нескольких процессов. Пример задания — выполнение программы, написанной на алгоритмическом языке. Здесь шаги задания: компиляция, редактирование и исполнение программы. Для управления работой многопрограммной ЭВМ и планирования процессов в ЭВМ, независимо от того, осуществляет это управление аппаратура или операционная система, необходима определенная информация. К ней относятся: прогнозируемые объемы оперативной памяти и времена обслуживания шагов заданий, при- ..."},"tag":"операторы JCL","text":"В качестве примера рассмотрим основы языка JCL, используемого в ЕС ЭВМ. Язык обладает простой структурой. Он содержит шесть основных операторов (в расширенной версии используется девять операторов). Все операторы имеют формат, состоящий из четырех полей: // имя — операция — операция — комментарий. Между полями один или несколько пробелов. Рассмотрим основные операторы JOB, EXEC, DD:\n\nУВ (задание) — оператор задания, им определяются начало задания; учетный номер; прогнозируемый объем раздела оперативной памяти; предельное время выполнения; класс, приоритет задания. ЕХЕС (сокращенное execution — выполнение) — оператор выполнения шага задания. Он определяет начало шага задания и описывает его. Здесь указывается программа, соответствующая шагу задания, объем оперативной памяти, время выполнения, приоритет шага задания и другая управляющая информация. DD (Data Definition — определение данных"}],
[{"tag":"введение в дисциплины распределения ресурсов","text":"Использование многими процессами того или иного ресурса, который в каждый момент времени может обслуживать лишь один процесс, осуществляется с помощью дисциплин распределения ресурса. Их основой являются:\nдисциплины формирования очередей на ресурсы или совокупность правил, определяющих размещение процессов в очереди;\nдисциплины обслуживания очереди или совокупность правил извлечения одного из процессов очереди с последующим представлением выбранному процессу ресурса для использования."},{"tag":"очередь как элемент диспетчеризации","text":"Основным конструктивным, согласующим элементом при реализации той или иной дисциплины диспетчеризации является очередь, в которую по определенным правилам заносятся и извлекаются запросы."},{"tag":"факторы, влияющие на дисциплину формирования очередей","text":"Определяющее влияние на сущность (содержание) дисциплины формирования очередей оказывают:\nинформация о классах и приоритетах заданий и шагов заданий, информация о необходимости обращения к тем или иным устройствам, массивам данных, зафиксированных в операторах языка управления заданиями;\nсоглашения о приоритете уровней запросов прерывания и прерывающих программ, принимаемых при проектировании, разработке ЭВМ;\nнаборы соглашений, принимаемых в вычислительном центре; используемая дисциплина обслуживания очередей, которая зачастую определяет и дисциплину формирования очереди."},{"tag":"классификация дисциплин формирования очередей (статические и динамические)","text":"Дисциплины формирования очередей разделяются на два класса:\nстатический, где приоритеты назначаются до выполнения пакета заданий; большинство рассмотренных фактов определяет содержание статических дисциплин;\nдинамический, при котором приоритеты определяются в процессе выполнения пакета.\nОба класса широко используются в практике организации вычислительного процесса в ЭВМ."},{"tag":"базовые дисциплины обслуживания очередей","text":"В ЭВМ не только многопрограммных, но и однопрограммных, однопроцессорных, многопроцессорных широко используется ряд дисциплин обслуживания очередей, ставших классическими. Эти дисциплины распределения ресурсов часто называют базовыми. Рассмотрим наиболее часто встречающиеся на практике дисциплины обслуживания [1, 16, 27]."},{"tag":"FIFO (first in first out) дисциплина обслуживания","text":"**Дисциплина обслуживания в порядке поступления.** Первый пришел — первый обслуживается. В литературе эта дисциплина обозначается как FIFO (First in — First out). Самая простая и широко используемая на практике. Условная схема этой дисциплины показана на рис. 2.4, а.\nВсе заявки поступают в конец очереди. Первыми обслуживаются заявки, находящиеся в начале очереди."},{"tag":"LIFO (last in first out) дисциплина обслуживания","text":"**Дисциплина обслуживания в порядке, обратном порядку поступления.** Последняя пришла — первая обслуживается. Обозначается LIFO (Last in — First out). Так же, как и FIFO, проста в реализации и широко используется на практике. Условное обозначение дисциплин на рис. 2.4, б. Данная дисциплина является основой построения стековой памяти."},{"tag":"сравнение FIFO и LIFO, справедливость и время ожидания","text":"Общим для названных дисциплин является простота их реализации и определения «справедливость» в обслуживании всего потока запросов, поступающих в систему. Среднее время ожидания запросов в очереди при некотором установившемся темпе обслуживания и темпе поступления является одинаковым независимо от характеристик процессов-пользователей. Например, если некоторые процессы предполагают длительное использование ресурсов (отрабатываются «длинные» запросы), а"}],
[{"tag":"функции системного ввода","text":"Функции системного ввода: считывание операторов JCL входного пакета заданий, их анализ и формирование управляющих таблиц; создание входных очередей обработки заданий и их шагов; запись входных данных, программ для каждого шага заданий в память прямого доступа; создание основы выходных очередей для выходных наборов данных и системных сообщений."},{"tag":"формирование управляющих таблиц","text":"Во время считывания входного пакета заданий производится анализ операторов JCL и формирование управляющих таблиц. Эта часть работы системного ввода иллюстрируется рис. 3.2. Во время считывания анализируется информация операторов JOB, EXEC и DD каждого задания и каждого его шага и происходит формирование таблиц*. На каждое задание — одна таблица управления заданием (ТУЗ), на каждый шаг задания — одна таблица управления шагом задания (ТУШЗ) и одна или несколько таблиц вода — вывода шага задания (ТВВШЗ). Наряду с указанными таблицами формируется и блок управления набором данных (БУНД). В нем содержится характеристика наборов данных, используемых при выполнении задания. Эти таблицы являются новой формой представления управляющей информации, которая фиксируется на МД."},{"tag":"объединение таблиц в входную очередь","text":"Следующим этапом работы над управляющей информацией является объединение таблиц управления различных заданий во входную очередь (рис. 3.3) и ее размещение на МД. Входная очередь упорядочивается по классам и приоритетам. Значение классов и приоритетов зафиксировано в операторах JCL."},{"tag":"завершение системного ввода","text":"Системный ввод заканчивается, когда с входных устройств поступает сигнал о конце ввода. Окончание системного ввода может быть инициировано оператором командой STOP."},{"tag":"инициатор‑терминатор и режимы мультипрограммирования","text":"Инициатор‑Терминатор. В названии этого системного компонента определены две основные его функции: осуществление подготовки задания к исполнению (фаза инициализации) и выполнение действий по завершению задания (фаза окончания). Перечень выполняемых действий в течение каждой из фаз,"}],
[{"tag":"процесс и дескриптор","text":"Процесс \\- это динамический объект, который может изменять свои состояния и способен по мере своего развития запрашивать, использовать и освобождать ресурсы. Динамика изменений состояний, а также связей с ресурсами обусловливает динамический характер информации, сосредоточенный в дескрипторе любого процесса. В той или иной степени в дескрипторе отражены классификационные признаки процессов. Прежде всего отражены динамически изменяемые связи с другими процессы. Все процессы, находящиеся в текущий момент времени в одном и том же состоянии, объединены через дескрипторы в одну цепочку (\\\"прошивают\\\" через дескрипторы) и образуют списковую структуру. Такой же прием проводят с дескрипторами тех процессов, которые ожидают доступа к одному и тому же ресурсу. В таком случае прошивку, как правило, осуществляют в соответствии с приоритетами на право использовать ресурс. Дескрипторы прошиваются также для отображения \\\"родственных\\\" связей между процессами. Несомненно одна из главенствующих ссылок, хранящихся в дескрипторе, \\- это ссылка на область памяти, в которой будет использоваться программа при нахождении процесса в активном состоянии."},{"tag":"информация в дескрипторе процесса","text":"Таким образом, информацию, которая находится в дескрипторе, можно разделить на несколько групп по функциональному назначению: информация по идентификации содержит уникальное имя процесса для реализации операций управления над процессами как над поименованными объектами; информация о ресурсах содержит информацию о ресурсах, которые затребованы или используются процессом в настоящее время; информация о состоянии процесса содержит информацию о текущем состоянии процесса, позволяющую определить текущее состояние и возможность перехода на следующее. Например, в состояниях, отличных от \\\"активного\\\", хранится информация, являющаяся по смыслу информацией, находящейся в слове состояния программы. Хранится содержимое сохраняемых регистров или ссылки на области, где хранится данная информация. Информация о родственных связях используется для корректного окончания процессов, связанных родственными связями, передачи для совместного или автономного использования некоторых ресурсов, для установления информационных связей. Информация, необходимая для учета и планирования процессов, содержит адресные ссылки на другие процессы в случае, если процесс находится в каких-то очередях, приоритет или место в соответствующей очереди, ссылки на информацию для организации доступа к внешним данным по отношению к процессу, ссылки на средства синхронизации между процессами и т. д. Физическое отображение дескрипторов в каждой ОС производится по-разному. Так, в МВК \\\"Эльбрус\\\" процесс однозначно ассоциируется со стеком \\- памятью, организованной по магазинному принципу. Эта память выделяется процессу по мере его порождения и состоит из двух частей. Собственно стековая часть, исполняющая программу процесса, и \\\"шапка\\\" стека, исполняющая роль дескриптора процесса. В \\\"шапке\\\" сосредоточивается часть информации о процессе. Другая ее часть динамически создается и уничтожается по определенным правилам и находится в стековой части. Особенности построения этих физических представителей процесса в МВК \\\"Эльбрус\\\" подробно приводятся в гл. 5. В ОС UNIX процесс представлен, во-первых, областью данных пользователя, которая в момент существования процесса может быть выделена в оперативной памяти и хранить данные и программу пользователя либо находиться на внешней памяти, если процесс подвергнут свопингу \\- временно вытеснен из оперативной памяти. Во-вторых, процесс представлен дескриптором процесса. Дескрипторы объединены в таблицу процессов. Из каждого дескриптора есть ссылка на таблицу пользователя, которую еще называют контекст процесса. Каждая таблица пользователя \\- это продолжение дескриптора. В этой таблице хранится менее актуальная информация, чем в таблице процессов. Таблицы отличаются еще и тем, что таблица процессов постоянно находится в оперативной памяти в известном месте и размер ее фиксирован, а таблица пользователя требуется системе только в том случае, когда процесс находится в активном состоянии. Поэтому эта таблица, являясь частью области данных процесса, может быть перемещена при необходимости на диск, когда процесс находится в состояниях, отличных от активного. В данной ситуации она становится недоступной для модификации. В таблице пользователя сосредоточена текущая информация, ориентированная в основном на организацию работы процесса с внешними данными (файлами). Это, по сути, программный интерфейс процесса с файловой системой. Некоторые элементы работы этой системы рассмотрены далее. Каждый дескриптор в таблице процессов резервируется при порождении процесса и освобождается при его завершении. Здесь содержится статусная информация о процессе, которая необходима независимо от того, находится ли процесс в оперативной памяти или выгружен (подвержен своимут). В частности, здесь содержатся адресные ссылки на область оперативной памяти, где располагается \\\"образ процесса\\\": данные и программа. Кроме того, здесь содержится адресная ссылка на область внешней памяти, куда вытесняется процесс в результате свопинга. В дескрипторе содержится информация, необходимая для синхронизации процессов. Здесь же содержатся идентификаторы процесса, а также породившего его процесса."},{"tag":"блок управления задачей (TCB) в ОС ЕС ЭВМ","text":"В ОС ЕС ЭВМ функции дескриптора процесса выполняет блок управления задачей (ТСВ \\- Task Control Block). Здесь и далее кроме русского наименования блоков ОС ЕС ЭВМ указываются их английские названия, а также их нотации. Блок ТСВ строится в момент порождения задачи (напомним, что в терминах ОС ЕС так называется отдельный процесс в системе). Этот блок содержит в основном адресные ссылки на другие блоки, содержащие дополнительную информацию о процессе. В частности, отдельными блоками (RB \\- Request Block) описываются динамические вызываемые программные модули при развитии процесса; выделяемые области памяти для процесса (SPQE \\- SubPool Queue Element, т. е. элемент очереди подпулов); CDE \\- Contents Directory Entry, т. е. запись справочника содержимого; управляющие блоки, используемые во время обработки ввода \\- вывода (DEB \\- Data Extent Block, т. е. блок экспентов данных); блоки управления событиями (ECB \\- Event Control Block), используемые для синхронизации. Блоки управления задачами упорядочиваются в очередь к процессору, если они находятся в текущий момент в состоянии готовности (очередь готовности), либо в очередь ожидания, если соответствующие процессы находятся в состоянии ожидания. Упорядочение в очереди готовности проводится в соответствии с диспетчерскими приоритетами, являющимися атрибутом каждой задачи. Кроме того, ТСВ имеют ссылки на соответствующие ТСВ для описания родственных ссылок. Очередь готовности \\- динамичное образование. На нее устанавливается адресная ссылка из так называемой таблицы векторов связей (CVT \\- Communication Vector Table). Она в системе имеет фиксированное месторасположение в оперативной памяти. Таким образом, начиная с CVT, можно провести анализ состояния как всей системы в целом, так и отдельных процессов в ней с необходимой степенью детализации."},{"tag":"функции ядра ОС UNIX","text":"В ОС UNIX функции, аналогичные рассмотренным, выполняет одна из двух секций ядра этой системы. Эта секция по назначению является центральной. Она программно реализована на языке Си. Основные функции, выполняемые секцией: резервирование ресурсов, определение последовательности выполнения процессов, принятие запросов на обслуживание. Как и в ОС ЕС, в составе секции реализуются функции краткосрочного планировщика. Распределение центрального процессора производится также по приоритетной схеме. Причем система берет на себя обязанности динамического изменения приоритетов в зависимости от текущих характеристик управляемых процессов. Определение текущего приоритета основано на оценке отношения времени, которое уже использовано процессом к моменту текущего назначения приоритета, к прогнозируемому (пользователем) общему машинному времени, которое требуется процессу для вычислений. Чем меньше значение подсчитанного отношения, тем большим должен быть приоритет. Поэтому процессы, программы которых были недавно загружены, но работающие с момента загрузки малое время (из-за необходимости, например, ожидания ввода\\-вывода), будут иметь относительно высокий приоритет. Перераспределение приоритетов на основе указанной зависимости происходит детерминированно с дискретностью один раз в секунду. Этот период перепланирования называется квантом мультиплексирования процессора, так как после очередного перераспределения приоритетов производится переключение процессора. Он отдается процессу, имеющему в текущий момент самый высокий приоритет."},{"tag":"механизмы распределения ресурсов","text":"На практике используют централизованную или децентрализованную схему распределения ресурсов. Известны системы, в которых используются одновременно обе эти схемы. Для централизованной схемы характерно построение для каждого отдельного ресурса или определенной их совокупности отдельного распределителя, который чаще называют монитором. Мониторы реализуются в форме некоторого объединения процедур доступа к ресурсам, которые он распределяет процессам\\-потребителям по формализованным запросам. В составе монитора находятся локализованная в них управляющая информация, необходимая для организации такого доступа. Помимо этого монитор содержит механизмы и средства, которые используются при распределении ресурсов с учетом их характерных свойств. Такие механизмы строятся на основе классификационной схемы ресурсов. В состав системы распределения ресурсов входят следующие механизмы: распределения активных ресурсов; распределения пассивных ресурсов; виртуализации ресурсов; создания и уничтожения ресурсов; ранжирования ресурсов, управления тупиковыми ситуациями; функциональной избыточности; учета ресурсов; контроля работоспособности твердых ресурсов, а также средства реконфигурации системы ресурсов; человеко\\-машинные средства общения. Основное назначение монитора \\- реализовать определенную дисциплину распределения ресурса. При этом одновременно реализуются функции по синхронизации процессов, конкурирующих между собой за право захвата ресурсов. Кроме того, осуществляются проверки на допустимость обращений, ведется учет использования ресурса. При децентрализованной схеме распределения процессы захватывают, используют и освобождают ресурсы без услуг специальных распределителей. Распределение осуществляется на основании некоторых соглашений, устанавливаемых между процессами. Как правило, при таком виде доступа процессы могут использовать некоторый набор механизмов и средств, реализованных в системе, для обеспечения корректности и облегчения действий по захвату, использованию и освобождению ресурсов."},{"tag":"задачи стратегии распределения ресурсов","text":"При построении системы распределения ресурсов независимо от выбранной схемы распределения приходится решать ряд общих задач, которые в совокупности составляют стратегию распределения ресурсов в машине. Среди первоочередных следует назвать следующие: выбрать приемлемое правило удовлетворения запросов на каждый из распределяемых ресурсов в системе с целью достижения необходимого эффекта; обосновать и обеспечить необходимую степень динамизма в выделении и освобождении ресурса; определить степень автоматизации процесса распределения ресурсов."},{"tag":"статическое и динамическое распределение ресурсов","text":"В ОС ресурсы распределяются как на статической основе (до момента порождения процесса и являются далее для него постоянными), так и на динамической основе (по мере развития процесса\\-потребителя). Наиболее распространенной является ситуация, когда в момент порождения процесса известна и выделяется лишь часть ресурсов. Другая часть выделяется динамически, по мере развития процесса и является поэтому временной по отношению к процессу\\-потребителю. Динамическое распределение и освобождение ресурсов может происходить как по явным запросам от процессов, так и без явного на то указания, средствами ОС. Первую схему поэтому часто называют динамической по требованию, а вторую \\- динамической эвристической."},{"tag":"активные объекты и автоматизация распределения","text":"Активными объектами, влияющими на процесс распределения, являются: администрация, пользователи и оператор. Администрация регулирует входной поток, устанавливая правила формирования и приоритизации заданий, стремясь к повышению загрузки и пропускной способности машины. Пользователи определяют содержание потока заданий и, в зависимости от их квалификации, могут влиять на процесс распределения ресурсов. Оператор выполняет функции настройки и вмешательства в работу системы, включая монтирование носителей, управление памятью и разрешение тупиковых ситуаций. Степень автоматизации этих функций различается в разных ОС и влияет на гибкость и эффективность распределения ресурсов."},{"tag":"распределение оперативной памяти","text":"В составе любой операционной системы имеется распределитель оперативной памяти, поскольку ни один из процессов не может развиваться без ресурса оперативной памяти. Вместе с тем алгоритмы, по которым происходит распределение памяти, очень разнообразны. Причин для этого много. Выделим лишь некоторые из них. Несмотря на бурное развитие схемотехники, оперативная память до сих пор остается дорогим и часто используемым ресурсом машины. В настоящее время вошли в практику машины средней производительности с объемом памяти в единицы Мбайт. Машины большой производительности обеспечиваются оперативной памятью с объемом уже в десятки Мбайт. Следует ли считать в такой ситуации, что проблема памяти решена? Что ресурс оперативной памяти из разряда остро дефицитных переходит в разряд обыкновенных? Ответы на эти вопросы неоднозначны в отношении разных машин. Для микро\\- и миниЭВМ и персональных ЭВМ вопрос обеспеченности оперативной памятью можно считать частично решенным. Следовательно, операционные системы таких машин должны больше заботиться не об эффективной загрузке оперативной памяти, а о достижении пользовательской эффективности \\- обеспечении удобного доступа к данным, находящимся в оперативной памяти, с приемлемыми временами доступа. Несмотря на существенное увеличение объемов оперативной памяти, снижение стоимости, улучшение временных характеристик, вопрос обеспечения оперативной памятью нельзя считать решенным даже для малых машин. Структура памяти любой машины является многоуровневой. Чаще всего выделяются соответственно уровни регистровой, оперативной и внешней памяти. Следовательно, даже для малых машин при распределении оперативной памяти требуется обеспечить высокую системную эффективность ее использования, что подразумевает использование таких алгоритмов распределения, которые обеспечивали бы высокую степень загрузки оперативной памяти по мере работы машины."},{"tag":"фрагментация памяти и алгоритмы распределения","text":"Другой объект минимизации \\- потери памяти, возможные при использовании любого алгоритма. Наиболее часто это проявляется в том, что в результате длительной работы системы распределения памяти наблюдается явление, называемое фрагментацией. Фрагментация проявляется в том, что в памяти образуется большое число малых по размеру дыр. Каждая дыра слишком мала для удовлетворения в ней запроса. Вместе с тем суммарный размер таких малых дыр может быть достаточно велик и превосходить размер, указываемый при каждом разовом запросе на память. В результате наличия фрагментации на длительном интервале работы машины фактически не используется определенный процент объема оперативной памяти. Если не предпринимать каких-либо мер, то потери от фрагментации являются абсолютными потерями и могут быть весьма ощутимыми. Каждому алгоритму распределения свойственны потери, возникающие из-за фрагментации. Эти потери в различных алгоритмах и различных условиях их использования разные, чем обусловлено большое разнообразие алгоритмов распределения, применяемых на практике."},{"tag":"зональная организация памяти","text":"Внутри зоны память распределяется динамически на уровне краткосрочного планирования. В любой момент времени все пространство оперативной памяти представляет собой чередующуюся последовательность из занятых (распределенных) и свободных (не распределенных в текущий момент) участков памяти. Последние образно называют дыр\\u0430ми. Задача распределения, решаемая на уровнях как долгосрочного, так и краткосрочного планирования, распадается на три взаимосвязанные задачи: учета, выделения, возврата. Учету по определенным правилам подвергаются либо только дыры, либо, более часто, дыры и занятые участки. Решение задачи выделения происходит всякий раз, когда требуется выделить некоторую область памяти для отдельной работы или для процесса в составе работы по запросу на память. В наиболее простых случаях выделение требуемого непрерывного участка памяти происходит из резерва свободной памяти, представленной в некотором порядке совокупностью дыр. По определенным правилам выбирают дыру, в составе которой и выделяется участок памяти требуемого размера. Более сложные алгоритмы распределения предполагают выделение участка памяти даже в том случае, когда из числа имеющихся дыр ни одна не пригодна (мала) для распределения. Тогда распределение может происходить, если это допустимо в системе, за счет некоторого переупорядочения (перемещения) занятых участков и дыр. Цель таких действий \\- получить дыру больших размеров. Возможно выделение памяти непрерывным участком, состоящим из некоторого числа чередующихся и физически смежных дыр и занятых участков. При этом требуется обеспечить сохранность информации, находящейся в занятых участках в распределяемой области, и возможность ее дальнейшего использования. Например, информация из занятого участка может быть переписана на уровень внешней памяти. Если через некоторое время ее опять переписать в то же место оперативной памяти, то для процесса, использующего эту информацию (это может быть часть его программы или какие\\u0442о данные), не произойдет нарушения логики работы. Однако пример иллюстрирует наиболее простой случай. Часто необходимо переписывать информацию с уровня внешней памяти на место, отличное от первоначального. Тогда восстанавливаемый текст должен быть определенным образом настроен на новое место расположения. Предполагается, что он допускает такую настройку и в составе ОС должны быть средства для ее проведения."}]"}],
[{"tag":"статическое выделение зон памяти","text":"Несмотря на большую гибкость, второй способ выделения зон также является статичным, основан на выделении непрерывных участков оперативной памяти, требует участия пользователя в распределении памяти. Пользователь обязан, применяя средства общения с системой, указывать количество требуемой памяти для зоны. Этот способ, несмотря на указанные негативные свойства, весьма прост в реализации и широко применяется на практике. Он используется в ОС ЕС ЭВМ, работающей в режиме MVT."},{"tag":"таблицы выделения и свободных зон","text":"Здесь реализация динамического распределения памяти зонами * для заданий на уровне долгосрочного планирования осуществляется с использованием двух таблиц. В одной таблице отражается информация о выделенных (распределенных) зонах, в другой — о свободных, незанятых зонах (дырах). Каждая таблица состоит из строк (элементов) одинакового формата, приведенного ниже. Он содержит три поля. В поле состояния указывается, распределена зона или свободна (доступна для распределения)."},{"tag":"емкость оперативной памяти и пример таблиц","text":"Допустим, оперативная память имеет емкость 1024К (\\\\( K = 1024 \\\\; \\\\text{байт} \\\\)). На ядро ОС отводится зона с емкостью 312К с начальным адресом, равным 0. В оставшейся части ОП выделены три зоны для заданий 1, 2, 3. Между зонами ОП свободна. Тогда таблицы выделенных и свободных зон для заданий будут иметь следующий вид:"},{"tag":"фрагментация памяти","text":"Допустим, в режиме мультипрограммирования трем новым заданиям необходимо выделить требуемые объемы ОП: заданию 4—24К, заданию 5—128К и заданию 6—256К. Вновь выделяемые зоны показаны на рис. 3.6, б. Допустим, через некоторое время задания 2 и 3 выполнены. Тогда соответствующие зоны будут переведены в свободные, доступные состояния и распределение ОП будет иметь вид, показанный на рис. 3.6, в."},{"tag":"негативный фактор — фрагментация","text":"Изложенное выше иллюстрирует негативный фактор — фрагментацию памяти. Обратимся к рис. 3.7, б и допустим, что после выполнения заданий 2 и 3 требуется выделить заданию 7 раздел памяти емкостью 140К. В соответствии с рассмотренным алгоритмом распределения в выделении заданию 7 требуемой зоны памяти будет отказано, так как ни одна из свободных зон не имеет размера, большего или равного 140К. Такой отказ происходит при наличии свободной памяти общим объемом \\\\( 32 + 128 + 136 = 296 > 140 \\\\)К. Память простаивает, не используется, а запрос на выделение памяти не обслуживается. Такое состояние в системе возникло вследствие появления фрагментации — иссечения памяти на большое число дыр с небольшими размерами."},{"tag":"алгоритмы распределения памяти","text":"На практике используются различные алгоритмы реализации функций распределения памяти под зоны и освобождения зон. В частности, может быть использован ранее рассмотренный алгоритм «самый подходящий» или «первый подходящий». Выбор того или иного алгоритма определит и специфику составления таблиц. При использовании алгоритма «первый подходящий» строки таблицы упорядочивают по начальным адресам зон. При использовании алгоритма «самый подходящий» строки таблиц упорядочиваются по размерам зон."},{"tag":"процедура выделения и освобождения памяти","text":"Независимо от принимаемого алгоритма необходимо выполнение следующих действий: найти свободную область с размером, не меньшим адресного пространства задания; если свободная область имеет больший размер, чем требуемый заданию, то ее нужно поделить на две части, при этом одна часть становится распределенной зоной, вторая — свободной; при освобождении зоны необходимо, если есть возможность, объединять освобождаемую зону с любой смежной свободной областью."},{"tag":"алгоритм первый подходящий (поиск зоны)","text":"Рассмотрим схему алгоритма выделения требуемой зоны по принципу «первый подходящий». Считаем, что строки таблиц упорядочены. Каждая следующая строка описывает свободную область, находящуюся в более старших адресах ОП. Схема алгоритма приведена на рис. 3.7. Здесь поиск требуемой зоны с размером \\\\( N_p \\\\) начинается с первой (\\\( i=1 \\)) свободной области, имеющей самый малый начальный адрес. Аналогично реализуется алгоритм освобождения зоны."},{"tag":"оверлейная структура","text":"Помимо указанных негативных свойств алгоритмов распределения памяти под зоны существенным недостатком является существенное ограничение размера программ и данных, которые можно исполнять и хранить в зоне при исполнении конкретной работы. Если эти размеры превосходят объем зоны, то пользователь должен предварительно искать какие-то способы, чтобы «вместить» эти информационные объекты в отведенное место. Например, строить свою программу в виде так называемой оверлейной структуры. Данная программа по мере ее активизации переносится в зону памяти не полностью, а частями. Эти"}],
[{"tag":"унифицированный интерфейс ввода‑вывода","text":"В любом мультипрограммном режиме, в том числе и в пакетном, подсистема управления вводом — выводом должна обеспечить пользователя удобным и понятным интерфейсом для обращения к периферийным устройствам. При этом наиболее часто выдвигается требование на достижение унифицированного интерфейса для доступа к различным по своим физическим характеристикам периферийным устройствам. Это отвечает принципу независимости от устройств. Состав подсистем управления вводом — выводом, организация и особенности работы у разных машин существенно отличаются, что объясняется отмеченными различиями в аппаратуре ввода — вывода, а также множеством методов, используемых на практике для управления этой аппаратурой. Вместе с тем можно выделить единое концептуальное начало, свойственное всем подсистемам."},{"tag":"внешние процессы и параллелизм","text":"Аппаратуру ввода — вывода можно рассматривать как совокупность аппаратурных процессоров, которые способны работать параллельно относительно друг друга, а также относительно центрального процессора. На таких процессорах, как было отмечено при классификации процессов, развиваются внешние процессы. Например, для периферийного устройства внешний процесс может представлять собой совокупность действий, обеспечивающих перевод каретки, продвижение бумаги на одну строку, смену регистра печати на русский и печать любого заданного числа символов. Внешние процессы, используя аппаратуру ввода — вывода, в состоянии взаимодействовать как между собой, так и с программными процессами, развивающимися на центральном процессоре. Важным при этом является то обстоятельство, что скорости развития внешних и программных процессоров (число действий выполняемых при развитии процесса на процессора в единицу времени) будут существенно различны и могут отличаться на несколько порядков."},{"tag":"прямой метод управления вводом‑выводом","text":"Прямой метод управления основан на наличии непосредственной связи между центральным процессором и периферийным устройством (рис. 3.10, \\( a \\)). На центральный процессор возлагается обязанность непосредственного управления работой устройства. Это предполагает наличие в составе команд процессора специальных команд по инициированию работы устройства, проверке готовности его к работе, останову устройства, записи информации и т. д. Особенностью этих команд является следующее. При попытке обращения к устройству для ввода или вывода информации в случае, если устройство занято выполнением какой-либо ранее заданной операции, выполнение команды процессора блокируется до тех пор, пока устройство не освободится. Часто для предоставления возможности программировать совмещение счета на центральном процессоре и процесса выполнения отдельных операций ввода — вывода на периферийном устройстве в состав системы вводят флажок занятости устройства. Он программно доступен центральному процессору и устанавливается или сбрасывается аппаратно по мере занятости или освобождения устройства. Если флажок в некоторый момент времени находится в установленном состоянии (устройство занято), то процессор можно заставить (запрограммировать) выполнять некоторую счетную работу, а не простаивать в ожидании освобождения устройства. Как при наличии, так и при отсутствии флажка занятости задачи совмещения работы центрального процессора и периферийного устройства полностью возлагаются на программиста. Он должен определенным образом расставить команды обращения к устройству в своей программе, с тем чтобы достигнуть максимального совмещения и, как следствие, минимизировать простой центрального процессора. Управление вводом — выводом при прямом методе управления построено по децентрализованной схеме и требует от программиста хорошего знания особенностей работы конкретного устройства."},{"tag":"косвенный метод управления (канал)","text":"Главный недостаток прямого метода управления вводом — выводом — практическая нереализуемость на его основе режима мультипрограммирования. Этого недостатка лишен метод косвенного ввода — вывода (рис. 3.10, \\( б \\)). Метод основан на том, что между центральным процессором и периферийным устройством помещается специальный процессор, называемый чаще всего каналом, который осуществляет фактическое управление операциями ввода — вывода. Таким образом, с центрального процессора снимаются несвойственные ему функции по управлению периферийными устройствами, доступ к которым теперь косвенный — через канал. Вместе с тем за центральным процессором остаются функции управления, но уже не устройствами, а каналом. Центральный процессор только инициирует ввод — вывод, а затем может выполнять необходимые программы вплоть до момента окончания инициированного процесса ввода — вывода. Фактической передачей данных управляет канал по специальной программе, исполнение которой в канале представляет собой внешний процесс. По мере развития внешнего процесса центральный процессор, канал и адресуемое периферийное устройство работают параллельно."},{"tag":"синхронизация ввода‑вывода: флаги и прерывания","text":"Для синхронизации параллельной работы центрального процессора и канала используют различные средства. Наиболее распространенными являются следующие. Для проверки занятости канала центральному процессу предоставляется флажок занятости канала. Кроме того, ему может быть доступна и более расширенная статусная информация о состоянии канала"}],
[{"tag":"особенности управления вводом-выводом в ОС ЕС ЭВМ","text":"Рассмотрим теперь основные особенности управления вводом—выводом в составе ОС ЕС ЭВМ. В этой операционной системе реализованы более универсальные методы управления вводом—выводом. Степень централизации управления в данной системе значительно выше и реализована в рамках одного супервизора ввода—вывода, который управляет совокупностью каналов и периферийных устройств, подключенных к ним. Основные системные посылки, используемые при построении и работе супервизора ввода—вывода, следующие."},{"tag":"привилегированные команды ввода-вывода и структура CCW","text":"Процессор управляет любым каналом программным способом. Для этого в составе его команд находится четыре привилегированные команды: SIO — запустить ввод—вывод, HIO — остановить ввод—вывод, TIO — проверить ввод—вывод, TCH — проверить канал. В адресной части этих команд указывается требуемый номер канала и номер устройства в канале. Канал в свою очередь управляет периферийными устройствами. Делает это он программным способом. Для реализации такого управления составляется канальная программа. Канальную программу составляет пользователь при его непосредственной работе с каналом. Если работа пользователя с каналом осуществляется опосредованно, через систему управления данными (через метод доступа), то канальная программа составляет автоматически, методом доступа. При этом используется информация, поставляемая пользователем. Эта программа представляет собой последовательность управляющих слов или команд канала (CCW — Channel Command Word). Каждое слово CCW — это команда для использования устройством управления периферийного устройства. Получив такую команду от канала, устройство управления (контроллер) управляет периферийным устройством уже аппаратным способом. В языке ассемблера управляющее слово канала записывается в следующем виде: CCW, A1, A2, A3, A4. Параметр A1 задает код операции обмена. Различают шесть групп операций: запись данных, ввод данных, управление устройством, уточнение состояния, чтение данных в обратном направлении, переход в канале. Каждая группы команд предполагает большое количество модификаций, что позволяет учесть все особенности интерфейса каждого вида периферийного устройства. Параметр A2 определяет адрес начала области памяти откуда (или куда) передаются данные. Параметр A3 задает байт управляющих признаков, необходимых для конструирования канальной программы. Параметр A4 служит для задания длины (количества) передаваемых данных."},{"tag":"канальная программа и адресное слово канала (CAW)","text":"Канальная программа должна храниться в непрерывной области оперативной памяти, начальный адрес которой заносится перед запуском операции ввода—вывода в слово памяти с фиксированным адресом. В этом слове хранится так называемое адресное слово канала (CAW — Channel Address Word). В начале своей работы канал по адресному слову определяет первую команду канальной программы."},{"tag":"коды условий при запуске SIO","text":"При запуске канала по операции SIO вырабатывается нулевой код условия, если канал и устройство свободны. В противном случае вырабатывается код, не равный нулю. Код условия доступен для анализа. После окончания работы периферийное устройство передает в канал информацию о своем состоянии, а канал в свою очередь после завершения ввода—вывода вырабатывает сигнал прерывания. При этом процессору передается слово состояния канала, также записываемое в слово памяти по фиксированному адресу. По содержанию слова состояния канала можно определить результат выполнения операции ввода—вывода, исполняемой по канальной программе, определить состояние канала и устройства."},{"tag":"структура супервизора ввода-вывода (EXCP и прерывания)","text":"Супервизор ввода—вывода — это системная программа, состоящая из двух частей: EXCP-супервизор (EXCP — Execute Channel Program, т. е. выполнить программу канала) и супервизор прерываний ввода—вывода. Первая часть предназначена для приема и обработки запросов на ввод—вывод, поступающих от программных процессов. Этой частью осуществляется проверка готовности канала, управление очередями запросов, инициирование ввода—вывода. Супервизор прерываний предназначен для обработки прерываний по вводу—выводу, поступающих от каналов по мере окончания передачи очередного блока данных. Он анализирует успешность окончания передачи на основе получаемой из канала информации о состоянии устройства, завершившего передачу; планирует при необходимости выполнение программ обработки ошибок ввода—вывода; отмечает успешность выполнения, используя средства синхронизации, в отношении программных процессов, которые заказывали вывод или ввод информации; выбирает из очереди запросов очередной запрос и подготавливает условия для активизации очередной операции ввода—вывода с помощью EXCP-супервизора."},{"tag":"подготовка к вызову EXCP и блок IOB","text":"Прежде чем обратиться к EXCP-супервизору с запросом на ввод—вывод, программный процесс обязан выполнить ряд подготовительных действий. Это прежде всего действия, связанные с составлением канальной программы, размещением ее в определенной области памяти и формирование адресного слова канала. Помимо этого необходимо заполнить требуемой информацией ряд служебных блоков. В частности, должен быть сформирован блок управления вводом—выводом (IOB), адрес которого задается в качестве операция в макрокоманде EXCP. По этой макрокоманде происходит обращение программного процесса к EXCP-супервизору."},{"tag":"схема работы супервизора ввода-вывода","text":"Работа супервизора ввода—вывода иллюстрируется схемой взаимодействия программы, от которой исходит требование на ввод—вывод, и программы супервизора (рис. 3.13). Управляющие связи между отдельными программными единицами изображены направленными дугами, помеченными цифрами. Непомеченные направленные и ненаправленные дуги — это адресные ссылки или информационные связи. Супервизор ввода—вывода ориентирован на прием запросов от произвольного числа программных процессов. Запросы могут поступать в систему в разных ситуациях, которые контролирует планировщик каналов. Если при поступлении запроса (связь 1) требуемый канал занят, то запрос помещается в очередь запросов к данному каналу (связь 2). В системе принят асинхронный принцип управления вводом—выводом. Поэтому после восприятия запроса супервизором ввода—вывода управление передается программе, выдавшей запрос (связь 3). Разумеется, супервизор «берет на себя обязательство» выполнить действия по вводу—выводу, выраженные в запросе, и оповестить об этом событии процесс, выдавший запрос. Это делается с помощью средств синхронизации процессов, принятых в ОС ЕС, через блок управления событиями (ECB — Event Control Block) с помощью специальных макрокоманд (WAIT и POST). Блок ECB должен быть построен процессом, который обращается к супервизору перед выдачей запроса. Другая возможная ситуация при поступлении запроса — канал свободен и нет очереди запросов к нему. Тогда планировщик каналов передает управление секции начала ввода—вывода (связь 4). Назначение этой секции — инициировать работу канала, т. е. начать работу канала. Выдается команда SIO и проверяется успешность её выполнения. Далее канал начинает работать автономно по канальной программе, ссылка на которую помещена в адресном слове канала (CAW). После инициации канала управление от секции начала ввода—вывода, как и ранее, передается в программу, выдавшую запрос (связь 5). При получении управления программа исполняется дальше, за точкой выдачи запроса. Если возникает необходимость проверки успешности выполнения заказанной ею операции ввода—вывода, она должна воспользоваться средством синхронизации —блоком ECB и макрокомандой WAIT. Когда ввод—вывод закончен, в ECB появляется отметка о таком событии (это делает супервизор прерываний). Окончание очередной работы в канале (конец отработки очередного запроса) вызывает прерывание исполнения программы центрального процессора. Прерванной может быть не обязательно та программа, запрос которой только что был обслужен каналом. При возникновении прерывания (связь 6) управление передается секции кода прерываний супервизора прерываний. Происходит определение, какой канал и какое устройство в нем закончили работу. Далее определяется процесс, по инициативе которого была выполнена закончившаяся работа, проводится анализ успешности выполнения ввода—вывода, отметка о выполнении работы в соответствующем ЕСВ. Поскольку канал освободился, супервизором прерываний производится попытка загрузить его новой работой. Для этого с помощью секции поиска (связь 7) осуществляется анализ очереди запросов к каналу и инициация канала по очередному запросу с помощью средств EXCP-супервизора. После выполнения перечисленных действий, которые можно классифицировать как операцию по обработке прерываний по вводу—выводу, управление передается диспетчеру задач (связь 8). Диспетчер планирует дальнейшее использование центрального процессора, либо возвращает управление на продолжение прерванной по вводу—выводу программе, либо передает управление какой-либо другой программе."},{"tag":"система управления данными и файловые системы","text":"§ 3.5. Система управления данными Современные ЭВМ являются мощным средством по обработке информации не только потому, что осуществляют преобразование данных с помощью команд процессора. Они являются мощным средством для работы с информацией, рассматриваемой в системе как единое целое. Наличие в составе машин внешних запоминающих устройств, способных хранить огромные массивы информации в течение сколь угодно длительного времени, поставило перед разработчиками операционных систем задачу создания специальных систем по управлению данными. Такая система, используемая как интерфейс между пользовательскими и системными процессами и данными, хранимыми на уровне внешней памяти, должна обеспечить эти процессы комплексом услуг по управлению данными. Такое назначение системы управления данными, на первый взгляд, полностью совпадает с функции подсистемы управления вводом—выводом, рассмотренными в предыдущем параграфе. Совпадение несомненно есть, но есть еще ряд функций, которые не присущи подсистеме управления вводом—выводом. Система управления данными — это не что иное, как виртуальная подсистема управления вводом—выводом. Она строится на базе существующей подсистемы управления вводом—выводом, на основе использования специальных программно-аппаратных средств, специальных информационных структур. Пользователи систем управления данными должны получить в результате некоторое виртуальное представление внешней памяти и работать с ней не в терминах команд управления конкретными физическими устройствами внешней памяти (например, обращаться к диску с учетом многочисленных особенностей его адресации), а в терминах, обусловленных особенностями структуры и состава его конкретных наборов данных. Пользователь должен видеть виртуальную внешнюю память как среду, способную хранить его обособленные и поименованные информационные объекты, имеющие определенную внутреннюю структуру. Такого рода объекты, рассматриваемые как отдельные единицы хранения, называют файлами. Системы управления данными называют файловыми системами."},{"tag":"требования к файловым системам","text":"Среда должна обеспечивать возможность хранить произвольное количество файлов без ограничений объема, измеряемого, например, в байтах. Пользователь должен быть обеспечен средствами доступа как к отдельным файлам, так и к их составным частям, с учетом логической структуры. Он должен иметь возможность помещать в виртуальную среду отдельные файлы, а также удалять их. При необходимости должен иметь возможность вести определенную сортировку файлов, объединяя их в некотором порядке или, наоборот, разъединяя. В отношении каждого своего файла пользователь должен быть обеспечен некоторым методом доступа к его внутренним составным элементам. Метод доступа к файлу — это, по сути, способ адресации к составным элементам файла на основе логической структуры файла."},{"tag":"компоненты файловой системы","text":"Назначение файловых систем определяет состав их программных частей. Программная часть должна содержать следующие компоненты: средства взаимодействия с процессами пользователей, которые должны обеспечивать прием и интерпретацию запросов от пользователя на обработку файлов, сообщать им в приемлемой форме о результатах выполненной обработки; средства, реализующие методы доступа к внутренним составным элементам и файлу в целом. Эти средства на основании интерпретации запросов пользователей, анализа учетной информации о файлах и устройствах, где они хранятся, вырабатывают в установленной форме запросы и подготавливают начальные условия для отработки этих запросов в подсистеме управления вводом—выводом. Этими же средствами обеспечивается синхронизация работы с подсистемой ввода—вывода; средства, обеспечивающие распределение внешней памяти для хранения файлов, а также ее освобождение по мере уничтожения файлов; средства учета расположения как файлов в целом, так и отдельных его составных элементов. Все перечисленные средства составляют логический уровень управления данными. Исключением является подсистема ввода—вывода, которую можно считать физическим уровнем управления данными. Именно в таком обобщенном виде файловая система и выступает как интерфейс между программными процессами и файлами (рис. 3.14)."},{"tag":"задачи файловых систем","text":"Файловые системы разрабатывают при разных начальных условиях и ограничениях, обусловленных прежде всего назначением операционной системы и возможностями аппаратуры. Вместе с тем ряд целей являются общими. Необходимо обеспечивать прежде всего удобство и простоту использования средств файловой системы. В мультипрограммных ОС одной из первостепенных задач, является обеспечение эффективной (по времени и по минимуму расхода оперативной памяти) работы файловой системы, обеспечение гарантии сохранности файлов, защиты от несанкционированных доступов пользователей к «чужим» файлам."},{"tag":"сокрытие реального расположения и обработка ошибок","text":"Традиционной задачей файловых систем является сокрытие от программистов реального расположения информации на уровне внешней памяти, обеспечение независимости программ от конкретной конфигурации ЭВМ. Файловая система должна обеспечивать стандартную реакцию на ошибки, возникающие при обмене данными между уровнями памяти. Одна из общих целей файловых систем — унификация операций обмена с различными устройствами, на которых размещаются файлы."},{"tag":"распределение внешней памяти и совместное использование файлов","text":"Несмотря на большие объемы внешней памяти, ее требуется эффективно распределять, как любой ресурс, среди множества процессов. Должно быть обеспечено не только раздельное, но и совместное, при необходимости, использование файлов как критических ресурсов. Причем механизмы реализации должны быть максимально замаскированы от пользователя и минимально влиять на организацию мультипрограммной работы."},{"tag":"подходы к построению файловых систем и уровень абстракции","text":"Различные подходы к построению файловых систем отличаются степенью автоматизации действий по управлению данными. В результате пользователь может воспринимать файл с большей или меньшей степенью абстракции по отношению к той конкретной физической среде, где он хранится."},{"tag":"файлы как переменные в языках программирования","text":"Пользователь, который пишет программу, например, на языке Паскаль, воспринимает файл как структурированную переменную, в отношении которой допустимы операции чтения и записи значений составных однотипных элементов в последовательном порядке. Причем пользователю безразлично, как расположена переменная типа «файл» в памяти (во внешней или оперативной), его не интересуют вопросы пересылки значений между уровнями памяти и т. д. Он работает с последовательным по структуре файлом, как с обыкновенной переменной, используя соответствующие языковые средства. Чтобы обеспечить такую степень абстракции в восприя"}]"}],
[{"tag":"общие сведения о файловой системе и требования к пользователю","text":"\\(ти\\) файла, предполагается, что пользователь должен сообщить файловой системе физические и логические характеристики файла (где расположен файл, его длину, структуру и т. д.) до исполнения программы одним из доступных ему способов. Например, в ОС ЕС ЭВМ такие характеристики сообщаются с помощью средств языка управления заданиями. Более распространенной является ситуация, когда пользователь, работая в контексте определенного языка, хорошо осведомлен, что файл — это поименованная совокупность данных, хранимая во внешней памяти и имеющая определенную структуру. При работе с файлами ему предоставляются средства для резервирования внешней памяти при построении новых файлов, средства для оповещения файловой системы о желании пользователя работать с ней, непосредственные операторы по считыванию и записи информации в (из) файлы и т. д. Другими словами, пользователь должен обладать определенными, хотя и неглубокими знаниями о работе файловой системы, о размещении информации на внешних запоминающих устройствах. При этом не затрагиваются вопросы конкретного программирования работы канала по пересылке данных между уровнями памяти, работы конкретного внешнего запоминающего устройства. Все это делает файловая система. Такой подход реализован, например, в ЭВМ «Искра-226», где пользователь имеет возможность работать только на языке Бейсик. В состав этого языка вмонтированы средства работы с файловой системой, ориентированные на малоквалифицированного пользователя. Известен подход, который основан на представлении каждого файла в системе как некоторого виртуального внешнего устройства, имеющего собственную систему команд и способ доступа, т. е. способ адресации. Эта идеология реализована, например, в ОС МВК «Эльбрус». Такой подход дает возможность рассматривать файловую систему как систему управления периферийными устройствами."},{"tag":"UNIX файловая система: единый подход","text":"В § 3.4 отмечалось, что противоположный подход реализован в ОС UNIX. Там действия пользователя по управлению внешними устройствами аналогичны действиям по управлению файлами. Работа пользователя с файлами и внешними устройствами унифицирована и происходит в терминах файловой системы."},{"tag":"уровни доступа к файлам","text":"В ряде ОС, к числу которых прежде всего относится ОС ЕС ЭВМ, файловая система ориентирована на широкий круг пользователей с различной подготовкой и, следовательно, с разными требованиями к организации работы с файлами. В составе файловой системы реализован принцип функциональной избирательности. Пользователь при желании может работать непосредственно на физическом уровне с некоторым устройством внешней памяти или каким-либо периферийным устройством. При этом система минимально его поддерживает. Либо, наоборот, он может работать на максимально возможном в системе уровне абстракции — логическом, где система полностью автоматизирует действия по доступу к файлам каждого пользователя, обеспечивая при этом мультипрограммную обработку пользовательских процессов, которые работают с файлами. Возможны и промежуточные варианты, когда пользователи могут работать на разных уровнях."},{"tag":"последовательная структура файла","text":"Начнем рассмотрение основных особенностей построения файловых систем с логической структуры файла. Наиболее распространенным подходом является построение файлов с последовательной структурой. Файл рассматривается как одномерный массив составных элементов, называемых логическими записями или логическими блоками. Длина логических записей может составлять десятки байт и быть как переменной, так и постоянной в составе файла. Каждая логическая запись характеризуется своим порядковым номером в составе файла (рис. 3.15, \\( a\\)). Доступ к логическим записям в файлах с последовательной структурой — последовательный. После обработки с помощью операций записи или считывания некоторой \\( i\\)-й по порядку записи доступна для обработки только \\( i+1\\) запись. Следовательно, для организации доступа к файлу с последовательной структурой достаточно иметь один указатель на текущую обрабатываемую запись."},{"tag":"деревовидная структура файлов","text":"В ряде файловых систем предполагается использование более сложных логических структур файлов, нежели последовательная. Например, записи могут быть объединены такой системой связей, при которой файл представляет собой совокупность данных с древовидной организацией. Тогда предполагается, что поиск требуемых записей должен осуществляться в соответствии с алгоритмами поиска по дереву."},{"tag":"индексно‑последовательная организация файлов","text":"Весьма распространенными являются структуры, которые предполагают некоторый вид ассоциативного поиска и обращения к составным элементам файла. Эти методы основаны на идентификации записей файла по некоторому ключу, в качестве которого выступает некоторое поле данных в составе записи. Предложено и используется много способов упорядочения и поиска записей по ключу. Наиболее простым является метод последовательного просмотра записей в файле, которые могут быть как упорядочены, так и не упорядочены по значениям ключей. Такие методы просты в реализации, но требуют большого числа обращений к диску. С целью сокращения обращений усложняют структуру файла. В состав файла помимо собственно данных вводят некоторую учетную информацию. Получается своеобразная «мини-файловая система». Широко используется, например, индексно‑последовательная организация файла (рис. 3.15, б). Такая структура строится так, что поиск элементов файла проводится с помощью двух методов: в последовательном и в прямом (произвольном) порядке. Каждая логическая запись, входящая в файл с данной структурой, содержит ключ — некоторый индивидуальный отличительный признак. Все записи в файле упорядочиваются по значению ключей. Например, если ключом является некоторое двухсимвольное поле записи, начинающееся с буквы, то упорядочение может проводиться в алфавитном порядке расположения ключей. В файл с такой организацией можно выделить группы записей, ключи которых расположены подряд в файле. Эти группы хранятся в некоторой локальной области внешней памяти, например в пределах одной дорожки на диске. Для более быстрого поиска таких групп строят специальную структуру, называемую чаще всего индексом, например индекс дорожки. Каждый элемент индекса описывает отдельную группу записей. Чаще всего индекс содержит значение максимального (в текущий момент времени) ключа в группе и ссылку на начальную запись в группе. В принципе можно построить еще одну группу индексов, если рассматривать индекс файла как файл, и т. д. Построение индексов производят для увеличения скорости поиска нужной записи в файле по искомому ключу. Для поиска записи с некоторым ключом необходимо сначала обратиться к индексу файла и определить группу записей, диапазон значений ключей которой входит искомый ключ. По индексу находят начало первой записи требуемой группы, а затем, обращаясь к самой группе, последовательным анализом ключей в каждой записи находят требуемую запись. При такой организации файла время поиска записи будет меньше, чем в случае, если бы файл имел последовательную структуру."},{"tag":"пример индексно‑последовательной организации (словарь)","text":"Иллюстрацией индексно‑последовательной организации файла может служить, например, толковый словарь. Каждая запись в таком файле — это толкование отдельного термина. Каждый отдельный термин — это ключ записи алфавита. Для описания расположения в словаре каждой группы терминов, размещенных в алфавитном порядке, используют индекс. Индекс можно построить из представителей отдельных групп, расположенных их в алфавитном порядке. Представитель группы — это, в простейшем случае, первый элемент группы. При занесении представителя группы в индекс записывается номер страницы (адресная ссылка), с которой начинается группа терминов в словаре и в которую он входит. Для поиска нужной записи необходимо обратиться сначала к индексу и найти страницу, с которой начинается требуемая группа терминов, обратиться к этой странице и, последовательно считывая термины и сравнивая их с искомым (термином), найти требуемый."},{"tag":"расширение файлов и область переполнения","text":"Основная проблема, которая присуща работе с файлами с индексно‑последовательной организацией, — проблема расширения файла во время работы с ним. Это связано с тем, что логика взаимного расположения записей в файле требует упорядоченности их по ключам. Чтобы решить эту проблему, вводят так называемую область переполнения, куда будут заноситься записи, динамически вводимые в файл, которые нельзя разместить в основной области из-за отсутствия места в ней. Из основной области устанавливаются ссылки (в соответствии с логическим порядком ключей) на требуемые элементы области переполнения."},{"tag":"библиотечная структура файлов","text":"Широко распространенной в практике использования файлов является библиотечная структура файлов. Это также своеобразная «минифайловая система». Данная структура предполагает два уровня — учетный и собственно информационный. Файл с библиотечной организацией составляется из совокупности последовательных наборов данных, каждый из которых имеет собственное имя в составе данного файла. В терминологии ОС ЕС, например, такие отдельные наборы библиотеки называют разделами. Расположение разделов в библиотеке в общем случае никак не упорядочено (рис. 3.15, \\( a\\)). Они записываются в библиотеку по мере поступления. Расположение каждого отдельного раздела фиксируется в каталоге библиотеки, который размещен на учетном уровне файла. Для сокращения поиска элементы каталога, как правило, расположены в алфавитном порядке следования имен разделов. Естественно, что обращение к каждому отдельному разделу, т. е. элементу файла с библиотечной структурой, происходит через каталог."},{"tag":"физическая и логическая структура файлов","text":"Физическая структура файла, т. е. расположение информации на конкретном носителе, чаще всего значительно отличается от логической упорядоченности. Так, если файл имеет последовательную логическую структуру, то записи, логически смежные в файле, необязательно будут храниться физически смежно в некоторой среде хранения, например на поверхности магнитного диска. Преобразование логической структуры в физическую происходит с учетом особенностей распределения внешней памяти и с помощью специальной связующей информации, однозначно отображающей такое преобразование. Большая часть такой информации сосредоточивается в каталогах файлов и специальных описателях (дескрипторах) файлов."},{"tag":"алгоритмы распределения внешней памяти","text":"Тот или иной вид физической структуры обусловлен способом распределения ресурса внешней памяти. Требования к алгоритмам распределения могут быть самыми разными, зачастую противоречивыми. Хотя внешняя память имеет большой объем, необходимо заботиться о рациональном ее использовании. Вместе с тем алгоритм распределения должен быть таким, чтобы он обеспечивал быстрый поиск как занятых участков, где располагаются данные из файлов, так и свободных участков памяти. На практике для распределения внешней памяти используются, по сути, те же алгоритмы, что и для распределения оперативной памяти. Отличие состоит в способах реализации механизмов распределения. Наиболее часто участки свободной оперативной памяти (дыры) связывают по некоторому правилу в список (например, дыры упорядочены по размеру). Указатели на каждый последующий элемент списка помещают в состав самих дыр. Такая организация явно неприемлема для учета дыр на диске. Проход по списку до некоторого i-го элемента (i-й дыры) потребовал бы i—1 обращения к диску. Поэтому при связывании дыр на диске в список указатели на элементы списка, как правило, объединяют в некоторую таблицу. Таблицу указателей или некоторую ее часть перед поиском можно переписать в оперативную память, а затем отыскать в ней нужный указатель. Этот прием существенно уменьшает время поиска."},{"tag":"распределение блоков и фрагментация","text":"При реализации алгоритмов распределения пространства внешней памяти принято разбивать ее на блоки фиксированного размера, каждый из которых имеет свой уникальный порядковый номер, по которому можно однозначно идентифицировать непрерывную область памяти, принадлежащую блоку. Длина блоков сравнительно небольшая. Чаще всего 256 или 512 байт. Память под файлы выделяется либо непрерывной областью, состоящей из некоторого числа смежных свободных блоков, достаточных для хранения данных файла, либо выделение памяти происходит в физически несметной последовательности блоков, произвольным образом расположенных в пространстве внешней памяти. Первый способ сравнительно прост в реализации и часто используется в простых файловых системах, например в упоминаемой ранее ЭВМ «Искра-226», миниЭВМ, использующих ОС РАФОС, и др. Этому способу свойственно, по крайней мере, два недостатка, что затрудняет его использование в рамках мультипрограммной реализации. Определенные затруднения возникают, если пользователи изменяют по мере работы размеры своих файлов. В данной ситуации необходимо создать новый файл требуемого размера, переписать в него старый файл и освободить память под старым файлом. Необходимость в такой процедуре возникает потому, что каждый файл ограничен соседними наборами данных. Кроме того, при данном способе, как и в случае распределения оперативной памяти, возникает явление фрагментации — наличие запаса неиспользуемых длительное время дыр малого размера, для ликвидации которых требуется периодически проводить уплотнение информации на носителе. Второй способ предполагает несмежное размещение блоков и снимает проблемы расширения (динамического) размеров файлов, практически ликвидируется фрагментация. Однако при этом усложняется алгоритм распределения, поиска нужной информации и, как следствие, увеличивается время доступа к информации."},{"tag":"UNIX inode и косвенная адресация","text":"Наиболее развитым механизмом распределения, построенным на основе данного способа, можно считать механизм распределения внешней памяти, принятый в системе UNIX. Система потенциально ориентирует пользователя на возможность динамического изменения размеров файлов, допуская взрывное увеличение размеров в пределах до 1 Гбайта (максимально допустимый размер файла может быть 1082 201 088 байт). Каждый файл в системе имеет дескриптор (рис. 3.16), в составе которого хранится список, содержащий 13 номеров блоков на диске. Список используется для адресации к тем блокам, которые входят в состав файла. Используется как прямая, так и косвенная адресация. Первые десять элементов списка непосредственно указывают на десять блоков, в которых могут размещаться данные файла. Если файл большего размера, то используются последующие три элемента списка. Одиннадцатый элемент списка используется для одноуровневой косвенной адресации. В нем указан номер блока, хранящий список из 128 номеров блоков, которые могут принадлежать файлу (помимо указанных первых десяти). Обращение к таким блокам косвенное — через блок первого уровня косвенной адресации. Если требуется объем файла, превышающий \\(10+128\\) блоков (каждый блок — 512 байт), то требуется использовать двенадцатый или даже тринадцатый элементы списка в дескрипторе. Двенадцатый элемент указывает на второй уровень косвенной адресации — ссылается на блок, который содержит список из 128 номеров блоков первого уровня косвенной адресации. Следовательно, можно адресоваться в составе файла уже к \\(128\\times128+128+10\\) блокам. С помощью тринадцатого элемента в списке дескриптора файла производится обращение к третьему уровню косвенной адресации, где указана ссылка на блок, содержащий список из 128 номеров блоков второго уровня косвенной адресации. С помощью третьего уровня косвенной адресации можно обращаться к \\(128^3\\) блокам файла. Итак, имеется потенциальная возможность использовать чрезвычайно большие по объему файлы. Однако при этом необходимы промежуточные обращения к косвенным блокам. Авторы разработки считают, что это не является существенным недостатком. Отмечается, например, что по наблюдениям накладные расходы на потребление памяти в файловой системе, насчитывающей в своем составе 25 000 блоков файлов и содержащей 13 Мбайт данных, составляют 10% общего объема данных."},{"tag":"каталоги файлов и VTOC","text":"Современные файловые системы машин, работающих в мультипрограммных режимах, способны обслуживать десятки и тысячи файлов. Отсюда следует, что роль учетного механизма в составе файловой системы очень важна. Общепринятым приемом является сведение учетной информации о местах расположения файлов в пределах одного или нескольких томов в одно место. Тогда эта информация, представленная в определенном формате, выполняет: роль каталога (справочника). Доступ к файлам в таком случае организуется через соответствующий каталог. Под термином «том» здесь и далее понимаем сменный носитель информации, который имеет уникальный идентификатор, программно доступный операционной системе. например, том — это сменный пакет дисков, в определенном месте которого записана стандартная метка тома. Обычно каталоги располагают на тех же томах, где расположены файлы. Содержание и структура каталогов определяются содержанием и структурой учитываемых файлов, стремлением достичь должной гибкости в способах доступа к файлам, обеспечить допустимое время доступа. Каталоги могут быть как автономными, так и объединенными в некоторую структуру. В ряде ОС на каждом томе имеется единственный каталог, который содержит сведения о всех файлах, находящихся на этом же томе, что реализовано, например, в системе РАФОС. Каталог представляет собой список элементов, каждый из которых описывает характеристики конкретного файла на томе. Основная информация, содержащаяся в каталоге и используемая для организации доступа к требуемому файлу, — имя файла, тип файла, местоположение и длина файла на томе. В ОС ЕС ЭВМ аналогичные функции выполняет оглавление тома (VTOC — Volume Table of Contents) — структура, хранимая на каждом томе и содержащая учетную информацию о файлах, расположенных на томе (рис. 3.17). Информация, описывающая каждый отдельный файл в VTOC, весьма разнообразна и объясняется универсальностью файловой системы ЕС ЭВМ. Помимо традиционного указания имени файла и места расположения его в памяти указывают физические и логические характеристики. Поскольку в системе допустимы файлы с различной логической структурой, указываются конкретный тип структуры и характеристики составных элементов файла — формат логических записей, блоков из записей и т. д. Если файл располагается на нескольких томах, то указывается регистрационный номер первого тома, порядковый номер тома в многотомном файле и т. д."},{"tag":"многоуровневая файловая система и каталоги","text":"Системы, в которых каталоги файлов никак между собой не связаны, можно считать одноуровневыми файловыми системами. Основное соглашение, которое в них должно быть выдержано, — это фиксация места расположения каталога на томе. Место должно быть известно файловой системе. Для фиксации используют, как правило, определенные системные соглашения. Например, в простейшей файловой системе ЭВМ «Искра-226» каталог всегда начинается с нулевого сектора диска. Хотя все другие системы гораздо сложнее, но, по сути, используется такой же прием. Так в ОС ЕС VTOC может располагаться в произвольном месте тома. Однако на него имеется адресная ссылка из так называемой метки тома. Метка тома содержит информацию, используемую при организации хранения и автоматической идентификации тома. Эта метка формируется при выполнении процедуры инициализации тома, когда и указывается место расположения VTOC на томе. Информация вносится в состав метки тома, а сама метка записывается на строго определенное место на диске — на нулевой дорожке нулевого цилиндра. Таким образом, при установленном томе на устройстве внешней памяти файловая система всегда способна отыскать каталог файлов, а через него обратиться к любому файлу на томе. В ряде систем на одном томе стро"}],
[
    {
        "tag": "способы ввода-вывода файлов",
        "text": "Синхронный способ считывания или записи данных в файл возможен только в случае, если файл имеет последовательную структуру. После выдачи запроса, реализованного в виде макрокоманды, на ввод или вывод одной логической записи (минимально различимый элемент в файле) программный процесс переводится системой принудительно в состояние ожидания. Он будет переведен системой обратно в активное состояние только тогда, когда система закончит пересылку информации между файлом и указанной в макрокоманде области памяти.\n\nПри асинхронном способе файловая система после восприятия запроса от программного процесса на ввод или вывод данных из (в) файла передает управление программному процессу без перевода его в состояние ожидания. Вместе с тем файловая система предоставляет ему средства для последующей проверки окончания заказанной операции ввода\\-вывода. Используя асинхронный способ, можно работать с любой структурой файлов, допустимой в файловой системе ОС ЕС."
    },
    {
        "tag": "операции третьей группы в UNIX",
        "text": "Операции, составляющие третью группу, в разных системах могут иметь существенные различия. В системе UNIX, например, к этой группе относят команды по переименованию файлов, управлению правами доступа к файлам, команды создания и уничтожения каталогов. К этой группе можно отнести команды, обеспечивающие печать содержимого каталога или файла, команды поиска файла по дереву каталогов и др."
    },
    {
        "tag": "структура виртуальной памяти",
        "text": "§ 4.1. Структура виртуальной памяти\n\nПри современном уровне развития вычислительной техники пользователь знает, что для исполнения его программы и хранения данных требуется память. Но представление о памяти у различных пользователей может быть существенно различным. Оно зависит от возможной степени абстракции в представлении машины, которую определяют ему конкретный язык программирования и операционная система машины. За исключением случаев написания программы непосредственно в машинных кодах, пользователю предоставляется возможность работать не с реальной, а с виртуальной памятью.\n\nВ контексте данной книги понятие виртуальной памяти рассматривается в широком смысле. Виртуализация подвергается не только оперативная, но и другие виды памяти. Физическая память современных машин является многоуровневой. Каждый уровень памяти при работе ОС рассматривается как разделяемый ресурс. В зависимости от особенностей алгоритмов распределения такого вида ресурсов пользователи воспринимают память с характеристиками, отличными от характеристик реально существующей памяти. Наряду с основными свойствами того или иного уровня физической памяти пользователю могут быть предоставлены различные дополнительные свойства, отсутствующие в реальной памяти.\n\nТак, при реализации виртуальной оперативной памяти каждому пользователю предоставляются обычные свойства оперативной памяти — последовательный вид доступа к памяти, непосредственная адресация, времена доступа, сравнимые с временами доступа к реальной оперативной памяти. Кроме того, превносятся новые качества. К числу основных относят практически неограниченный или очень большой объем непрерывного адресного пространства, которое получает каждый программист в монопольное или совместное использование.\n\nНа машине может существовать также и виртуальная регистровая память, если в ОС имеется такая система распределения аппаратных регистров, что при их ограниченном числе любой активный процесс автоматически получает в свое распоряжение нужное для его развития количество (в пределах числа реально существующих) регистров. Таким видом памяти обладает, например, МВК «Эльбрус» [6].\n\nСуществует и виртуальная внешняя память, которую часто называют файловой памятью. Виртуальной внешней памяти присущи стандартные свойства — долговременное хранение информации, произвольность объемов хранения и т. д. Помимо этого пользователи получают доступы к данным по способам, отличным от реальных способов доступа к адресуемым элементам внешней памяти. С ее помощью можно осуществлять, например, выборку информации с учетом ее структурно\\-логической упорядоченности.\n\nИтак, при использовании специальных программно\\-аппаратных средств многоуровневой физической памяти в составе ОС может быть построена своя виртуальная память для каждого или некоторых уровней. Причем предполагается функциональное расслоение виртуальной памяти по уровням, эквивалентным уровням реальной памяти. Поэтому такую схему построения виртуальной памяти машины называют вертикальной.\n\nНа каждом уровне виртуальной памяти можно добиться различной степени виртуальности, под которой понимается степень отличия свойств уровня виртуальной памяти от соответствующего ему уровня реальной памяти. К свойствам уровня можно отнести, например, удобство программирования, способ доступа к памяти, технические характеристики — объем доступного пространства памяти, время доступа и т. д. Хотя такие отличия всегда существуют, не представляется возможным выразить их количественно из-за множественности и нестандартности свойств как того, так и другого видов памяти. Поэтому далее будем использовать только качественные оценки. Если на одном или более уровнях допускается расслоение виртуальной памяти, то такую схему называют горизонтальной.\n\nЕсли машина имеет виртуальную память с вертикально\\-горизонтальной схемой расслоения, то пользователь может работать с любым уровнем памяти. При этом предполагается, что память каждого уровня с определенной степенью виртуальности обладает собственным механизмом доступа к информации, хранимой в этой памяти."
    },
    {
        "tag": "адресное пространство и физическая адресация",
        "text": "§ 4.2. Основные понятия и принципы виртуализации памяти\n\nКаждый тип физической памяти имеет некоторую среду хранения, составленную из однотипных элементов. Каждый элемент способен хранить информацию и является адресуемым в соответствии со способом адресации, принятым для данной среды хранения. Все доступное множество адресов элементов хранения, упорядоченное по какому-либо признаку, называют адресным пространством памяти.\n\nАдрес понимают как некий символ, однозначно идентифицирующий расположение элемента хранения среди прочих элементов в составе среды хранения. Форма задания адреса полностью определяется механизмом доступа к элементам хранения, принятым для данной памяти.\n\nВ простейшем случае механизм доступа — это механизм физической адресации конкретного вида памяти, реализованный аппаратно. Тогда адрес — это число, которое однозначно определяет номер требуемого элемента хранения. В представлении пользователя адресное пространство — это последовательность целых чисел, начинающихся, как правило, с нуля. Число различных элементов последовательности адресов конечно и равно некоторому значению \\( N \\), называемому размером адресного пространства. Для данного механизма доступа размер адресного пространства равен объему (емкости) конкретного вида памяти \\( V \\). Для измерения объема памяти используются байт или слово, объединяющее несколько байт. На рис. 4.1 показан пример механизма физической адресации оперативной памяти, емкость которой \\( N_{оп} = V_{\\phi} = 32 \\ , \\text{K} \\) слов. Каждый адресуемый элемент хранения может содержать одно слово информации. Поэтому размер адресного пространства \\( N = 32 \\ , \\text{K} \\) адресов. Адресация начинается с нуля. При подаче на вход механизма физической адресации физического адреса \\( A_{\\phi} = 1117 \\) происходит непосредственное обращение к слову с адресом 1117.\n\nМеханизм физической адресации может послужить основой для построения более сложного механизма доступа, который реализуется уже, как правило, в программно\\-аппаратной форме. На входе такого механизма в качестве адреса может быть использовано представление не в числовой, а в какой\\-то другой форме, более удобной для пользователя данного механизма. Например, может быть использовано некоторое символьное имя. Предполагается, что такой адрес должен однозначно определять некоторый элемент хранения среди прочих, адресуемых также по именам в соответствии с установленными правилами адресации. Следовательно, пользователь данного механизма доступа имеет дело с адресами, отличными от физических адресов конкретного вида памяти. Такие\n\nПрограммно\\-аппаратный механизм доступа — это средство виртуализации физического адресного пространства. Пользователь не имеет непосредственного доступа к механизму физической адресации, а лишь к его программному слою. Этот слой составляют процессы, которые обеспечивают необходимое преобразование каждого виртуального адреса из допустимого входного виртуального адресного пространства в некоторый физический адрес в пределах физического адресного пространства. При одном механизме физической адресации можно построить различные программные слои над ним. Для пользователя это проявляется в том, что ему предоставляется возможность работать в различных виртуальных адресных пространствах. Для системы это проявляется в необходимом управлении различными по назначению и составу системам процессов и ресурсов. Программный слой механизма доступа в данном случае представляется неоднородным, а состоящим из некоторого числа компонентов. Связи между компонентами строятся в пределах вертикально\\-горизонтальной схемы, рассмотренной ранее. В результате пользователь имеет возможность обращаться к различным компонентам и работать с памятью с различной степенью виртуализации. Например, адресное пространство символьных адресов, используемых в программе на ассемблере, можно рассматривать как виртуальное адресное пространство. Это пространство преобразуется статически в физические адреса памяти средствами транслятора и загрузчика, которые в данном случае представляют собой программный компонент механизма доступа к оперативной памяти. Виртуальность для пользователя проявляется в том, что он получает возможность использовать символьную адресацию как более удобную, чем числовой способ обращения к отдельным элементам хранения оперативной памяти. Структура символьного (виртуального) адресного пространства и физического адресного пространства оперативной памяти при этом остаются идентичными. Поэтому степень виртуальности в данном случае является весьма слабой.\n\nПри построении программно\\-аппаратных механизмов доступа возникает необходимость устанавливать связи с другими системами процессами, поскольку при решении задач преобразования виртуальных адресов в физические необходимо решать ряд сопутствующих задач, которые рассмотрены далее. Для успешного их решения возникает необходимость введения в архитектуру машины специальных средств.\n\nСуществует много схем решения задачи преобразования адресов."}],
[{"tag":"структурирование фиксированными страницами - группировка и нумерация страниц","text":"Группировку проводят последовательно от начала исходного адресного пространства в порядке возрастания адресов. Причем каждый вновь образованной странице присваивают номер в возрастающем порядке в последовательности целых чисел, начиная с 0. Очевидно, что максимальный номер страницы будет равен \\(2^{n-m}-1\\). В результате проведенной группировки получено новое адресное пространство, представляющее собой последовательность номеров страниц: \\( k = 0, 1, 2, ..., 2^{n-m} - 1 \\). Между полученным и исходным адресными пространствами имеется следующее соответствие. Для каждой страницы с номером \\( k \\) всегда можно найти адрес ее начала в исходном адресном пространстве: \\( A_h = kL \\). Для двоичного представления адреса страницы в исходном адресном пространстве размером \\( N = 2^n \\) необходимо поле в \\( n \\) двоичных разрядов. Тогда адрес начала любой страницы в двоичном представлении будет характеризоваться тем, что в \\( m \\) младших разрядах его будут содержаться нули."},{"tag":"смещение внутри страницы","text":"Группировка адресов по страницам и нумерация страниц — это первый шаг структуризации. Второй шаг заключается в том, что производится перенумерация адреса в пределах каждой страницы. Каждую страницу рассматривают как отдельное адресное пространство. Адреса в пределах каждой страницы получают значения от 0 до \\( 2^m - 1 \\) в порядке возрастания от начала страницы. Такие адреса внутри страницы с целью их выделения называют *смещением*. Значения смещений внутри каждой страницы лежат в одних и тех же пределах: \\( 0 \\leq R \\leq 2^m - 1 \\)."},{"tag":"пример фиксированных страниц","text":"После проведения второго шага структуризация адресного пространства на основе страничной организации закончена. В результате одномерное адресное пространство превращено в двухмерное. Теперь адрес задается уже двумя координатами — значением номера страницы \\( k \\) и значением смещения в данной странице \\( R \\), составляющими совместно так называемую адресную пару \\((k, R)\\). На рис. 4.2 приведен пример структуризации исходного одномерного адресного пространства, составленного из 16 адресов. Для наглядности каждый адрес обозначен точкой. В состав страницы входит четыре адреса. Начальные адресы четырех полученных страниц имеют нули в младших \\( m = 2 \\) разрядах двоичного изображения адреса в исходном адресном пространстве:\n| Номер страницы | Начальный адрес |\n|---|---|\n| 0 | 0 | 0000 |\n| 1 | 4 | 0100 |\n| 2 | 8 | 1000 |\n| 3 | 12 | 1100 |\nСтаршие \\( n - m = 2 \\) разряда в двоичном изображении адреса, как видно из примера, представляют собой двоичный код номера страницы."},{"tag":"преобразование адресов (страница+смещение)","text":"Между странично-структурированным и исходным одномерным адресными пространствами устанавливается взаимно однозначное соответствие. Для перехода из исходного адресного пространства в странично-структурированное достаточно двоичное изображение. Адрес 6 принадлежит странице с номером 1 (двоичное изображение 01) и находится в ней со смещением 2 (двоичное изображение 10). Соответственно адрес 13 принадлежит странице с номером 3 (двоичное изображение 11) и находится в ней со смещением 1 (двоичное изображение 01). Рассматриваемые адреса обведены кружками."},{"tag":"формула база+смещение","text":"Для перехода из странично-структурированного адресного пространства в исходное одномерное можно воспользоваться выражением вида: \\( A=kL+R \\). Здесь адрес в «страничном виде» задан адресной парой \\((k, R)\\). Вновь обратимся к рис. 4.2. Пусть заданы два адреса в виде адресных пар \\((3, 2)\\) и \\((1, 3)\\). Производим переход по указанному выражению. Для первого адреса: \\( A_1=3 \\cdot 2^2 + 2 = 14 \\). Для второго адреса: \\( A_2=1 \\cdot 2^2 + 3 = 7 \\). На рис. 4.2 используемые компоненты адресных пар обведены квадратами."},{"tag":"конкатенация адресов","text":"Выражение для преобразования адресов из странично-структурированного адресного пространства в адреса непрерывного адресного пространства декларирует хорошо известный принцип адресации «база+смещение». Здесь базируется непрерывные области — страницы. В качестве базового адреса («базы») в непрерывном адресном пространстве выступает величина \\( kL \\). Вместе с тем можно заметить следующее. Для вычисления выражения по преобразованию структурированного адреса в непрерывный требуется выполнение двух действий: умножения и сложения. Можно обойтись одним действием, требующим гораздо меньшего времени при практической реализации данной функции преобразования. По сути, необходимо произвести действие, обратное действию по переходу от непрерывного адреса к структурированному. Из адресной пары «структурированного» адреса необходимо двоичное изображение номера страницы \\( k \\) поместить в старшие \\( n-m \\) разрядов двоичного изображения «непрерывного» адреса. Соответственно двоичное изображение смещения \\( R \\) из адресной пары необходимо поместить в младшие \\( m \\) разрядов двоичного изображения «непрерывного» адреса. Итак, получено двоичное изображение адреса в непрерывном адресном пространстве. Такую операцию по объединению двух двоичных изображений с целью получения третьего двоичного числа называют _конкатенацией_."},{"tag":"пример конкатенации","text":"Для иллюстрации действия принципа конкатенации вновь обратимся к рис. 4.2. Возьмем вновь два «структурированных» адреса, т. е. адресные пары (3,2) и (1,3). Конкатенация двоичного изображения номера страницы 3 (11) и смещения 2 (10) дает двоичное изображение «непрерывного» адреса 1110, т. е. в десятичном представлении это 14. Аналогично конкатенация двоичного изображения номера страницы 1 (01) и смещения 3 (11) дает двоичное изображение «непрерывного» адреса 0111. В десятичном представлении это 7."},{"tag":"структурирование переменными страницами - ввод","text":"Рассмотренный вариант структурирования адресного пространства называют _структурированием фиксированными страницами_. Известен и используется и другой вариант страничного структурирования, когда структуризация исходного непрерывного адресного пространства производится на основе использования страниц переменного размера. Этот вариант называют _структурированием переменными страницами_."},{"tag":"переменные страницы - детали","text":"Как и в предыдущем варианте, на первом шаге структуризации необходимо произвести группировку адресов в страницы в исходном адресном пространстве. Но теперь допускаем, что число адресов в составе каждой страницы может различаться. Устанавливается диапазон изменения размеров страниц: \\( 1 \\leq l \\leq L \\). Верхняя граница этого диапазона \\( L = 2^m \\). Причем выдерживается ограничение \\( L \\leq N \\), где \\( N \\) — размер исходного непрерывного адресного пространства. На втором шаге, как и в первом варианте, в каждой странице производится перенумерация адресов, начиная с нуля. Следовательно, смысл смещения остается тем же, что и в первом подходе. Однако начальные (базовые) адреса страниц, длины которых уже не кратны 2, не будут иметь в общем случае нулевых значений в младших \\( m \\) разрядах двоичного представления абсолютного адреса. Поэтому нумерация страниц, переменных по длине, лишена смысла. По значению номера страницы и длине уже невозможно определить ее базовый адрес. Поэтому каждой \\( i \\)-й странице адресного пространства при таком подходе должен быть поставлен в соответствие в качестве атрибута ее абсолютный базовый адрес \\( A_{i_0} \\)."},{"tag":"адресная пара переменных страниц","text":"Следовательно, как и в первом варианте, при структуризации одномерное адресное пространство преобразуется в двухмерное. Для задания адреса в этом пространстве необходимо также задать две координаты — базовый адрес страницы \\( A_{i_0} \\) и смещение \\( R \\), которые в совокупности также составляют адресную пару вида \\((A_{i_0}, R)\\)."},{"tag":"пример переменных страниц","text":"На рис. 4.3 показан пример структуризации непрерывного адресного пространства, представленного на рис. 4.2, на основе схемы «структурирование переменными страницами». Максимальный размер страницы \\( L = 4 \\). По оси абсцисс в отношении каждой страницы нанесены не номера страниц, а их начальные (базовые) адреса в непрерывном адресном пространстве. В рассматриваемой схеме уже нет взаимно однозначного соответствия между «структурированным» и «непрерывным» адресами. Это вызвано тем, что способов группировки при указанном ограничении на размеры страниц может быть больше одного. В первом варианте способ группировки при заданном размере страницы только один."},{"tag":"преобразование переменных страниц в непрерывный адрес","text":"Возможен переход от структурированного представления адреса в виде адресной пары \\((A_{i_0}, R)\\) к непрерывному. Обратный переход в силу указанных причин невозможен. Для допустимого перехода необходимо использовать принцип «база + смещение», т. е. для получения значения непрерывного адреса \\( A \\) по заданному структурному \\((A_{i_0}, R)\\) необходимо использовать выражение: \\( A = A_{i_0} + R \\). На рис. 4.3 структурированному адресу, заданному парой (12,1) соответствует непрерывный адрес в исходном адресном пространстве: \\( A = 12 + 1 = 13 \\). Однако по значению непрерывного адреса 13 (попытка сделать обратный переход) нельзя сказать, к какой странице он принадлежит."},{"tag":"сегментная схема - ввод","text":"Рассмотрим второй класс структуризации, который называют сегментным. Это более общий случай варианта структуризации переменными страницами. На первом шаге структуризации исходного адресного пространства производят объединение адресов в группы, которые в данном случае называют сегментами. Размеры сегментов, т. е. число адресов в составе сегментов, различаются и находятся в диапазоне \\( 1 \\leq l_s \\leq N \\). Помимо этого каждый сегмент получает номер \\( s \\), который должен отличаться от других номеров. Упорядочение номеров необязательно. Номер сегмента выступает как идентификатор, имя сегмента."},{"tag":"трехмерное представление сегментов","text":"На втором шаге структуризации, в соответствии с проведенным разбиением, каждому сегменту ставится в соответствие его базовый адрес \\( A_{s_0} \\), т. е. адрес начала сегмента в непрерывном исходном адресном пространстве. В результате получается двухмерное представление адресного пространства. В нем каждый сегмент определяется своими координатами \\((s, A_{s_0})\\), где \\( s \\) — номер сегмента; \\( A_{s_0} \\) начальный (базовый) адрес данного сегмента. Как и ранее, в каждом сегменте производится перенумерация адресов. Поэтому смысл смещения \\( R \\) остается прежним. Введение смещения — это переход к трехмерному представлению адресного пространства. Для задания адреса в этом пространстве необходимы три координаты: номер сегмента \\( s \\), его базовый адрес \\( A_{s_0} \\) и смещение в сегменте \\( R \\)."},{"tag":"пример сегментной схемы","text":"На рис. 4.4 показан пример структуризации рассматриваемого непрерывного адресного пространства по сегментной схеме. На первом шаге структуризации происходит формирование сегментов и присвоение номеров сегментам. Номера сегментов не упорядочены и могут быть произвольными целыми числами, например 17; 1 и 24 (расположены по оси ординат на рис. 4.4). На следующем шаге формируется двухмерное представление адресного пространства — каждому сегменту с определенным номером ставится в соответствие его базовый адрес. Наконец, на последнем шаге завершается построение трехмерного представления адресного пространства, в котором располагаются три сегмента."},{"tag":"преобразование сегментного адреса","text":"Как и в предыдущем варианте, при заданном структурном адресе можно осуществить переход к непрерывному адресу. Обратное невозможно. На практике при использовании сегментной схемы структуризации задают не три координаты структурированного адреса \\((s, A_{s_0}, R)\\), а всего две — номер сегмента s и смещение R. Тогда при переходе от такого «усеченного структурированного» адреса к непрерывному необходимо выполнить две операции. Сначала сегменту с номером s необходимо присвоить базовый адрес \\( A_{s_0} \\) (операция установления соответствия), а далее провести определение непрерывного адреса, используя принцип адресации «база—плюс—смещение»: \\( A = A_{s_0} + R \\). Назначение базового адреса проводится в свою очередь по мере выделения непрерывной области адресов, равной размеру сегмента, в составе непрерывного адресного пространства."},{"tag":"сегментно-страничная схема - ввод","text":"На практике используют и комбинированные схемы структуризации, называемые *сегментно-страничными*. Исходное непрерывное адресное пространство сначала подвергается структурированию фиксированными страницами по схеме, рассмотренной ранее. Далее происходит еще одна группировка. Сегмент рассматривается уже как некоторая непрерывная последовательность номеров страниц в промежуточном странично-структурированном адресном пространстве. Размер сегмента — это количество страниц, входящих в состав сегмента. Каждый сегмент также имеет свой уникальный номер s. Затем в пределах каждого сегмента происходит перенумерация страниц, начиная с нуля в возрастающем порядке. Поскольку размеры сегментов (в количестве страниц) различны, то по номеру сегмента (если проводить нумерацию сегментов в возрастающем порядке) невозможно определить его базовый адрес. Поэтому при формировании сегмента в"}]"}],
[
    {
        "tag": "сегментно-страничная структуризация",
        "text": "адресном пространстве ему должен быть назначен базовый адрес \\( A_{s_0} \\). Таким образом, адрес в полученном сегментно-структурированном адресном пространстве задается с помощью четырех координат: \\( s \\) — номер сегмента; \\( A_{s_0} \\) — базовый адрес сегмента; \\( R' \\) — номер страницы в пределах сегмента; \\( R \\) — смещение в пределах страницы. Для перехода от такого структурного адреса к непрерывному необходимо сначала выполнить операцию соответствия, т. е. назначить сегменту базовый адрес \\( A_{s_0} \\). Затем, используя операцию «база — плюс — смещение», найти базовый адрес страницы в составе сегмента: \\( A_R' = A_{s_0} + R'L \\). Далее, к найденному базовому адресу страницы необходимо применить операцию конкатенации — присоединить значение смещения, если размер страницы был кратен 2."
    },
    {
        "tag": "логическая организация виртуальной оперативной памяти",
        "text": "В § 4.3 оставлен без ответа вопрос о необходимости структуризации адресного пространства. Кроме того, возникает еще ряд вопросов. В частности: какое адресное пространство (виртуальное или некой среды хранения) подвергать структуризации и по какой схеме? какое соответствие необходимо устанавливать между схемами структуризации отдельных адресных пространств? Для ответа на эти и подобного рода вопросы необходимо еще раз рассмотреть целевое назначение виртуальной оперативной памяти.\\n\\nРанее было подчеркнуто, что виртуальная память строится для удовлетворения нужд пользователя, для предоставления ему новых свойств оперативной памяти, облегчающих процесс программирования. Но это только одна сторона дела. Построение виртуальной памяти дает возможность во многом облегчить или повысить эффективность работы операционной системы в части управления ресурсами оперативной памяти и процессора.\\n\\nМожно построить виртуальную память, ориентированную в первую очередь на удовлетворение потребностей пользователя, а не системы. Возможен и другой вариант, когда виртуальная память в большей степени ориентирована на удовлетворение нужд системы, а не пользователя. Наконец, возможны такие схемы построения виртуальной оперативной памяти, которые предполагают компромиссное решение — удовлетворение потребностей как пользователя, так и системы, которые по своей природе в большей части противоречивы.\\n\\nСистемные требования к виртуальной памяти прежде всего заключаются в увеличении степени использования оперативной памяти при параллельном развитии некоторого числа процессов в каком-либо мультипрограммном режиме. Помимо исключения потерь памяти необходимо достигнуть такого распределения оперативной памяти, чтобы не вызывать ощутимых задержек процессов при обращении к данным, которые они обрабатывают. При этом память хотелось бы распределить так, чтобы достигнуть развития максимально возможного числа параллельных процессов, минимально мешающих друг другу из-за ресурса памяти и тем самым поднять пропускную способность системы. В качестве примера приведем требования, сформулированные разработчиками МВК «Эльбрус»:\\n\\n1) должен быть вызван квант данных, вероятность использования которых в последующий момент наибольшая; 2) требуемый квант данных должен быть вызван в самый последний момент и было бы возможно освобождать оперативную память в любой момент после ее использования; 3) должна быть предусмотрена возможность перераспределять данные внутри оперативной памяти или сброса их во внешнюю память с последующим вызовом; 4) должна быть предусмотрена возможность располагать большие массивы, представляющие собой единую линейную последовательность данных, в различных участках оперативной памяти отдельными квантами.\\n\\nЭти системные требования удовлетворяются виртуальной памятью в составе МВК «Эльбрус».\\n\\nИспользование виртуальной памяти дает возможность системе (опять же в разной степени, в зависимости от конкретной архитектуры виртуальной памяти) достаточно просто решать еще ряд важных задач. Например, эффективное использование программных ресурсов, реализация защиты информации при развитии процессов, обеспечение взаимодействия между процессами и т. д.\\n\\nТребования пользователей к памяти могут быть весьма противоречивыми. Одни пользователи пишут короткие программы, для размещения которых необходимы небольшие (по сравнению с объемом оперативной памяти) участки памяти. Другие, наоборот, пишут длинные программы, объем которых соизмерим или даже больше (а иногда и значительно) объема оперативной памяти. Кроме того, некоторые программы никак не структурированы, т. е. не содержат в своем составе каких-либо дистанционно вызываемых программных единиц типа подпрограмм, процедур, блоков и пр. Другие, наоборот, построены как некоторая программная система, состоящая из определенного числа указанных программных единиц и некой ведущей программы. Все эти компоненты связаны между собой определенным образом. Процесс исполнения программы одного пользователя может взаимодействовать с процессом исполнения программы другого пользователя посредством разделения одного и того же программного ресурса. Процедура служит примером такого ресурса. К ней может обращаться как один, так и другой процесс. Все эти особенности работы пользователей накладывают определенные требования на построение виртуальной памяти и, разумеется, в разной степени учитываются разными архитектурами виртуальной оперативной памяти.\\n\\nПрежде чем рассматривать различные логические схемы построения виртуальной памяти, остановимся на ряде общих для этих схем понятий и принципов.\\n\\nПрограмма, поступающая от отдельного пользователя для погружения в виртуальную память, представлена, по сути, двумя компонентами — неким программным текстом и адресным пространством, в пределах которого используются адреса в составе данной программы. Программный текст логически состоит из двух частей, которые будем называть соответственно *кодовый сегмент и данные*. В кодовый сегмент входят команды программы, текстуально упорядоченные программистом. Кодовая часть программы и данные могут быть структурированы определенным образом, т. е. разбиты на некоторые логически обособленные части. Такое разбиение распространяется и на адресное пространство.\\n\\nДалее рассмотрим две возможности общения пользователя с виртуальной памятью.\\n\\n1. Пользователь пишет программы без структуризации в пределах непрерывного адресного пространства, которое предоставляется в его распоряжение механизмом виртуальной памяти. Каждый адрес рассматривается пользователем при программировании как адрес одного слова оперативной памяти, которая выделяется ему (в его представлении!) как физически непрерывная область, состоящая из отдельных слов. Размер этой области может быть больше размера реальной оперативной памяти. Заметим, что у других пользователей может возникнуть такое же представление об использовании виртуального непрерывного адресного пространства. Каждый имеет собственное адресное пространство. Причем одно никак не связано с другим. Это проявляется, в частности, в том, что если два пользователя используют в программе одно и то же значение адреса, то они не имели в виду одну и ту же ячейку оперативной памяти. При исполнении их программ эти виртуальные адреса (одинаковые по значению) будут в общем случае преобразованы в различные адреса реальной оперативной памяти."}],
[{"tag":"отображение виртуальных страниц на физические","text":"Итак, каждая часть программного текста пользователя помещается в некоторый блок оперативной памяти перед исполнением. Но адреса в этих частях программы остались в том виде, как их написал пользователь и преобразовала система, т. е. во всех командах присутствуют структурные виртуальные адреса, ориентированные на исполнение программы в непрерывной последовательности виртуальных страниц в пределах от 0 до \\( K - 1 \\). Следовательно, требуется отобразить страничное виртуальное пространство на страничное пространство оперативной памяти. Для каждой виртуальной страницы необходимо указать, какая физическая страница поставлена ей в соответствие. Тем самым созданы предпосылки для динамической (по мере исполнения программы) настройки адресов. По сути, речь идет о процессе перемещения кванта программного текста, написанного в пределах адресного пространства некоторой виртуальной страницы, на новое место в среде хранения — в некоторый блок. Данный программный текст должен быть преобразован так, чтобы при своем исполнении он содержал уже исполнительные адреса в пределах адресного пространства физической страницы."},{"tag":"адресация база+смещение","text":"Перемещение программ, использующих принцип адресации «база—плюс—смещение», производится весьма просто. Достаточно для механизма адресации указать значение нового базового адреса, т. е. начального адреса области, куда перемещается программа. Далее каждый исполнительный адрес при работе перемещенной программы получается путем сложения базового адреса со смещением."},{"tag":"отображение виртуальных страниц на физические","text":"В данном случае перемещается часть программы, равная по размеру одному блоку. Как было показано, в странично структурированном адресном пространстве всегда имеется возможность перехода от структурированного адреса, заданного адресной парой, к непрерывному в предположении, что по номеру страницы всегда можно однозначно определить ее базовый адрес. Поэтому после отображения каждой виртуальной страницы на некоторую физическую всегда можно однозначно осуществить преобразование любого виртуального адреса в абсолютный исполнительный."},{"tag":"решение проблемы фрагментации","text":"В данном случае система поставлена в более благоприятные условия для эффективного решения задачи распределения оперативной памяти. В самом деле, вместо того, чтобы искать при выделении памяти для программы один непрерывный участок, состоящий из \\( Q \\) слов (для рассматриваемого случая), она может найти (что более вероятно) и выделить для использования \\( K \\) несмежных, в общем случае, блоков памяти. При таком подходе в значительной степени решается проблема фрагментации, а следовательно, уменьшаются потери памяти. Продемонстрируем это. Пусть система пытается распределить адресное пространство оперативной памяти для размещения в ней программы размером \\( Q \\). Пусть в текущий момент в системе зафиксировано, что свободными (т. е. не распределенными для использования) являются \\( K = [Q/L] + 1 \\) блоков, которые физически несмежны в памяти. Если бы оставалось требование на выделение программе непрерывной области оперативной памяти, то в рассматриваемой ситуации распределение памяти для программы было бы невозможно, хотя свободная память имеется. В схеме чисто страничного распределения такое требование непрерывного распределения не является обязательным. В результате отдельные части программы можно перемещать в несмежные блоки оперативной памяти."},{"tag":"мультипрограммное исполнение","text":"Мультипрограммного исполнения программ можно достичь с достаточной степенью эффективности при условии, что размеры адресных пространств каждой программы в среднем допускают размещение в оперативной памяти одновременно двух или более программ."},{"tag":"страничная (по требованию) схема и локальность","text":"Страничная (по требованию) схема функционирования виртуальной оперативной памяти. Можно провести модификацию чисто страничной схемы функционирования виртуальной оперативной памяти (и, разумеется, всего механизма виртуальной памяти), если отказаться от основного принципа предыдущей схемы, где предполагается, то при исполнении программа должна находиться целиком в оперативной памяти. Принципиальная возможность для этого имеется. Первая посылка заключается в том, что в программах различные части адресного пространства используются с раз-ной интенсивностью. При каждом конкретном исполнении может оказаться, что некоторые части программы вообще могут быть не использованы. Как показывают исследования, в типичных программах доля неиспользуемого адресного пространства может достигать 25%. Следует стремиться к того, чтобы такие потенциальные используемые части и не загружались в память. Вторая посылка определяется локальностью вычислений. При исполнении программы в течение некоторого интервала времени \\(\\"}],
[
    {
        "tag": "адресные атрибуты виртуальной памяти",
        "text": "Любой элемент данных, помещенный в виртуальную оперативную память, характеризуется тремя адресными атрибутами: \\[A_B \\] — виртуальным адресом в виртуальном адресном пространстве; \\[A_A \\] — абсолютным адресом в адресном пространстве архивной среды хранения; \\[A_{ОП}\\] — абсолютным адресом в адресном пространстве оперативной памяти."
    },
    {
        "tag": "четыре задачи управления виртуальной памятью",
        "text": "Вопрос построения механизма, автоматически перемещающего информацию в рабочую среду из архивной при обращении к ней в ходе развития активного процесса, является самым важным при построении виртуальной оперативной памяти. Построение механизма основано на решении четырех взаимосвязанных задач управления виртуальной памятью: *размещение, перемещение, преобразование, замещение.* Каждая задача решается по-разному, в зависимости от выбранной схемы функционирования виртуальной памяти.\n\nВ результате решения задачи размещения в адресном пространстве оперативной памяти выбираются страницы или сегменты, на которые будут отображаться некоторые страницы (или сегменты) виртуального адресного пространства.\n\nПри решении задачи перемещения в архивной среде хранения выбирается та информация, которая принадлежит отображаемой виртуальной странице (сегменту). Эта информация переносится в страницу (сегмент) оперативной памяти, найденную в результате решения задачи размещения. Одним из возможных решений задачи перемещения может быть перенесение программного текста из рабочей среды хранения в архивную. Такой перенос возникает тогда, когда требуется перераспределить некоторую страницу (сегмент) адресного пространства оперативной памяти. Информацию из перераспределяемой области оперативной памяти требуется сохранить, когда она не соответствует копии в архивной среде. Адрес в архивной среде определяется с помощью соответствующей функции преобразования \\[A_A = F_1(A_B)\\].\n\nПо мере решения задачи преобразования находят абсолютный адрес слова в рабочей среде хранения по его виртуальному адресу в соответствии с функцией преобразования \\( A_{ОП} = F_2(A_B) \\).\n\nРешением задачи замещения является выбор среди прочих страниц адресного пространства оперативной памяти кандидата на перераспределение. Решение проводится по мере решения задачи размещения в ситуации, когда обнаруживается отсутствие «свободных» страниц в адресном пространстве оперативной памяти, на которые можно было бы вести отображение.\n\nРешение четырех задач управления виртуальной памятью пытаются находить, руководствуясь соображениями эффективности. Кроме основных факторов, определяющих эффективное использование оперативной памяти, при реализации механизма виртуальной оперативной памяти главенствующим является требование минимизации времени на решение задач управления. Минимизация должна проводиться как при построении отдельных механизмов, решающих эти задачи, так и при их взаимодействии по мере обработки данных."
    },
    {
        "tag": "задача размещения",
        "text": "Рассмотрим виртуальную оперативную память со «страничной по требованию» организацией. При ее построении, как правило, используют различные алгоритмы распределения адресных пространств архивной и рабочих сред хранения, а также виртуального адресного пространства. Это обусловлено существенной разницей в размерах этих адресных пространств, а также особенностями доступа к архивной и рабочим средам хранения. Размер виртуального адресного пространства существенно больше размера адресного пространства оперативной памяти: \\( N_B \\gg N_{ОП} \\). При выбранном способе структуризации и длине страницы \\( L \\) соотношение \\( \\alpha = L / N_B \\) всегда значительно меньше единицы. Значение \\( \\beta = L / N_{ОП} \\) значительно больше \\( \\alpha \\). Соотношения \\( \\alpha \\) и \\( \\beta \\) можно назвать коэффициентами расщепления странично структурированных адресных пространств, виртуальной и оперативной памяти соответственно. Одной из основных причин появления виртуальной памяти и прежде всего ее страничной организации является стремление уменьшить фрагментацию. Возникает вопрос: достигнуто ли уменьшение фрагментации? Ответ неоднозначен: и да, и нет. Да — поскольку исключена фрагментация между областями оперативной памяти, выделяемой для выполнения каждого задания. Каждая из этих областей кратна длине физического блока (страницы) и в оперативной памяти исключена рассматриваемая фрагментация, которую называют *внешней*. Нет — так как при страничной организации возникает так называемая *внутренняя* фрагментация. Этот вид фрагментации определяется тем фактором, что в общем случае объем адресного пространства задания не кратен длине физического блока. Поэтому последняя страница задания, как правило, не заполнена. При помещении такой страницы в оперативную память ее незаполненная часть — это не что иное, как неиспользуемая память. В среднем для каждого задания теряется половина страницы. Кроме указанного вида потерь часть оперативной памяти используется для хранения учетной информации — таблиц сегментов, таблиц страниц, что также следует отнести к невосполнимым, абсолютным потерям памяти второго вида. Оба вида потерь взаимосвязаны. Очевидно, что чем меньше размер страницы, тем меньше потери первого типа и больше потери второго типа. Потери от фрагментации при распределении виртуального адресного пространства ведут к некоторому уменьшению числа используемых виртуальных адресов. Потери от фрагментации адресного пространства оперативной памяти влияют на пропускную способность системы — уменьшают темп обработки процессов, а также коэффициент мультипрограммирования. Это вызвано тем, что не используется определенная часть дорогостоящего физического ресурса, чего нет в случае виртуального адресного пространства. На практике распространенной точкой зрения на распределение виртуального адресного пространства является следующая. Для повышения скорости решения задачи размещения виртуального адресного пространства выбирают максимально простой алгоритм его распределения, в меньшей степени обращая внимание на возможные потери пространства. Алгоритм строят так, чтобы уменьшить частоту его использования. Операцию размещения виртуального адресного пространства следует классифицировать как «длинную» по сравнению с операцией размещения адресного пространства оперативной памяти. Это также накладывает определенные ограничения на выбор алгоритма распределения и способа его реализации."
    },
    {
        "tag": "алгоритм распределения без переиспользования",
        "text": "Пример алгоритма распределения виртуального адресного пространства в ОС МВК «Эльбрус». Виртуальное адресное пространство имеет размер \\( N_B = 2^{23} \\) адресуемых слов, что значительно превышает размер адресного пространства оперативной памяти, равного \\( N_{ОП} = 2^{20} \\). При одном из возможных размеров адресного пространства страницы \\( L = 2^9 \\) коэффициент расщепления виртуального адресного пространства \\( a = 2^{-23} \\). Коэффициент расщепления адресного пространства оперативной памяти \\( \\beta = 2^{-11} \\). Реально значение коэффициента \\( \\beta \\) в МВК «Эльбрус» другое. Это объясняется тем, что структурирование адресного пространства оперативной памяти производится на основе схемы с переменными по длине страницами в комбинации с другими схемами структурирования. Реальный коэффициент тем не менее соизмерим по значению \\( c = 2^{-11} \\). Видно, что характеристические коэффициенты удовлетворяют соотношению \\( \\beta > a \\).\n\nВиртуальное адресное пространство состоит из возрастающей последовательности номеров страниц в диапазоне от 0 до \\( 1/a - 1 = 2^{23} - 1 \\). Минимальной единицей распределения является страница. Выделение страницы по требованию производится в соответствии с правилом, названным «без переиспользования». Каждый раз при необходимости помещения некоторого массива данных в виртуальную память этот массив «погружают» в адресное пространство виртуальной памяти (в терминологии МВК данный вид виртуальной памяти называют математической). Погружение заключается в выделении области адресного пространства виртуальной памяти, состоящей из некоторого числа физически смежных номеров страниц. Количество распределяемых страниц (номеров страниц) при размере массива в \\( Q \\) слов составит \\( P = [Q/L] + 1 \\), где \\([x]\\) — целая часть от \\( x \\). Номера для страниц, распределяемых под массив, выделяются в строго возрастающем порядке из числа еще не распределенных номеров свободных страниц.\n\nОчевидно, что при данном способе распределения в каждый момент времени пространство состоит из двух секторов.\n\n«Занятый» сектор включает в себя физически смежную последовательность номеров страниц, распределенных для массивов. Минимальный номер страницы в этой последовательности всегда равен нулю. Максимальный — переменный по значению, изменяется по мере распределения адресного пространства.\n\n«Свободный» сектор представляет собой единственную «дыру», в состав которой входят все нераспределенные номера страниц. Максимальный номер страницы в составе свободного сектора всегда фиксирован и равен \\( M \\) — максимальному номеру среди страниц адресного пространства: \\( M = N_B/L \\). Минимальный номер этой последовательности всегда на единицу больше максимального номера в «занятом» секторе. Этот номер можно назвать указателем дыры и обозначить \\( M_0 \\). При каждом новом распределении значение указателя всегда возрастает. Значение \\( M_0 = 0 \\) означает, что все адресное пространство свободно, т. е. в адресном пространстве существует только «свободный» сектор. Значение \\( M_0 = M + 1 \\) означает другое крайнее состояние адресного пространства, когда «дыра» исчезла, а существует только «занятый» сектор. Все номера страниц в адресном пространстве распределены.\n\nНаличие единственной «дыры» чрезвычайно упрощает алгоритм распределения адресного пространства. Для идентификации «дыры» достаточно знать только значение указателя. Если размер требуемой области под массив меньше текущего размера «дыры», то из «дыры» выделяется соответствующая"}],
[
    {
        "tag": "перераспределение страниц",
        "text": "При данном способе структуризации возможно и используется перераспределение страниц. Если в некоторый момент обнаруживается, что свободных страниц нет, то имеется «кандидат» на перераспределение из числа уже распределенных страниц. Информацию, соответствующую странице-кандидату, переносят на уровень внешней памяти (в архивную среду). Затем освобожденную таким «насильственным» образом страницу закрепляют за процессом, выдавшим требование на выделение страницы. Выбор страницы-кандидата, а также перенос информации в архив осуществляются механизмами, реализующими решение задач замещения и перемещения."
    },
    {
        "tag": "страницы переменной длины и дыр",
        "text": "Значительно большие сложности возникают при построении алгоритма размещения в адресном пространстве оперативной памяти, структурированной страницами переменной длины. При требованиях, рассмотренных выше, возникает новое ограничение. Длина страницы, которую следует выделить при каждом разовом запросе, может быть переменной в пределах от 1 до L. Следовательно, номер страницы при данном способе структуризации лишен смысла и не может идентифицировать расположение нужной страницы. Каждую страницу требуется характеризовать адресной ссылкой на ее начало в адресном пространстве и ее длиной. Помимо распределенных в пространстве оперативной памяти могут быть «свободные» области, т. е. непрерывные последовательности адресов слов, не распределенные для использования в текущий момент времени. Поскольку их длины могут превышать величину L, то такие области будем называть не свободными страницами, а «дырами». Для распределения пространства оперативной памяти при рассматриваемом способе структуризации необходимо учитывать расположение в ней как распределенных страниц, так и дыр."
    },
    {
        "tag": "учет страниц и дыр",
        "text": "От способа формирования учетной информации о переменных по длине страницах (имеется в виду для краткости, что это распределенные страницы) и «дырах» зависит эффективность работы алгоритма размещения. Поскольку адресное пространство оперативной памяти в точности соответствует структуре среды хранения (и то и другое — последовательность смежных элементов), то, как правило, учетную информацию хранят физически смежно с объектом, который она описывает."
    },
    {
        "tag": "линк как связующая информация",
        "text": "Как было установлено в первой части книги, для описания каждой дыры используют специальную связующую информацию, называемую *линком*. В ОС МВК «Эльбрус» линки — это основа построения учетного механизма."
    },
    {
        "tag": "механизм формирования учетной информации",
        "text": "Рассмотрим один из возможных механизмов формирования учетной информации. Он в основном подобен механизму, принятому в ОС «Эльбрус»."
    },
    {
        "tag": "типы дыр: перемещаемые и резидентные",
        "text": "Каждая дыра ограничивается двумя линками — в младших адресах дыры (линк А) и в старших адресах (линк Z). Это дает возможность строить два типа списков дыр. Различают *перемещаемые* и *резидентные* дыры. В пространстве перемещаемых дыр удовлетворяются запросы на память для размещения информации, которая может быть перемещена в пределах среды хранения оперативной памяти либо даже перенесена на уровень внешней (в так называемый файл откачки). В пространстве резидентных дыр размещаются массивы, которые должны храниться в памяти постоянно по мере их размещения. Перемещать их нельзя."
    },
    {
        "tag": "определение типа дыр",
        "text": "Тип дыры с точки зрения ее перемещаемости определяется с помощью специального алгоритма, анализирующего тип информации в страницах, физически смежных с дырой. Может возникнуть такая ситуация, когда одна и та же дыра является одновременно перемещаемой и резидентной."
    },
    {
        "tag": "схема учета дыр",
        "text": "Рис. 4.7. Схема учета «дыр» адресного пространства оперативной памяти МВК «Эльбрус» (\\( L4 \\leq L2 \\leq L5 \\leq L6; \\; L1 < L2; \\; L2 > L3; \\; L1 < L3 \\))."
    },
    {
        "tag": "список перемещаемых дыр",
        "text": "Для учета всех перемещаемых дыр строится двунаправленный список, состоящий из линков A перемещаемых дыр, а также дыр, которые одновременно являются и перемещаемыми и резидентными. В каждом линке имеются адресные ссылки на предшествующий и последующий линки в списке, указывается длина дыры. В линк, находящийся в конце списка, заносится специальный признак. Указатель начала списка всегда находится в слове оперативной памяти с адресом, равным 0."
    },
    {
        "tag": "список резидентных дыр",
        "text": "Для учета всех резидентных дыр строится двунаправленный список, состоящий из линков Z, резидентных дыр, а также дыр, которые одновременно резидентны и перемещаемы. Структура линка Z повторяет структуру линка A. Указатель начала списка также фиксирован в системе — находится в первом слове оперативной памяти."
    },
    {
        "tag": "пример учета дыр",
        "text": "На рис. 4.7 приведен пример учета в системе трех перемещаемых и четырех резидентных дыр. Дыра длиной \\( L2 \\) находится одновременно в двух списках. Как любые списковые структуры, списки дыр могут быть упорядоченными или нет по какому-либо признаку. В МВК «Эльбрус» список перемещаемых дыр не упорядочен, а список резидентных дыр упорядочен в порядке возрастания длин дыр."
    },
    {
        "tag": "поиск в списках дыр",
        "text": "Очень важным является способ реализации алгоритма поиска требуемого элемента в списке. В МВК «Эльбрус» для организации поиска предусмотрена специальная машинная команда."
    },
    {
        "tag": "перераспределение при выделении страниц",
        "text": "В алгоритмах распределения оперативной памяти предполагается перераспределение областей адресного пространства в случае выделения памяти для очередной страницы. Для реализации перераспределения необходимо учитывать расположение не только дыр, но и страниц. Различают «линк», стоящий в начале страницы (линк A) и в конце (линк Z). Страницы также могут быть резидентными и перемещаемыми. Каждая страница снабжается собственными линками, которые будут использоваться не только при решении задачи размещения, но и в алгоритмах задачи преобразования."
    },
    {
        "tag": "задача перемещения и архивная среда",
        "text": "§ 4.8. Задача перемещения. Рассмотрим логические основы решения задачи перемещения, а именно основные положения распределения адресного пространства для архивной среды хранения, реализуемой на внешних запоминающих устройствах. Из-за многообразия средств управления и распределения этих устройств невозможно привести унифицированную схему распределения адресного пространства архивной среды. Можно лишь выдвинуть общие требования к построению архива исходя из специфики решения четырех задач управления виртуальной памятью. Архивная среда не должна накладывать каких-либо ограничений на пользователей виртуальной памяти."
    },
    {
        "tag": "требования к архивной среде",
        "text": "Если, например, установлен размер виртуального адресного пространства равным \\(2^{32}\\) слов, то архивная среда должна быть в состоянии хранить всю информацию, которую можно «погружать» в такое пространство, а также определенные (порой весьма значительные) объемы служебной информации, необходимой для решения четырех задач управления памятью. Особые условия накладываются на алгоритм распределения адресного пространства архивной памяти, если виртуальная память построена по сегментно-страничной схеме. Работа с архивной средой представляет собой «длинную» операцию по сравнению с работой в рабочей среде. Однако важно использовать таких алгоритмов работы с архивом, которые минимизировали бы время помещения информации в архив и время поиска требуемой информации в архиве. Архивная среда — это большой по объему, но все же ограниченный ресурс, весьма дорогостоящий. Поэтому необходимо помимо прочих удовлетворять требование по экономизму использованию архивной среды хранения."
    },
    {
        "tag": "файл откачки и файловая система",
        "text": "Архивная среда со своим адресным пространством поддерживается файловой системой и названа файлом откачки (ФО). Этот файл предназначен для хранения архивной и служебной информации, относящейся ко всем пользователям, работающим с виртуальной оперативной памятью. Архивная среда — это устройство внешней памяти барабанного и (или) дискового типа. Адресное пространство архивной среды не является последовательностью физических адресов для обращения к барабану или диску. Оно построено в терминах файловой системы—состоит из файловых адресов и структурных объединений этих адресов, различаемых в системе. Файловая система преобразует файловые адреса пространства архивной памяти в физические адреса носителей. Архивная среда со своим адресным пространством выступает как виртуальная внешняя память."
    },
    {
        "tag": "соответствие физической и виртуальной адресации",
        "text": "Существует следующее соответствие между физической и виртуальной адресациями. Минимальным адресуемым элементом на носителях барабанного и дискового типа принят сектор. Объем сектора на барабане и диске — 32 слова. Но разрядность слова на барабане — 72, а на диске — 64. Сектора объединены в физические листы. Каждый лист — это совокупность нескольких смежных секторов. Количество секторов в листе (длина листа) является величиной переменной и может быть задано в качестве атрибута того файла, который располагается на конкретном носителе. Все физические листы и сектора в нем пронумерованы, что позволяет однозначно установить физический адрес"}],
[{"tag":"уровень 1 структура листов","text":"На первом уровне файл откачки рассматривается как смежная последовательность листов. Причем количество листов может быть переменным во времени. Во избежание коллизий по месту в архивной памяти всегда поддерживается некий резерв полностью свободных листов. Управление файлом на этом уровне осуществляется обычными средствами файловой системы и специальным процессом операционной системы. Последний активизиру- Файл откачки Уровень 1. Лист 1 Уровень 2. Ряд 1 Уровень 3. Сектор ... Сектор Сектор ... Сектор Сектор ... Сектор ... Рис. 4.8. Схема структуризации файла откачки Для листа Ряд L Ряд L+k-1 Сектор ... Сектор ... Сектор ... еется, если запас свободных листов становится слишком малым или слишком большим. На первом уровне структуризации лист — это единица взаимодействия между файлом откачки и системой управления файлами."},{"tag":"уровень 2 структура рядов","text":"На втором уровне файл откачки рассматривается уже как совокупность более мелких структурных элементов, названных рядами. Каждый лист разбивается на одно и то же число рядов. Ряды пронумерованы в сквозном порядке по файлу откачки. Ряд — это единица измерения адресного пространства. Выделение непрерывной области в файле откачки для нужд отдельных задач происходит рядами."},{"tag":"учет свободных рядов и двоичный вектор","text":"Система учета свободных и занятых рядов построена следующим образом. Строится двоичный вектор с разрядностью, равной числу рядов в файле откачки. Каждый разряд характеризуется своим значением (0 или 1) и порядковым номером в векторе. Разряд с номером i отображает текущее состояние ряда с номером i в файле откачки. Если в текущий момент времени ряд i нераспределен (свободен), то i-й разряд вектора установлен в 0. В противном случае — в 1. В двоичном векторе для каждого листа устанавливается счетчик свободных рядов в листе. На каждую задачу заводится специальная таблица, в которой описываются все ряды, выделенные для данной задачи к текущему моменту времени. Указывается общее количество закрепленных за задачей рядов, конкретные их номера и некоторая уточняющая информация о распределении пространства внутри ряда. На эту таблицу направлены указатели из других таблиц, где описаны характеристики задачи при управлении ею."},{"tag":"правило самый подходящий и распределение рядов","text":"Распределение пространства на основе использования рядов выполняют соответствующие процедуры ОС. Удовлетворение требований осуществляется по правилу «самый подходящий». Требование удовлетворяется в том листе файла откачки, который имеет свободную непрерывную область, где можно удовлетворить тре-"},{"tag":"уровень 3 структура секторов","text":"среди прочих листов самое большое количество уже распределенных рядов. На третьем уровне файл откачки рассматривается как совокупность секторов, включенных в соответствующие ряды. Размер сектора равен размеру физического сектора. Выбор рядов в области пространства, выделенного задаче для резервирования в них некоторого числа секторов, основан на правиле «самый подходящий». Среди рядов задачи находят «самый заполненный», т. е. имеющий максимальное количество занятых секторов, и одновременно такой, в котором можно удовлетворить запрос — выделить нужное число секторов. Распределение пространства ряда проводится по алгоритму, аналогичному рассмотренному ранее алгоритму распределения виртуального адресного пространства. В ряду постоянно поддерживается одна дыра, состоящая из некоторого числа смежных секторов и «прижатая» к старшим адресам ряда. Сектора выделяются всякий раз из начала дыры, т. е. всегда в порядке возрастания номеров секторов. Занятая часть ряда — это последовательность распределенных секторов и секторов, которые были ранее распределены, но в текущий момент времени освобождены. Последние поэтому можно назвать, как и раньше, *псевдодырями*, которые принимаются во внимание только при полном заполнении ряда (при исчезновении единственной дыры)."},{"tag":"алгоритмы передачи данных FIFO и правило наименьшего времени доступа","text":"Особенности алгоритмов передачи данных. При решении задачи перемещения помимо задачи распределения адресного пространства архивной среды необходимо решать еще ряд задач, влияющих в значительной степени на эффективность работы виртуальной оперативной памяти. Необходимо учитывать характеристики внешних запоминающих устройств и прежде всего времена доступа к информации при том или ином способе ее физического расположения на носителе. Для вращающихся устройств памяти время доступа зависит от порядка, в котором происходит передача информации от устройства или к устройству. Такой порядок определяется тем или иным алгоритмом передачи. В качестве распространенного можно назвать — «первый пришел — первый обслужен» (FIFO). Используют также специальные алгоритмы, учитывающие расположение информации в архивной среде. Например, в алгоритме передачи часто используют правило выбора: «следующая — страница с наименьшим временем доступа». Данный алгоритм, как показывает анализ, приводит к достаточно ощутимым сокращениям среднего времени доступа к страницам, находящимся в архивной среде, по сравнению с алгоритмом передачи на основе правила FIFO. Так, если время доступа к М страницам, размещенным на барабане, t, то время доступа к одной странице при использовании правила FIFO равно","tag":"формула времени доступа FIFO","text":"\\( T = (1/2 + 1/M)t"}],
[{"tag":"архивные модули и базовые адреса","text":"В справочник сегментов можно занести также справочную информацию о модулях, находящихся в текущий момент времени в архивной среде. Это могут быть абсолютные базовые адреса модулей, но уже в архивной среде. Значение этого адреса будет храниться в элементе справочника сегментов с индексом \\( S \\), если соответствующий модуль находится в архивной среде. Если же модуль будет перенесен с помощью алгоритма перемещения в рабочую среду, то данному элементу должно быть присвоено значение найденного базового адреса по оперативной памяти \\( A_s \\)."},{"tag":"виртуальное адресное пространство и справочник сегментов","text":"Нетрудно заметить, что виртуальное адресное пространство любого программного текста, состоящего из пронумерованных в сквозном порядке сегментов, — это просто перечень индексов в справочнике сегментов конкретного пользователя. Распределение такого пространства проводится на статической основе — в него сразу «погружаются» все сегменты, что сводится к присвоению им номеров."},{"tag":"вычисление абсолютного адреса сегмента","text":"Обращение к справочнику сегментов должно происходить каждый раз, когда при работе с неким сегментом с номером \\( S \\) появилась потребность в обращении к новому сегменту программного текста, имеющего номер \\( S' \\neq S \\). При расположении справочника сегментов в оперативной памяти для определения базового адреса сегмента с номером \\( S' \\) достаточно выбрать содержимое элемента справочника с таким же номером. Адрес этого элемента \\( A_0' = A_a + S' \\), где \\( A_a \\) — базовый адрес справочника. Тогда для обращения к элементу сегмента со смещением \\( R_s \\), его абсолютный адрес должен быть вычислен согласно выражению: \\( A_0 = <A_0' > + R_s' = <A_a + S' > + R_s \\). Данное выражение иллюстрирует необходимость использования комбинации двух принципов адресации: «база — плюс — смещение» и «косвенная адресация»."},{"tag":"длинное преобразование адресов и регистр R1","text":"Виртуальный адрес элемента сегмента рассматривается как адресная пара (\\( S', R_s' \\)). Вычисление по виртуальному адресу его абсолютного эквивалента — это более длинная операция, чем в случае использования «короткого» преобразования. Такую операцию необходимо выполнять только в момент первого обращения к\n\n===== Page 10 =====\n\nсемей преобразования адресов. Для этого необходимо при первом обращении к сегменту переустановить значение регистра \\( R_1 \\), т. е. присвоить ему значение найденного адреса \\( A_0 \\). Далее будет работать «короткая» схема преобразования, но уже с новым сегментом, вплоть до момента вызова очередного сегмента. Тогда следует повторить действия по обработке справочника сегментов. На рис. 4.10 показана схема преобразования, учитывающая возможность перехода от сегмента к сегменту в едином программном тексте. В регистре \\( R_2 \\) хранится базовый адрес \\( A_a \\) справочника сегментов. Перенос информации обозначен пунктирной линией. Сплошные линии указывают на связи по адресам."},{"tag":"механизм учета пользователей и каталог виртуальных памятей","text":"При работе с сегментами различных пользователей необходим некоторый механизм их учета. Как правило, он строится на том, что каждому пользователю в системе присваивается некоторый номер. Это номер его виртуальной памяти в некотором списке учета виртуальных памятей. Такой список можно рассматривать как объединенное виртуальное пространство. Его составными элементами являются номера виртуальных памятей пользователей, работающих в текущий момент времени с системой. Виртуальное адресное пространство будет небольшим по объему, так как число пользователей, работающих одновременно в системе и имеющих собственную сегментную виртуальную память, будет находиться в пределах от десятков до сотен, но никак не десятков тысяч. Поэтому может быть выбран любой алгоритм для распределения этого виртуального адресного пространства, в том числе предполагающий перенсиспользование, означающее присвоение пользователю, вошедшему в систему, одного из номеров тех пользователей, которые уже закончили работу."},{"tag":"каталог пользователей и вычисление адресов","text":"Для нахождения места расположения J‑го словаря сегментов (J = 0, 1, 2, ...) используют выражение: \\( A_a = <R_3> + J> \\). Тогда для получения абсолютного адреса некоторого элемента, находящегося в сегменте с номером S со смещением R_s и принадлежащего словарю с номером J, используют выражение вида:\n\\[A_0 = <<R_3> + J> + S> + R_s.\\]"} ,{"tag":"хранение справочников сегментов в архиве","text":"При практической реализации схемы преобразования очень важно определение места хранения учетной информации — каталога и словарей сегментов. Каталог из-за сравнительно небольших размеров хранят в оперативной памяти. Справочники сегментов можно хранить в архивной среде и вызывать необходимый справочник по мере необходимости в оперативную память."},{"tag":"страничная организация виртуальной памяти","text":"**Механизм преобразования адресов в виртуальной оперативной памяти на основе страничной по требованию организации.** При данном способе структуризации адресных пространств используется принцип адресации «база—конкатенация—смещение». Каждой странице виртуального адресного пространства сопоставляется страница адресного пространства оперативной памяти. Суть сопоставления заключается в следующем. При первом обращении к данным, адресованным в пределах страницы с номером \\( k' \\) в виртуальном адресном пространстве, должна быть выделена страница с номером \\( k \\) в пространстве адресов оперативной памяти. Все виртуальные адреса в пределах «виртуальной» страницы с номером \\( k' \\) «проецируется» на «физическую» страницу с номером \\( k \\). Каждый"},{"tag":"проекция виртуальной страницы на физическую","text":"виртуальный адрес \\( A_B = (k', R) \\) заменяется на ему соответствующий физический адрес \\( A_{ОП} = (k, R) \\). Для реализации такого преобразования достаточно в \\( n \\)-разрядное слово, содержащее виртуальный адрес \\( A_B \\), занести в старшие \\( (n-m) \\) разрядов значение номера физической страницы вместо номера виртуальной страницы \\( k' \\). Младшие \\( m \\) разрядов преобразуемого виртуального адреса, в которых содержится значение смещения \\( R \\), остаются без изменения."},{"tag":"таблица страниц (ТС)","text":"Для отображения текущего распределения физических страниц за виртуальными, как правило, используют табличное представление учетной информации. Таблицу, хранящую учетную информацию о распределении страниц, называют таблицей страниц (ТС). Для увеличения скорости преобразования адресов наиболее естественно хранить ТС в оперативной памяти строить ее как прямому ресурсу. Для каждого виртуального адресного пространства число элементов в ТС выбирается равным числу страниц в виртуальном адресном пространстве. Рассмотрим далее только одно адресное пространство при расположении ТС в оперативной памяти. Каждый элемент ТС с номером \\( k' \\), равным номеру виртуальной страницы, должен содержать номер физической страницы \\( k \\), если она выделена. В противном случае в элементе должен храниться признак «отсутствие в ОП»."},{"tag":"алгоритм преобразования адресов (страничный)","text":"Алгоритм преобразования адресов можно представить такой последовательностью действий.\n1. Определить по двоичному представлению виртуального адреса номер виртуальной страницы \\( k' \\).\n2. Обратиться к ТС, используя принцип адресации «база—плюс—смещение», для выборки элемента, описывающего «проекцию» требуемой виртуальной страницы: \\( k = <B> + k' \\), где \\( B \\) — регистр, содержащий базовый адрес таблицы страниц по оперативной памяти \\( A_{TC} \\).\n3. Если элемент ТС хранит признак «отсутствие в оперативной памяти», то выделить блок оперативной памяти и перенести туда требуемую часть программы, написанной в пределах адресного пространства виртуальной страницы \\( k' \\). При этом, возможно, придется решать не только задачи размещения и перемещения, но и задачу замещения, если в момент выполнения шага свободных блоков в памяти не окажется. После выполнения данной работы, которую можно назвать «проецированием» виртуальной страницы на физическую, в элемент ТС с номером \\( k' \\) заносится номер найденной физической страницы, соответствующей распределенному блоку оперативной памяти. Признак «отсутствие в оперативной памяти» сбрасывается в 0. Осуществляется обращение к шагу 2.\n4. Заменить в двоичном изображении виртуального адреса в \\( (n-m) \\) разрядах значение \\( k' \\) на \\( k \\)."} ,{"tag":"время преобразования адресов t_pr","text":"Практическая реализация рассмотренного алгоритма преобразования требует решения принципиального вопроса: сокращения времени преобразования виртуального адреса в физический \\( t_{\\text{пр}} \\). Пусть в оперативной памяти находятся таблица заданий (ТЗ) и все таблицы страниц (ТС). В ТЗ каждая строка содержит номер задания и ссылку на начальный адрес соответствующей ТС. Тогда\n\\[t_{\\text{пр}} = t_{обр} \\ \\text{оп} \\ (\\text{ТЗ}) + t_{обр} \\ \\text{оп} \\ (\\text{ТС}).\\]"} ,{"tag":"оптимизация обращения к таблице заданий (ТЗ)","text":"I. Уменьшение влияния обращения к ТЗ на время выполнения команды.\nПри выполнении каждого задания к ТЗ, хранящейся в ОП, можно обращаться лишь один раз. При этом строка ТЗ посылается на хранение в специальный регистр РАТ (регистр адреса таблицы). Содержание регистра во время выполнения задания (от его инициации до прерывания или от и"}],
[{"tag":"первый путь размещения таблицы страниц в регистровой памяти","text":"Первый путь: размещение всех ТС в регистровой памяти (РП). Здесь так же, как и при обращении к ТЗ, \\( t_{обр} \\text{рп} \\ll t_{обр} \\text{оп} \\), где \\( t_{обр} \\text{рп} \\) — время обращения к регистровой памяти."},{"tag":"стоимость размещения таблицы страниц в регистровой памяти","text":"Но данный путь не реализуем из-за высокой стоимости такого решения по следующим причинам: стойкость хранения бита в регистровой памяти на интегральных схемах в 100—200 раз выше стоимости хранения в ОЗУ на ферритовых сердечниках и в 10 раз — в полупроводниковых ЗУ; требуется большая емкость регистровой памяти. Так, для ЕС ЭВМ виртуальное адресное пространство задания равно 16 000 К байт. Допустим каждая страница имеет длину в 4 К байт, тогда адресное пространство задания может содержать до 4000 страниц. Если для каждой строки ТС требуется формат в 2 байт, то только для ТС одного задания потребуется 8000 байт регистровой памяти. Если допустить, что максимальное число заданий, исполняемых параллельно, равно 10, то для размещения ТС потребуется память в 80 000 байт = 80 К байт. Для сравнения реальная оперативная память эксплуатируемых моделей ЕС ЭВМ средней производительности имеет емкость порядка 512 К байт."},{"tag":"второй путь: регистровая память для одной ТС","text":"**Второй путь:** включение в состав ЭВМ регистровой памяти с емкостью, достаточной для размещения только одной ТС. Очевидно, что емкость такой РП должна определяться предельным значением виртуального адресного пространства. Такой путь нереден в прикладном плане. Обратимся для примера к техническим характеристикам МВК «Эльбрус». Виртуальное адресное пространство \\( N_B = 2^{32} \\) слов. Если взять размер страницы \\( L = 2^{9} \\) слов, то потребуется таблица страниц, содержащая \\( 2^{23} \\) строк. Если допустить, что строка ТС занимает одно слово оперативной памяти, то размер ТС будет в 8 раз превосходить объем оперативной памяти МВК «Эльбрус», равный \\( 2^{20} \\) слов."},{"tag":"третий путь: ограниченная емкость регистровой памяти","text":"**Третий путь:** использование регистровой памяти, емкость которой соответствует 10—30 строкам ТС. Возникает вопрос: почему возможно такое сокращение емкости РП при сохранении объема виртуального адресного пространства? Существуют объективные предпосылки такого решения. Первая предложилка. ЭВМ со страничным распределением памяти должна гарантировать возможность использования максимального виртуального адресного пространства. Но реально большинство заданий использует лишь часть максимального адресного пространства. Поэтому построение РП из расчета на максимальное адресное пространство при реальном использовании только его части является экономически не оправданным решением. Вторая предложилка. Анализ процесса выполнения программ и многочисленные исследования этого процесса показали, что для подавляющего большинства программ характерно свойство локальности. Различают два вида локальности."},{"tag":"принцип локальности","text":"Локальность во времени. Если при выполнении программы произошло обращение к какой‑то странице, то велика вероятность того, что в ближайшее время вновь произойдет обращение к этой же странице. Локальность в пространстве. Это свойство определяется естественным характером выполнения программы. Так, если выполняемая команда выбирается из ячейки с адресом \\( k+l \\), то высока вероятность того, что следующая команда будет выбрана из ячейки \\( k+l+1 \\). Соответственно в ограниченный отрезок времени обращение будет происходить не ко всем возможным страницам, а только к одной или ограниченной их части."},{"tag":"рабочее множество страниц","text":"На основании свойств локальности можно утверждать, что для любой программы в любой момент \\( t \\) существует так называемое рабочее множество страниц \\( W(t, \\Delta t) \\), определяющее страницы, которые потребуются программе при её исполнении за время \\( \\Delta t \\). Обозначим количество страниц в множестве \\( \\omega(t, \\Delta t) \\); максимальное количество строк в ТС, определяемое виртуальным адресным пространством, \\( K \\). Тогда при малых значениях \\( \\Delta t \\) \\[ \\omega(t, \\Delta t) \\ll K. \\] Это неравенство справедливо даже в том случае, когда вместо \\( K \\) возьмём не максимальное, а среднее количество строк \\( K_{cp} \\) в ТС программы, т. е. \\( \\omega(t, \\Delta t) \\ll K_{cp} \\). Объективность существования такого неравенства и определяет допустимость использования РП ограниченной емкости для хранения строк ТС."},{"tag":"структура полной таблицы страниц и ассоциативная память","text":"**Прикладные вопросы уменьшения влияния обращения к ТС на время выполнения команды за счет использования регистровой памяти ограниченной емкости.** Структура полной ТС, находящейся в ОП, упорядочена (рис. 4.13, \\( a \\)). Все её строки упорядочены по номеру виртуальных страниц от 1 до \\( K' \\). Выбор любой строки легко осуществляется в данном случае в ЗУ с традиционной прямой адресацией. Допустим, для хранения строк ТС используется РП ограниченной емкости, например, содержащая четыре регистра (рис. 4.13, \\( b \\)). В этой памяти хранится лишь часть строк ТС, а именно строки, соответствующие страницам с номерами 2, 15, 10 и 37. В данном случае, используя РП с прямой адресацией, легко выбрать один из четырёх регистров. Но выбрать строку с номером страницы, равным, допустим, 2 или 37, невозможно. Для этого необходима другая организация памяти — ассоциативная. В ней обращение происходит не по номеру регистра, а по содержанию одного из полей ассоциативного регистра. Каждый такой регистр имеет три поля (рис. 4.14). В формате полей \\( I \\) и \\( II \\) размещается строка ТС. В поле \\( I \\) размещается номер виртуальной страницы, к которой производится обращение. В поле \\( II \\) размещается номер физической страницы. Поле \\( III \\) содержит управляющую информацию."},{"tag":"схема преобразования виртуального адреса","text":"Схема преобразования виртуального адреса в физический при страничной организации памяти представлена на рис. 4.16. Здесь смещение \\( R \\) из регистра виртуального адреса \\( P_{eBa} \\) на регистр физического адреса \\( P_{dpa} \\) передается без изменений. При каждом преобразовании код поля \\( k' \\) \\( P_{eBa} \\) поступает на схемы сравнения ассоциативных регистров. На этом этапе возможны два случая. Первый случай — в одном из ассоциативных регистров имеется строка ТС с преобразуемым \\( k' \\). Содержимое поля \\( II \\) этого регистра, где находится номер физической страницы \\( k \\), соответствующий номеру виртуальной страницы \\( k' \\), передается в \\( P_{dpa} \\). На этом преобразование заканчивается. Время преобразования в данном случае определяется временем обращения к ассоциативной РП — \\( t_{обр. АРП} \\). Так как \\( t_{обр. АРП} \\ll t_{обр. СП} \\), то фактически исключается влияние."}]"}],
[
    {
        "tag": "замещение в ассоциативных регистрах (ARP)",
        "text": "Ни в одном из ассоциативных регистров нет строки ТС с преобразуемым \\( k' \\). По коду номера виртуальной строки \\( k' \\) в ОП выбирают соответствующую строку ТС. Код этой строки, определяющий номер физической страницы \\( k \\), передается в \\( P_{2фa} \\) и одновременно вся строка, выбираемая из ОП, записывается в один из ассоциативных регистров. Время преобразования равно \\( t_{обрАРП} + t_{обрОП} \\). Оно не уменьшилось (даже немного увеличилось), но ряд последующих обращений будет происходить к строке ТС, которая находится в АРП и соответственно время последующих преобразований будет определяться \\( t_{обрАРП} \\). Рассмотренная схема преобразования с АРП, состоящей из нескольких регистров (8—16), широко используется на практике. В ряде работ показано, что при ограниченном количестве регистров АРП до 90% обращений происходит к ТС в АРП, а не к ТС в ОП. Все рассмотренное является основой преобразования виртуального адреса в физический. Помимо этого должны быть средства для определения номера ассоциативного регистра, куда помещается выбираемая из ОП строка ТС (см. второй случай работы схемы преобразования с АРП). Для решения такой задачи необходима соответствующая стратегия замещения кодов в регистрах АРП. Эта стратегия должна отвечать на вопрос: какие строки ТС, находящиеся в АРП, потребуются в будущем (начиная с момента \\( t \\)) при обслуживании задания? Получение этой информации позволит исключить затирание в АРП содержимого того регистра, которое потребуется в ближайшее время. Но такой прогноз, к сожалению, нереализуем. Все стратегии замещения основаны на анализе информации, характеризующей степень использования информации в регистрах АРП до момента \\( t \\). При реализации таких стратегий необходимо искать решения, требующие прежде всего минимальных временных затрат, совместимых со временем обращения к АРП. Такие требования могут быть обеспечены лишь при аппаратной реализации стратегий замещения. На практике реализуются стратегии, основанные на использовании информации, находящейся в управляющем поле III ассоциативных регистров. В частности, используется управляющее поле, содержащее один двоичный разряд. При помещении информации в ассоциативный регистр или при последующем считывании с него информации соответствующий бит поля III всегда переводится в состояние 1. Если во всех регистрах значение бита управляющего поля равно 1, оно автоматически изменяется на 0. Обращение на замещение происходит к тому регистру, у которого код поля III равен 0. Если несколько регистров имеют в управляющем поле код 0, то из них выбирают регистр с наименьшим порядковым номером. Рассмотренная схема преобразования реализуема при резидентном хранении ТС (всех ее элементов) в оперативной памяти."
    },
    {
        "tag": "сегментно-страничная организация виртуальной памяти",
        "text": "**Механизм преобразования адресов в виртуальной оперативной памяти на основе сегментно-страничной организации.** Рассмотрим случай структуризации, когда адресное пространство оперативной памяти структурировано страницами переменной длины в отличие от виртуального адресного пространства, которое структурировано страницами фиксированной длины L. При этом выполняется ограничение: длина физической страницы всегда меньше или равна длине виртуальной. Вместо табличного способа представления учетной информации наиболее часто используют таблично-списковый. В ряде случаев такой подход имеет ощутимые преимущества. Рассмотрим построение механизма преобразования, основанного на таблично-списковой форме представления учетной информации. Учетная информация представлена совокупностью списков. Каждый список описывает однотипные по некоторому признаку виртуальные страницы, которые были спроецированы на оперативную память. Списки упорядочены в учетной таблице. Упорядочение чаще всего проводится с помощью алгоритма хэширования. Алгоритм хэширования основан на использование некоторой функции расстановки h(x). Значение функции различно для разных списков и одинаково для всех элементов, находящихся в одном списке. Учетная информация о списках (ссылки на списки) упорядочена в соответствии со значениями функции расстановки. Обращение к учетной информации о требуемой виртуальной странице — двухэтапное. По значению функции расстановки через учетную таблицу обеспечивается доступ к конкретному списку. Далее организуется поиск требуемой учетной информации в выбранном списке. Существенным моментом для обеспечения эффективного поиска учетной информации является выбор подходящей функции расстановки. В качестве возможного варианта рассмотрим подход, принятый при построении функции расстановки h(x) в МВК «Эльбрус». В отношении виртуального странично-структурированного адресного пространства, куда «погружаются» массивы данных, вводится еще один уровень структуризации. Все пространство представляется как последовательность смежных пронумерованных в сквозном порядке сегментов. В каждый сегмент входит одинаковое число страниц. Страницы в сегменте имеют собственную нумерацию, начиная с нуля. Номер следует рассматривать как смещение страницы в сегменте, т. е. относительный номер страницы от начала сегмента. Следовательно, любой виртуальный адрес задается триадой \\( A_B = (D, R', R) \\), где \\( D \\) — номер сегмента, содержащего страницу со смещением \\( R' \\), в которой находится адресуемый элемент слова со смещением внутри страницы \\( R \\). Если выбрать число страниц в сегменте равным 2^p, то для получения значения виртуального адреса \\( A_B \\) требуется произвести операцию конкатенации в отношении обрабатываемых компонентов \\( D, R', R \\). При изображении виртуального адреса в \\( n \\)-разрядном слове младшие \\( k \\) разрядов — это поле для изображения смещения \\( R \\) при длине страницы \\( L = 2^k \\) слов. Следующие \\( p \\) разрядов — это поле для изображения смещения в сегменте \\( R' \\) при длине сегмента \\( Z = 2^p \\) страниц. Старшие \\( n - (p + k) \\) разрядов — это поле для изображения номера сегмента. Виртуальное адресное пространство, имеющее три уровня структуризации, будем называть далее сегментно-структурированным. Для проведения хэширования в отношении такого пространства выполняется операция «свертывания». Происходит «проецирование» каждого сегмента виртуального пространства на новое адресное пространство, имеющее структуру, аналогичную структуре одного сегмента. Новое пространство образует последовательность смещения страниц в сегменте. Для краткости это пространство далее будем называть проекцией. Суть операции свертывания заключается в следующем. На каждый элемент проекции с номером \\( j(0 \\leq j \\leq 2^p - 1) \\) проецируются те элементы сегментов виртуального адресного пространства, т. е. те страницы, которые имеют смещение страницы в сегменте \\( R' = j \\). Для реализации проекции в оперативной памяти строят таблицу, число элементов (слов) в которой равно числу страниц в сегменте. Элементы таблицы пронумерованы в том же порядке, что и страницы в сегменте. Тогда каждый \\( j \\)-элемент таблицы представляет собой некоторый описатель всех страниц из различных сегментов, которые имеют одно и то же смещение в сегменте, равное \\( j \\). Эти страницы спроецированы на один такой элемент. Полученную таблицу будем называть далее таблицей страниц пользователя (ТСП). Пример «свертывания» виртуального адресного пространства на ТСП изображен на рис. 4.18. Из изложенного следует, что смещение страницы в сегменте можно использовать в качестве функции расстановки, так как процедура свертывания — это хэширование учетной информации о вир"
    }
]"}],
[{"tag":"рисунок 4.18","text":"Рис. 4.18. Процесс проецирования виртуального адресного пространства на таблицу страниц пользователя (ТСП)"},{"tag":"список сегментов","text":"- \\( M_1 \\) - \\( M_2 \\) - \\( M_3 \\) - \\( M_4 \\) - \\( M_5 \\) - \\( M_6 \\) - \\( M_7 \\) - \\( M_8 \\) - \\( M_9 \\) - \\( M_10 \\) - \\( M_11 \\) - \\( M_12 \\) - \\( M_13 \\) - \\( M_14 \\) - \\( M_15 \\) - \\( M_16 \\) - \\( M_17 \\) - \\( M_18 \\) - \\( M_19 \\) - \\( M_20 \\) - \\( M_21 \\) - \\( M_22 \\) - \\( M_23 \\) - \\( M_24 \\) - \\( M_25 \\) - \\( M_26 \\) - \\( M_27 \\) - \\( M_28 \\) - \\( M_29 \\) - \\( M_30 \\) - \\( M_31 \\) - \\( M_32 \\) - \\( M_33 \\) - \\( M_34 \\) - \\( M_35 \\) - \\( M_36 \\) - \\( M_37 \\) - \\( M_38 \\) - \\( M_39 \\) - \\( M_40 \\) - \\( M_41 \\) - \\( M_42 \\) - \\( M_43 \\) - \\( M_44 \\) - \\( M_45 \\) - \\( M_46 \\) - \\( M_47 \\) - \\( M_48 \\) - \\( M_49 \\) - \\( M_50 \\) - \\( M_51 \\) - \\( M_52 \\) - \\( M_53 \\) - \\( M_54 \\) - \\( M_55 \\) - \\( M_56 \\) - \\( M_57 \\) - \\( M_58 \\) - \\( M_59 \\) - \\( M_60 \\) - \\( M_61 \\) - \\( M_62 \\) - \\( M_63 \\) - \\( M_64 \\) - \\( M_65 \\) - \\( M_66 \\) - \\( M_67 \\) - \\( M_68 \\) - \\( M_69 \\) - \\( M_70 \\) - \\( M_71 \\) - \\( M_72 \\) - \\( M_73 \\) - \\( M_74 \\) - \\( M_75 \\) - \\( M_76 \\) - \\( M_77 \\) - \\( M_78 \\) - \\( M_79 \\) - \\( M_80 \\) - \\( M_81 \\) - \\( M_82 \\) - \\( M_83 \\) - \\( M_84 \\) - \\( M_85 \\) - \\( M_86 \\) - \\( M_87 \\) - \\( M_88 \\) - \\( M_89 \\) - \\( M_90 \\) - \\( M_91 \\) - \\( M_92 \\) - \\( M_93 \\) - \\( M_94 \\) - \\( M_95 \\) - \\( M_96 \\) - \\( M_97 \\) - \\( M_98 \\) - \\( M_99 \\) - \\( M_100 \\) - \\( M_101 \\) - \\( M_102 \\) - \\( M_103 \\) - \\( M_104 \\) - \\( M_105 \\) - \\( M_106 \\) - \\( M_107 \\) - \\( M_108 \\) - \\( M_109 \\) - \\( M_110 \\) - \\( M_111 \\) - \\( M_112 \\) - \\( M_113 \\) - \\( M_114 \\) - \\( M_115 \\) - \\( M_116 \\) - \\( M_117 \\) - \\( M_118 \\) - \\( M_119 \\) - \\( M_120 \\) - \\( M_121 \\) - \\( M_122 \\) - \\( M_123 \\) - \\( M_124 \\) - \\( M_125 \\) - \\( M_126 \\) - \\( M_127 \\) - \\( M_128 \\) - \\( M_129 \\) - \\( M_130 \\) - \\( M_131 \\) - \\( M_132 \\) - \\( M_133 \\) - \\( M_134 \\) - \\( M_135 \\) - \\( M_136 \\) - \\( M_137 \\) - \\( M_138 \\) - \\( M_139 \\) - \\( M_140 \\) - \\( M_141 \\) - \\( M_142 \\) - \\( M_143 \\) - \\( M_144 \\) - \\( M_145 \\) - \\( M_146 \\) - \\( M_147 \\) - \\( M_148 \\) - \\( M_149 \\) - \\( M_150 \\) - \\( M_151 \\) - \\( M_152 \\) - \\( M_153 \\) - \\( M_154 \\) - \\( M_155 \\) - \\( M_156 \\) - \\( M_157 \\) - \\( M_158 \\) - \\( M_159 \\) - \\( M_160 \\) - \\( M_161 \\) - \\( M_162 \\) - \\( M_163 \\) - \\( M_164 \\) - \\( M_165 \\) - \\( M_166 \\) - \\( M_167 \\) - \\( M_168 \\) - \\( M_169 \\) - \\( M_170 \\) - \\( M_171 \\) - \\( M_172 \\) - \\( M_173 \\) - \\( M_174 \\) - \\( M_175 \\) - \\( M_176 \\) - \\( M_177 \\) - \\( M_178 \\) - \\( M_179 \\) - \\( M_180 \\) - \\( M_181 \\) - \\( M_182 \\) - \\( M_183 \\) - \\( M_184 \\) - \\( M_185 \\) - \\( M_186 \\) - \\( M_187 \\) - \\( M_188 \\) - \\( M_189 \\) - \\( M_190 \\) - \\( M_191 \\) - \\( M_192 \\) - \\( M_193 \\) - \\( M_194 \\) - \\( M_195 \\) - \\( M_196 \\) - \\( M_197 \\) - \\( M_198 \\) - \\( M_199 \\) - \\( M_200 \\) - \\( M_201 \\) - \\( M_202 \\) - \\( M_203 \\) - \\( M_204 \\) - \\( M_205 \\) - \\( M_206 \\) - \\( M_207 \\) - \\( M_208 \\) - \\( M_209 \\) - \\( M_210 \\) - \\( M_211 \\) - \\( M_212 \\) - \\( M_213 \\) - \\( M_214 \\) - \\( M_215 \\) - \\( M_216 \\) - \\( M_217 \\) - \\( M_218 \\) - \\( M_219 \\) - \\( M_220 \\) - \\( M_221 \\) - \\( M_222 \\) - \\( M_223 \\) - \\( M_224 \\) - \\( M_225 \\) - \\( M_226 \\) - \\( M_227 \\) - \\( M_228 \\) - \\( M_229 \\) - \\( M_230 \\) - \\( M_231 \\) - \\( M_232 \\) - \\( M_233 \\) - \\( M_234 \\) - \\( M_235 \\) - \\( M_236 \\) - \\( M_237 \\) - \\( M_238 \\) - \\( M_239 \\) - \\( M_240 \\) - \\( M_241 \\) - \\( M_242 \\) - \\( M_243 \\) - \\( M_244 \\) - \\( M_245 \\) - \\( M_246 \\) - \\( M_247 \\) - \\( M_248 \\) - \\( M_249 \\) - \\( M_250 \\) - \\( M_251 \\) - \\( M_252 \\) - \\( M_253 \\) - \\( M_254 \\) - \\( M_255 \\) - \\( M_256 \\) - \\( M_257 \\) - \\( M_258 \\) - \\( M_259 \\) - \\( M_260 \\) - \\( M_261 \\) - \\( M_262 \\) - \\( M_263 \\) - \\( M_264 \\) - \\( M_265 \\) - \\( M_266 \\) - \\( M_267 \\) - \\( M_268 \\) - \\( M_269 \\) - \\( M_270 \\) - \\( M_271 \\) - \\( M_272 \\) - \\( M_273 \\) - \\( M_274 \\) - \\( M_275 \\) - \\( M_276 \\) - \\( M_277 \\) - \\( M_278 \\) - \\( M_279 \\) - \\( M_280 \\) - \\( M_281 \\) - \\( M_282 \\) - \\( M_283 \\) - \\( M_284 \\) - \\( M_285 \\) - \\( M_286 \\) - \\( M_287 \\) - \\( M_288 \\) - \\( M_289 \\) - \\( M_290 \\) - \\( M_291 \\) - \\( M_292 \\) - \\( M_293 \\) - \\( M_294 \\) - \\( M_295 \\) - \\( M_296 \\) - \\( M_297 \\) - \\( M_298 \\) - \\( M_299 \\) - \\( M_300 \\) - \\( M_301 \\) - \\( M_302 \\) - \\( M_303 \\) - \\( M_304 \\) - \\( M_305 \\) - \\( M_306 \\) - \\( M_307 \\) - \\( M_308 \\) - \\( M_309 \\) - \\( M_310 \\) - \\( M_311 \\) - \\( M_312 \\) - \\( M_313 \\) - \\( M_314 \\) - \\( M_315 \\) - \\( M_316 \\) - \\( M_317 \\) - \\( M_318 \\) - \\( M_319 \\) - \\( M_320 \\) - \\( M_321 \\) - \\( M_322 \\) - \\( M_323 \\) - \\( M_324 \\) - \\( M_325 \\) - \\( M_326 \\) - \\( M_327 \\) - \\( M_328 \\) - \\( M_329 \\) - \\( M_330 \\) - \\( M_331 \\) - \\( M_332 \\) - \\( M_333 \\) - \\( M_334 \\) - \\( M_335 \\) - \\( M_336 \\) - \\( M_337 \\) - \\( M_338 \\) - \\( M_339 \\) - \\( M_340 \\) - \\( M_341 \\) - \\( M_342 \\) - \\( M_343 \\) - \\( M_344 \\) - \\( M_345 \\) - \\( M_346 \\) - \\( M_347 \\) - \\( M_348 \\) - \\( M_349 \\) - \\( M_350 \\) - \\( M_351 \\) - \\( M_352 \\) - \\( M_353 \\) - \\( M_354 \\) - \\( M_355 \\) - \\( M_356 \\) - \\( M_357 \\) - \\( M_358 \\) - \\( M_359 \\) - \\( M_360 \\) - \\( M_361 \\) - \\( M_362 \\) - \\( M_363 \\) - \\( M_364 \\) - \\( M_365 \\) - \\( M_366 \\) - \\( M_367 \\) - \\( M_368 \\) - \\( M_369 \\) - \\( M_370 \\) - \\( M_371 \\) - \\( M_372 \\) - \\( M_373 \\) - \\( M_374 \\) - \\( M_378 \\) - \\( M_379 \\) - \\( M_381 \\) -381 \\)"},"tag":"алгоритм преобразования виртуального адреса","text":"в списке. Следовательно, анализируя по порядку \\( i \\)-й элемент списка, можно узнать базовый адрес физической страницы, которая является \\((i+1)\\)-й по порядку в списке. Для проведения преобразования виртуального адреса в физический необходимо в состав \\( i \\)-го линка ввести поле, где хранилось бы значение номера сегмента \\( D \\). Это номер того сегмента, в котором находится виртуальная страница, спроецированная на \\((i+1)\\)-ю физическую страницу анализируемого списка.\n\nТаким образом, каждый линк является первым элементом области оперативной памяти, отведенной для размещения физической страницы. Линк содержит учетную информацию двух типов; описывает ту страницу, с которой он физически смежен; описывает соседнюю в списке (в порядке «пропивки» элементов списка) физическую страницу, которая на нее спроецирована.\n\nИсходя из назначения и состава линков, таблицу страниц пользователя (ТСП) можно формировать также из линков. В ТСП будут собраны только линки и будут отсутствовать области, в которых должны находиться смежные с линками страницы. Чтобы выделить эту особенность в линке, находящемся в ТСП, значение поля «длина страницы» следует установить в 0, а линку будет присвоен порядковый номер \\( i=0 \\) в списке линков, который он начинает.\n\nРассмотрим далее алгоритм преобразования адресов, использующий таблично-списковую форму представления учетной информации о распределении «виртуальных» страниц в оперативной памяти. Исходной информацией для работы алгоритма является виртуальный адрес слова в форме \\( A_B = (D, R', R) \\). Необходимо получить физический адрес слова, т. е. адрес слова в оперативной памяти. Алгоритм составляет такая последовательность действий.\n1. Обратиться к ТСП и выбрать из нее элемент, находящийся по адресу: \\( A = <B> + R' \\), где \\( B \\) — регистр, содержащий базовый адрес ТСП.\n2. Проанализировать — содержит ли выбранный элемент (напомним — это линк) в своем составе номер искомого сегмента \\( D \\).\n3. Если номер сегмента найден, то выбрать из анализируемого линка адресную ссылку на следующий элемент списка. Это и будет искомый базовый адрес физической страницы, на которую спроецирована рассматриваемая виртуальная.\n4. К найденному базовому адресу \\( B_0 \\) следует прибавить смещение в странице (согласно принципу «база — плюс — смещение»): \\( A_0 = B_0 + R \\). Это и будет искомый физический адрес слова. Преобразование адреса закончено.\n5. Если номер сегмента не найден, то выбрать адрес следующего линка в списке.\n6. Если не обнаружен конец анализируемого списка линков, выбрать по указанному адресу очередной линк. Обратиться к шагу 2."},{"tag":"использование ассоциативной памяти","text":"Анализ представленного алгоритма свидетельствует о том, что операции по преобразованию виртуального адреса в физический могут быть как «короткими», так и «длинными». При реализации алгоритма, как правило, вводят аппаратную поддержку для уменьшения времени на преобразование. Так, в МВК «Эльбрус» предусмотрено использование ассоциативной памяти, построенной на 32 регистрах. После нахождения по описанному алгоритму базового адреса искомой физической страницы в один из регистров ассоциативной памяти заносится информация, необходимая для дальнейшего быстрого преобразования адресов: номер виртуальной страницы и базовый адрес физической страницы, на которую спроецирована виртуальная.\n\nКаждый раз, по мере преобразования адреса сначала производится обращение к ассоциативной памяти. При нахождении в одном из элементов этой памяти (что делается очень быстро) номера виртуальной искомой страницы из этого же элемента считывается значение базового адреса физической страницы. Далее, используя принцип «база — плюс — смещение», находят физический адрес искомого слова.\n\nЕсли в ассоциативной памяти поиск был безуспешным, то начинается выполнение «длинной» операции поиска — через ТСП, как было показано. «Самая длинная» операция преобразования выполняется в том случае, когда поиск в списке через ТСП будет безуспешным. Тогда, как было указано, необходимо дополнительно решать задачи размещения и перемещения."},{"tag":"схема преобразования виртуального адреса при сегментно-страничной организации","text":"Рассмотрим другой механизм преобразования виртуального адреса в физический для сег"}],
[
    {
        "tag": "случай III ассоциативная память",
        "text": "Случай III. Есть искорки регистр в блоке АРП2 (совпадение по коду \\( D \\)). Код поля II выбранного регистра определяет адрес оперативной памяти,\n\n|    | Адресное поле ТС | Адресное поле ТСет | Рабочее поле | Управляющее поле | |---|---|---|---|---| | I    | II    | III    | IX    |    |\n\n5) Адресное поле ТСет Рабочее поле Управляющее поле\n\n|    | I    | II    | III    | |---|---|---|---| |    |    |    |    |\n\nРис. 4.20. Форматы регистров ассоциативной памяти: \\[ a - \\text{для} \\quad \\text{блока} \\quad \\text{АРП1}; \\quad б - \\text{для} \\quad \\text{блока} \\quad \\text{АРП2} \\]\n\nгде находится начало соответствующей ТС. Происходит формирование, адреса оперативной памяти, где находится искомая строка ТС. При этом\n\nадрес начала ТС (код поля II регистра АРП2)\n\n\\[K \\text{ (код поля } Pr_{Ba}\\)\\]\n\nадрес искомой строки ТС в оперативной памяти.\n\nПо полученному адресу выбираем из ОП строку ТС. Код поля III этой строки направляем в \\(Pr_{Ba}\\), одновременно всю строку помещаем в АРП1, решая при этом задачу выбора из регистров АРП1 того регистра, код которого будет затираться. В данном случае \\(t_{\\text{пр}} = t_{обр} \\text{АРП1} + t_{обр} \\text{АРП2} + t_{обр} \\text{ОП}\\). Здесь не удалось исключить обращение к ТС, находящейся в ОП, но высока вероятность того, что ряд последующих преобразований произойдет без обращения к ОП."
    },
    {
        "tag": "случай II2 ассоциативная память",
        "text": "Случай II2. В АРП2 нет искомого регистра. Необходимо обращение к ОП, к таблице сегментов. Происходит формирование адреса ОП, где хранится искомая строка Т Сет. Для этого\n\nадрес начала Т Сет (код хранится в РА Т Сет)\n\n\\[D \\text{ (код поля } Pr_{Ba}\\)\\]\n\nадрес искомой строки Т Сет в оперативной памяти.\n\nПо полученному адресу выбираем из ОП строку ТСет. Код этой строки помещаем в АРП2, предварительно решая задачу выбора одного из регистров АРП2, код которого будет затираться.\n\nС использованием кода поля II выбранной строки (где хранится адрес начала требуемой ТС) формируется адрес ОП (где хранится искомая строка ТС). При этом\n\nадрес начала ТС\n\n\\[K \\text{ (код поля } Pr_{Ba}\\)\\]\n\nадрес искомой строки ТС в оперативной памяти.\n\nПо полученному адресу из ОП выбирается код искомой строки ТС. Код поля II этой строки направляется в \\(Pr_{Ba}\\) и одновременно код всей строки помещается в один из регистров АРП1. Здесь так же, как и в предшествующих случаях, будет решаться задача выбора одного из регистров АРП1, код которого будет затираться."
    },
    {
        "tag": "время преобразования формулы",
        "text": "Общее время преобразования в случае II2\n\n\\[t_{\\text{пр}} - t_{обр} \\text{АРП1} + t_{обр} \\text{АРП2} - t_{обр} \\text{ОП} \\text{ (ТСет)} + t_{обр} \\text{ОП} \\text{ (ТСr)}.\\]\n\nЗдесь не исключено обращение к ОП как к Т Сет, так и к ТС. Но, как и в случае III, высока вероятность исключения подобных обращений к ОП при последующих преобразованиях."
    },
    {
        "tag": "виртуальная оперативная память эффективность",
        "text": "Приувведении виртуальной оперативной памяти стремятся увеличить системную эффективность использования ЭВМ. В конечном счете система эффективность определяется степенью мультипрограммирования, т. е. усредненным числом одновременно работающих в системе процессов-пользователей виртуальной памяти при максимально возможной нагрузке используемых ресурсов. Успешные решения каждой из задач размещения, перемещения, преобразования, замещения, рассмотренные в отдельности, способствуют увеличению системной эффективности. Однако существует множество факторов, которые можно рассматривать как параметры в отношении системы с виртуальной памятью и которые позволяют настроить систему в условиях обработки конкретного потока заданий как на эффективную работу, так и на крайне непроизводительную. Среди них прежде всего следует учитывать технические характеристики, такие, как число и тип внешних запоминающих устройств, используемых в качестве архивной среды, объем оперативной памяти, скорость передачи информации и т. д. Весьма важны структурно-логические характеристики программ и данных: принятый способ структуризации, объемы различных структурных единиц, количество активизированных программ отдельных пользователей, интенсивность использования ввода—вывода и т. д. Наиболее ощутимо влияние этих факторов при решении задач замещения."
    },
    {
        "tag": "задача замещения ресурсы",
        "text": "При решении задачи замещения необходимо решить задачу распределения не одного ресурса, как в рассмотренных ранее задачах, а нескольких взаимосвязанных ресурсов. Эта задача решается в составе системы обработки данных, которая состоит из одного или нескольких процессов, каналов, устройств внешней памяти, а также оперативной памяти. Этой совокупностью ресурсов управляют системные процессы, развивающиеся для поддержания в системе виртуального ресурса — виртуальной оперативной памяти. В этой системе развиваются и пользовательские процессы, вступая в конфликт с системными при использовании необходимых для них ресурсов, что особенно ощутимо в отношении центрального процессора. Чем больше времени его используют системные процессы для организации работы виртуальной памяти, тем меньше времени уделяется пользовательским процессам. В любой ОС должна быть найдена и обоснована некоторая согласованная загрузка ресурсов для совокупности системных и пользовательских процессов.\n\nПри построении виртуальной оперативной памяти необходимо прежде всего учитывать основной конфликт между потребностями пользователей в оперативной памяти и ее ограниченными размерами. По мере работы процессов эпизодически возникает ситуация, когда ресурс оперативной памяти становится полностью исчерпан. Вся память распределена, а одному из активных процес-"
    }
]"}],
[{"tag":"страничное прерывание и замещение","text":"Структурирование текстов, контроль за принадлежностью команд и данных страницам, находящимся в оперативной памяти или архивной среде, осуществляются автоматически, без участия пользователя. Автоматически контролируется и отсутствие требуемой страницы в оперативной памяти. Если адресуемая команда или данные принадлежат виртуальной странице, которая еще не была спроецирована на пространство оперативной памяти, то возникает так называемое _страничное прерывание_ исполняемой программы. Это сигнал о необходимости выделения в адресном пространстве оперативной памяти страницы, на которую будет произведено проецирование. Поиск требуемой страницы основан на решении задачи размещения. Если в результате обнаруживается отсутствие свободной памяти, то начинает решаться задача замещения, с тем чтобы освободить некоторую занятую область оперативной памяти и удовлетворить в результате требование на распределение памяти по страничному прерыванию."},{"tag":"стратегии замещения","text":"**Стратегии замещения.** Наиболее простой и реализуемый на практике подход в решении задачи замещения — приостановление развития активного процесса, потребовавшего страницу оперативной памяти в ситуации, когда вся память распределена. Процессор передается одному из процессов, находящемуся в состоянии готовности и, возможно, уже имеющему страницы в оперативной памяти. В отношении приостановленного процесса могут быть выполнены различные действия.\n\nНапример, можно использовать простейшее правило: страницы, распределенные приостановленному процессу, не подвергаются никаким воздействиям. Это правило рассчитано на то, что процесс приостанавливается на сравнительно короткое время. Другой подход — перемещение содержания физических страниц приостановленного процесса в архивную среду. Такой подход более рациональен с точки зрения системы, так как увеличивает ресурс оперативной памяти для тех процессов, которые будут активизированы после отработки страничного прерывания."},{"tag":"несправедливость и тупиковая ситуация","text":"Общим недостатком этих подходов является явная предвзятость стратегии распределения ресурсов в отношении процесса — «виновника» страничного прерывания. Этот процесс всякий раз в ситуации занятости оперативной памяти будет незаслуженно наказан — лишен процессора. Наказание явно несправедливое, так как ситуация занятости оперативной памяти сложилась динамически и с участием других процессов. Наказан же тот, кто обнаружил эту ситуацию. Кроме того, первому подходу свойствен еще один недостаток. Существует ненулевая вероятность попадания процессов в тупиковую ситуацию, возникающую в том случае, если в ситуации заполнения памяти всякий активизируемый процесс, имею-\n\n===== Page 27 =====\n\nции страницы в оперативной памяти, будет требовать новую страницу. Поскольку страницу некуда помещать (вся память распределена), то активный процесс приостановится. Так, по очереди могут быть активизированы и переведены в приостановленное состояние все процессы, находящиеся в состоянии готовности в момент первого обнаружения заполнения памяти. Ни один процесс нельзя запустить в активное состояние, так как нет памяти. Все процессы находятся в тупике."},{"tag":"алгоритмы замещения","text":"На практике более часто используют другие подходы, позволяющие поставить развивающиеся процессы в достаточно справедливые условия при использовании ресурсов центрального процессора и оперативной памяти. По мере возникновения страничного прерывания в ситуации, когда оперативная память полностью распределена, из памяти принудительно вытесняется в архивную среду содержимое только одной страницы. Это не обязательно страница, принадлежащая процессу, вызвавшему прерывание. Выбор страницы-кандидата на вытеснение среди прочих страниц проводят по различным правилам, руководствуясь различными соображениями. Наиболее известные из них следующие:\n\nFIFO — удаляется та страница, которая раньше всех среди прочих была распределена какому-либо процессу; случайная выборка — выбор кандидата на удаление производится случайным образом;\n\nLRU — замещается наименее активная страница, т. е. та, к которой за контролируемый период дольше всех не было обращений. Известна идеальная стратегия замещения, предложенная Билели [16, 29, 31]. Согласно этому алгоритму при необходимости замещения выбирается та страница, к которой в будущем дольше всех не будет обращений. В силу необходимости предсказания будущего характера ссылок этот алгоритм практически нереализуем."},{"tag":"пробуксовка","text":"Явление «пробуксовки». Способы уменьшения потерь. Алгоритм замещения выбирают исходя из стремления уменьшить число передач страниц между оперативной памятью и архивной средой. При некоторой критической степени мультипрограммирования в системе может возникнуть критическая ситуация, выражающаяся в том, что процессам хронически не хватает ресурса оперативной памяти — каждый процесс не обеспечивается необходимым множеством страниц в течение достаточно длительного времени. Резко может возрасти интенсивность страничных прерываний и, как следствие, интенсивность движения страниц между архивной средой и оперативной памятью. Пользовательские процессы попадают в весьма невыгодное состояние при распределении ресурса центрального процессора, называемое состоянием «голодания». Системные процессы постоянно перехватывают процессор у пользовательских процессов. Резкая активизация системных процессов в свою очередь вызвана необходимостью более частого выполнения задачи заме\n\n===== Page 28 =====\n\nщения и перемещения. Это сводится, в конечном счете, к увеличению интенсивности перераспределения оперативной памяти, к/активизации работы каналов, к необходимости перепланирования распределения ресурсов центрального процессора среди пользовательских процессов. Деятельность системы обработки данных в такой ситуации резко вырождается. Именно поэтому такую ситуацию и называют пробуксоном. В самом деле, хотя ресурсы центрального процессора, оперативной и внешней памяти, канала распределяются и интенсивно используются, но в результате не выполняется полезна работа, связанная с развитием пользовательских процессов. Система бункует на месте, т. е. работает сама на себя. Известны экстремальные случаи, когда в режиме пробуксонка система тратила на себя до 99% времени процессора!"},{"tag":"контроль загрузки и борьба с пробуксовкой","text":"Несмотря на то что алгоритмы замещения призваны уменьшать число передач страниц, они не могут сами по себе предотвратить пробуксонку. Для устранения этого явления или, по крайней мере, для уменьшения последствий от его проявления при построении виртуальной памяти используют ряд средств.\n\nНаиболее действенным средством, устраняющим пробуксонку, является контроль загрузки ЭВМ. В состав операционной системы вводят механизм, контролирующий и регулирующий число процессов, претендующих на оперативную память, с тем чтобы каждому процессу предоставить в оперативной памяти рабочее множество страниц. Если в системе интенсивность движения страниц доходит до некоторого крит"}],
[
    {
        "tag": "негативные проявления виртуальной памяти",
        "text": "К основным негативным проявлениям от использования виртуальной оперативной памяти относят следующие: определенное замедление при исполнении команд, связанное с необходимостью преобразования виртуального адреса в физический; введение в состав машины достаточно сложных дополнительных программно-аппаратных механизмов, что в результате повышает стоимость машины; возможное вырождение системы из-за несбалансированности ее характеристик и свойств обрабатываемых программ, ограничений по ресурсам оперативной и внешней памяти. Вырождение проявляется в увеличивающихся потерях памяти из-за внутренней или внешней фрагментации, в потерях процессорного времени вследствие появления пробуксовки."
    },
    {
        "tag": "режим SVS и виртуальная оперативная память в ЕС ЭВМ",
        "text": "§ 4.12. Виртуальная оперативная память в ЕС ЭВМ\n\nВ изложенном материале те или иные положения иллюстрировались на примере виртуальной памяти МВК «Эльбрус». В данном параграфе даются краткие сведения о построении виртуальной памяти в ЕС ЭВМ. В ЕС ЭВМ РЯД-2 введен режим мультипрограммной обработки (пакетной) заданий — режим SVS. Его основной особенностью в отличие от режимов MFT и MVT является использование при обработке программ виртуальной оперативной памяти. Введение такой памяти дало возможность снять ограничение на количество одновременно обрабатываемых заданий, существенно увеличить объем доступного адресного пространства для каждого из заданий, повысить эффективность использования оперативной памяти за счет снижения фрагментации и увеличения коэффициента перекрытия ее. При построении виртуальной памяти ЕС ЭВМ в качестве базовой использована сегментно-страничная организация адресных пространств. Виртуальное адресное пространство рассматривается как совокупность сегментов. Каждый сегмент имеет свой уникальный номер и состоит из страниц. Возможно использование страниц двух размеров — в 2 или 4 Кбайт. Допустимые размеры сегментов — 64 Кбайт или 1 Мбайт. Устанавливается ограничение на объем виртуального адресного пространства — 16 Мбайт, что одновременно устанавливает ограничение на максимально возможное количество сегментов, на которое можно разбить виртуальное адресное пространство, а именно 256. Возможно использование не одного, а нескольких виртуальных адресных пространств с указанной структурой. Суммарный объем этих адресных пространств в конечном счете определяется объемом архивной среды. В качестве архивной среды используются тома прямого доступа на дисках, на которых располагается специальный файл (набор данных в терминах ОС"
    },
    {
        "tag": "структура адресного пространства и физический адрес",
        "text": "Адресное пространство оперативной памяти странично-структурировано. Размер блока оперативной памяти равен размеру виртуальной страницы. Физический адрес в оперативной памяти с такой структурой адресного пространства определяется как конкапенсация номера блока и смещения в блоке."
    },
    {
        "tag": "механизм управления виртуальной памятью и супервизор страниц",
        "text": "Механизм управления виртуальной памятью программно-аппаратный. Основным компонентом программной части этого механизма является супервизор страниц. Он обеспечивает размещение информации на уровнях рабочей и архивной сред в соответствии с логикой выполнения программ, размещенных в сегментно-страничной виртуальной памяти. Основная функция супервизора страниц — решение задач размещения, замещения и перемещения. Для решения задачи преобразования в основном используются аппаратные средства. Вместе с тем подготовку решения этой задачи обеспечивают программные средства. Остановимся на этом вопросе несколько подробнее."
    },
    {
        "tag": "формирование запроса в режиме SVS и преобразование виртуального адреса",
        "text": "В режиме SVS, как и в режиме МVT, на языке JCL должен быть сформирован запрос на зону памяти для исполнения задания (или шага задания). Отличие заключается в том, что в режиме SVS этот запрос подразумевает выделение зоны не в оперативной, а в виртуальной памяти. Затем организуется преобразование адресных частей команд в программе, указанной в одном или более пунктов задания. Такая переработка, по сути, является процедурой «погружения» текста программы в адресное пространство зоны, выделенной в виртуальном адресном пространстве для исполнения задания. В зависимости от расположения текста программы в этом адресном пространстве можно представить каждый адрес в форме виртуального. Виртуальный адрес состоит из трех смежных частей: номера сегмента, номера страницы, смещения в странице. Указанное преобразование текста программы проводит системная программа-загрузчик. Преобразованный указанным образом программный текст с помощью программы-загрузчика помещается в архивную среду — в файл SYS1.PAGE. Кроме того, эта система программа строит таблицу страниц для каждого сегмента в отведенной для задания зоне и устанавливает адресную ссылку на каждую такую таблицу из таблицы сегментов. Строится также таблица внешних страниц, в которой описывается расположение (постранично) программного текста в архивной среде. Указанные таблицы используются при решении задачи преобразования соответствующими аппаратными средствами. Причем по мере преобразования виртуальных адресов конкретного задания в физические устанавливаются адресная ссылка на соответствующую таблицу сегментов задания в специальный управляющий регистр \\( I \\)."
    },
    {
        "tag": "обработка страничного прерывания и алгоритм замещения",
        "text": "Механизм преобразования адресов стандартен, он был описан ранее в основных концепциях. При преобразовании в случае отсутствия требуемой страницы в оперативной памяти возникает страничное прерывание. В результате начинает работать супервизорная программа страничного обмена. Она выделяет в адресном пространстве оперативной памяти блок, куда должна быть перемещена требуемая страница из архивной среды. Для решение этой задачи размещения используется учетная информация о текущем состоянии блоков. Эта информация сосредоточена в специальных очередях. В системе различают шесть типов очередей.\n\nОдна из них описывает свободные в текущий момент блоки памяти. Если эта очередь в момент возникновения страничного прерывания не пуста, то именно из нее происходит выделение блока. В противном случае фиксируется полная занятость памяти и необходимо решать задачу замещения — выбирать какой-либо блок, который в текущий момент используется некоторым заданием, но может быть выбран в качестве кандидата на переиспользование.\n\nДля решения задачи замещения используются остальные четыре типа очередей. В основе решения этой задачи лежат два основополагающих принципа: 1) замещению подлежат те блоки (страницы, находящиеся в них), к которым дольше других не было обращения; 2) предпочтение при замещении страниц отдается тем из них, которые по мере пребывания в оперативной памяти не подвергались изменению. Для реализации этих принципов используются специальные аппаратные средства — два дополнительных бита в ключе защиты памяти: бит обращения и бит изменения. Эти биты устанавливаются и сбрасываются аппаратно. При любом виде обращения к странице, находящейся в блоке оперативной памяти, взводится (устанавливается в 1) бит обращения, а бит записи взводится, только если производится запись хотя бы в одну ячейку страницы. В зависимости от состояния этих битов блок становится на учет в одну из упомянутых ранее четырех очередей. Переустановка блоков по очереди происходит каждый раз по мере обращения к супервизору страниц.\n\nОдна из очередей, которая еще не упоминалась, служит для учета блоков, выделенных на текущем шаге работы супервизора для замещения новыми страницами из архивной среды. Блоки из этой очереди никогда не назначаются как кандидаты на замещение при возникновении очередного страничного прерывания."
    },
    {
        "tag": "перемещение страниц и взаимодействие с вводом‑выводом",
        "text": "Задача перемещения решается программой страничного обмена. Входной информацией для нее служит номер блока, определенный на предыдущем этапе обработки страничного прерывания, куда следует переместить требуемую страницу. Кроме того, при возникновении страничного прерывания в ячейку оперативной памяти с фиксированным адресом (144) аппаратно заносится виртуальный адрес требуемой страницы. По этому адресу через таблицу сегментов определяется в таблице внешних страниц адрес расположения требуемой страницы в архивной среде. В результате программа подготовки ввода—вывода страниц организует обращение к супервизору ввода—вывода для переноса требуемой страницы из архивной среды в рабочую. При этом предварительно определяется необходимость переноса содержания блока, который выбран в качестве кандидата на перенопользование, в архивную среду. Это будет иметь место в том случае, если бит изменения страницы в блоке был установлен в «1». При этом предварительно организуется перенос этой страницы из рабочей среды в архивную и лишь затем копирование требуемой страницы."
    },
    {
        "tag": "ассоциативная регистровая память в управлении виртуальной памятью",
        "text": "В механизме управления виртуальной памятью предусмотрены средства, которые могут способствовать сокращению времени преобразования адреса: основа таких средств — ассоциативная регистровая память, используемая для преобразования. Количество ассоциативных регистров зависит от модели машины и может достигать до 128 (ЕС-1060). Работа механизма ассоциативной памяти достаточно традиционна и не требует дополнительных пояснений."
    },
    {
        "tag": "разделение виртуального адресного пространства на фиксированную и динамическую области",
        "text": "Виртуальное адресное пространство распределяется по-разному в зависимости от информации, которая в него «погружается». В пространстве различают две области: фиксированную и динамическую. Такое разделение обусловлено различием информации, которая помещается в эти области. Фиксированная область используется для нужд операционной системы, а динамическая — для заданий пользователей и программ управления заданиями. Каждая из этих областей по-разному отображается на адресное пространство оперативной памяти. В частности, ядро ОС будет резидентно находиться в оперативной памяти. Имеется возможность для пользовательских заданий сокращать влияние страничного обмена на некоторые страницы. Для задач таких заданий могут быть выделены особые зоны виртуального адресного пространства. Таблицы сегментов и таблицы страниц для этих зон таковы, что виртуальные адреса совпадают с физическими. Кроме того, такие страницы могут быть зафиксированы на определенное время пребывания в оперативной памяти."
    },
    {
        "tag": "мониторинг интенсивности страничного обмена",
        "text": "При управлении виртуальной памятью имеется механизм, который позволит наблюдать за интенсивностью обмена (число перемещений страниц за заданный интервал времени). Если наблюдаемая интенсивность обмена превышает некоторое заданное значение, то производится приостановка задач с минимальным приоритетом до тех пор, пока не будет выдержано соответствие между текущей и заданной интенсивностью обмена. Если, наоборот, интенсивность обмена мала по сравнению с заданной, то активизируются приостановленные задачи, если таковые имеются."
    },
    {
        "tag": "введение в механизм стековой памяти",
        "text": "Глава 5. МЕХАНИЗМ СТЕКОВОЙ ПАМЯТИ КАК СРЕДСТВО ОРГАНИЗАЦИИ ВЫЧИСЛИТЕЛЬНОГО ПРОЦЕССА\n\nПринцип стековой организации памяти относят к одному из ведущих принципов, используемых в настоящее время при разработке ЭВМ. Это касается непосредственно операционных систем, так как стековая память представляет собой механизм, с помощью которого можно в значительной степени обеспечить эффективную организацию работы операционной системы. Стековая память не только поддерживает многие функции операционной системы, но и аппаратно реализует часть из них.\n\nСреди отечественных машин наиболее полно стековая архитектура выражена в МВК «Эльбрус», где ОС полностью ориентирована на стековую обработку данных. Активно используются аппаратные стеки в машинах СМ-3, СМ-4. Стековая память широко распространена в микропроцессорах всевозможного вида."
    },
    {
        "tag": "модель стека и принцип LIFO",
        "text": "§ 5.1. Модель стека. Стек выражений\n\nТело стека составляет совокупность смежных элементов хранения — регистров, ячеек оперативной памяти. Длина тела стека определяется количеством элементов хранения, которые в текущий момент содержат информацию. Длина является величиной переменной. Каждый раз по мере извлечения информации из стека (по правилу LIFO) длина тела уменьшается на 1. Поэтому в некоторый момент времени стека может выродиться — тело стека становится нулевой длины. Элемент тела стека, хранящий в текущий момент времени информацию, которая была помещена в стеке последней, называют вершиной стека."
    },
    {
        "tag": "регистры стека S и B и адресация",
        "text": "Адрес вершины стека меняется всякий раз по мере выполнения записи или считывания информации. При «вталкивании» информации новой вершиной становится слово, адрес которого на единицу меньше, чем у старой вершины. Сюда и будет помещаться вталкиваемая информация после установления адреса новой вершины. Если требуется считывать информацию из стека, то она выбирается из вершины стека, а потом проводится коррекция адреса вершины. Новая вершина будет располагаться по адресу, на единицу большему, чем адрес старой.\n\nДля реализации стековой памяти, которая строится на основе использования оперативной памяти, используют ряд специальных регистров. Указатель вершины стека далее обозначен как регистр S. Если все элементы тела стека адресовать в командах по обращению к стеку относительно регистра S, используя принцип адресации «база — плюс — смещение», то стек получает свойство перемещаемости. Для указателя дна стека также вводят специальный регистр, называемый далее регистр B. Наличие регистров S и B дает возможность контролировать изменение длины тела стека."
    },
    {
        "tag": "пример работы стека (рис. 5.1)",
        "text": "На рис. 5.1 показана работа стека при записи в него буквы K (каждый элемент способен хранить одну букву). Перед исполнением операции в стеке уже хранились буквы: D, B, C. M. Буквы перечислены в порядке поступления в стек. Для размещения стека зарезервирована область памяти из семи слов, начиная со слова с адресом A."
    },
    {
        "tag": "использование стеков для вычисления выражений",
        "text": "Стеки широко используются для вычисления арифметических и логических выражений. В этом случае они называются стеками выражений.\n\nВсякое арифметическое и логическое выражение обладает внутренней логикой, которая определяет порядок вычисления выражений. Обычно порядок выполнения задается известными правилами приоритетности выполнения арифметических или логических действий, скобочной записью. Каждое выражение"
    }
]"}],
[{"tag":"польская обратная запись (ПОЛИЗ)","text":"Модель стека можно представить в виде дерева, терминальными узлами которого являются операнды, а нетерминальными — операции. На рис. 5.2 показано представление выражения (A+4B)/(C+(DXE)) в виде дерева. Помимо обычного представления выражения известны и используемые L;Hrue. Одна из таких форм представления — польская инверсия запись (ПОЛИЗ). Такая форма представления может быть получена из обычной формы путем выполнения специальной операции над деревом выражения, называемой обходом дерева. В результате такой операции выражение из рис. 5.2, представляемое в форме ПОЛИЗ, имеет вид: AB+CDEX+]"} ,{"tag":"обработка выражений стеком","text":"В упрощённом виде суть обработки состоит в том, что элементы ПОЛИЗ в порядке их следования (слева направо) «заталкиваются» в стек выражений до тех пор, пока очередным элементом ПОЛИЗ не окажется операция. Тогда этот элемент ПОЛИЗ помещается в стек и служит для инициации конкретной операции. Выполняется указанная операция над двумя элементами стека, результат помещается в вершину стека. После выполнения операции над двумя операндами промежуточный результат помещается в вершину стека. Для модели с переменной вершиной адрес вершины предварительно должен быть модифицирован. Далее вновь продолжается заталкивание элементов в стек, если они являются операциями выражения. В результате после выработки последнего элемента ПОЛИЗ и выполнения соответствующих действий над ним в вершине стека остаётся вычисленное значение выражения. Стек выражений при этом вырождается, в его теле остаётся одна вершина, одновременно являющаяся и дном стека. Максимальная длина тела стека, требуемая для обработки выражения, значительно меньше суммарного числа операторов, входящих в состав выражения, поэтому количество ячеек оперативной памяти, резервируемое под стек, невелико. На практике стеки выражений имеют максимальную длину тела от единиц до нескольких десятков ячеек; длина тела стека является величиной переменной."} ,{"tag":"стековая обработка трансляторов","text":"Ориентация машины на стековую обработку позволяет строить более простые трансляторы, которые одновременно требуют меньше ресурсов (памяти и времени) и работают быстрее. Результатом работы трансляторов является эквивалент исходной программы, представленный в виде, готовом для непосредственной интерпретации с использованием стека. Это было проиллюстрировано выше на примере представления и вычисления выражения."} ,{"tag":"стек в обработке структурированных программ","text":"§ 5.2. Стек как средство обработки структурированных программ\\n\\nСтруктурирование программ является одним из ведущих принципов современного программирования и существенным для построения и организации работы операционных систем. Используются различные методы и техники структурирования программ. Далее рассмотрена блочно‑ориентированная структура программ, которая в наибольшей степени ориентирована на стековую обработку."} ,{"tag":"блочно-ориентированная структура программы","text":"Программа с блочной структурой может содержать в своём составе одну или более функционально автономных частей (блоков), каждая из которых может быть динамически вызвана для исполнения. Перед исполнением блок может быть настроен на определённые параметры, которые передаются ему перед обращением. Формы реализации блоков могут быть различными; в дальнейшем рассматривается форма процедуры. Прежде чем рассмотреть принципы установления управляющих и информационных связей с процедурами с использованием стеков, необходимо раскрыть ряд понятий, отличительных для работы процедур."} ,{"tag":"статическая цепочка","text":"Для любого узла дерева можно установить последовательность вложений блоков друг в друга, проходя по ветви дерева от анализируемого узла к корневому. Концом ветви является корневой узел. Такая последовательность называется статической цепочкой анализируемого блока. В примере, показанном на рис. 5.3,6, статической цепочкой для блока С будет последовательность \\( C - B - A \\), что означает вложенность С в В, а В — в А. Для блока Е статической цепочкой является последовательность \\( E - A \\)."} ,{"tag":"адресный контекст процедуры","text":"Адресный контекст процедуры определяет область известности имён переменных и других структурных элементов, доступных для обработки командами из состава процедуры. В адресный контекст входят локальные и глобальные переменные и программные структурные элементы. Локальные — переменные и элементы, непосредственно описанные, т.е. вложенные в тело процедуры. Глобальные — переменные и элементы, находящиеся в составе других процедур, входящих в статическую цепочку данной процедуры, а также параметры, передаваемые процедуре."} ,{"tag":"механизм расширения статической цепочки в ОС Эльбрус","text":"В ОС МВК «Эльбрус», полностью ориентированной на обработку блочно‑ориентированных программ, механизм расширения статической цепочки заключается в выделении нескольких постоянно существующих лексикографических уровней (от 0 до 2). На эти уровни выносятся узлы, соответствующие блокам ОС, пакетам прикладных программ и другим независимо транслированным программам. На самом верхнем (нулевом) уровне находятся процедуры операционной системы; они автоматически добавляются в начало любой статической цепочки прикладных программ, тем самым включаются в адресный контекст любой программы."} ,{"tag":"адресация в блочно-ориентированных программах","text":"Адресный контекст любой процедуры определяет адресные пространства, к которым имеют доступ команды процедуры. Для обращения к элементам, адресуемым в пределах этих пространств, используют адресные пары вида \\( (n, i) \\). Первый элемент n — номер лексикографического уровня, на который помещена процедура; второй элемент i — смещение, т.е. относительный адрес элемента в области памяти, отведённой для размещения тела процедуры. Виртуальное адресное пространство считается непрерывной областью, состоящей из описательной части (для локальных переменных) и части, предназначенной для адресации тела процедуры."} ]"}],
[{"tag":"адресные пары","text":"Представление всех адресов в командах процедуры в виде адресных пар — функция соответствующего транслятора. Транслятор несомненно должен проводить анализ структуры программы и определять принадлежность каждой процедуры к соответствующему уровню вложенности (лексикографическому уровню)."},{"tag":"принцип база‑плюс‑смещение","text":"Представление адреса в форме адресной пары предполагает и принцип получения физического адреса при обращении к оперативной памяти. Это известный принцип «база — плюс — смещение». Здесь демонстрируется задача виртуализации оперативной памяти. Адресная пара — это способ адресации в некотором виртуальном адресном пространстве, которое строится транслятором. Транслятор рассматривает каждый адресуемый элемент в таком пространстве как адресуемый по принципу «база — плюс — смещение» через базовый регистр. Это регистр виртуальный, так как он по смыслу является указателем (базой) конкретного лексикографического уровня. Виртуальность регистров проявляется в том, что их число при трансляции программы может быть произвольным."},{"tag":"выделение области памяти для процедуры","text":"Для отображения виртуального адресного пространства процедуры на адресное пространство оперативной памяти необходимо выделить область памяти, где будет храниться тело процедуры, назначить физический базовый регистр и занести в него начальный адрес отведенной области (базовый адрес)."},{"tag":"регистры‑дисплеи","text":"Возможна следующая схема распределения базовых регистров при проведении преобразования виртуального адреса (адресной пары) в физический. В процессоре выделяются специальные регистры, которые предназначены для базирования в указанном смысле, называемые далее *регистрами‑дисплеями*. Регистры пронумерованы в сквозном порядке, как и лексикографические уровни (в пределах тех же номеров). Тогда перед работой процедуры, расположенной на лексикографическом уровне с номером \\( n \\), предполагается, что для базирования будет выделен регистр‑дисплей также с номером \\( n \\). В него и будет помещен базовый адрес тела процедуры. Далее по мере работы процедуры в пределах отведенного ей адресного пространства оперативной памяти адрес любого элемента получают сложением смещения \\( i \\), указанного в операнде команды, и содержания регистра‑дисплея с номером \\( n \\)."},{"tag":"установка статической цепочки","text":"Чтобы обеспечить установку адресного контекста для любой процедуры, перед её исполнением необходимо сделать определённое отображение её статической цепочки на регистры‑дисплеи. Если в текущий момент подготавливается исполнение процедуры, отнесённой к лексикографическому уровню \\( n \\) в составе программы, то в регистры‑дисплеи с номерами \\( n \\) и ниже необходимо занести значения базовых адресов для всех процедур, которые находятся в составе статической цепочки активизируемой процедуры."},{"tag":"обращение к переменной внешнего уровня","text":"Пусть при исполнении процедуры, отнесённой к уровню \\( n \\), возникнет необходимость обращения к переменной, которая находится в контексте данной процедуры, т. е. в составе процедуры, отнесённой к лексикографическому уровня с номером \\( n-3 \\). Смещение адресуемой переменной равно 7. Это требование задаётся адресной парой вида \\( (n-3; 7) \\). При выполнении команды, содержащей такую адресную пару в качестве операнда, произойдёт обращение к регистру‑дисплею с номером \\( n-3 \\). К его содержимому будет прибавлено смещение 7. Это и есть адрес требуемой переменной в адресном пространстве оперативной памяти, находящемся вне адресного пространства процедуры, где была исполнена команда."},{"tag":"стек данных","text":"Локальные переменные каждой процедуры по функциональному назначению являются промежуточными данными. Их значения существуют и доступны только по мере исполнения процедуры. При исполнении программы как последовательности вызовов процедур, вложенных друг в друга, последовательность таких вызовов и возвратов в вызываемые процедуры описывается, как известно, дисциплиной LIFO. Наличие определённого числа запущенных, но ещё не законченных процедур, связанных между собой правилом LIFO, предполагает одновременно наличие в каждой такой процедуре совокупности своих локальных данных и параметров. Порядок появления и уничтожения такой информации в точности соответствует порядку вызова и выхода из процедур, т. е. описывается правилом LIFO. Поэтому можно хранить промежуточные данные каждой процедуры (локальные переменные и значения параметров) в специальном стеке, называемом далее _стеком данных_. Модель такого стекла и механизм управления им в точности совпадают со стеком выражений. Используемые для управления регистры (далее будем называть их регистры‑атрибуты) будем обозначать соответственно: \\( B' \\) — дно стека данных, \\( S' \\) — вершина стека данных."},{"tag":"структура стека данных","text":"Стек данных состоит из областей переменной длины. Каждая такая область ставится в соответствие процедуре в момент её активизации. Область состоит из определённого числа слов оперативной памяти. Каждое слово предназначено для хранения локальной переменной процедуры. Кроме того, в область помещается другая информация, включая параметры процедуры. Расположение значений переменных в пределах каждой такой области должно совпадать с порядок описания переменных в процедуре. Другими словами, каждая область стека данных — это память для хранения локальных переменных отдельной процедуры. На адресное пространство такой области производится отображение виртуального адресного пространства описательной части процедуры."},{"tag":"обращение к стеку данных через регистры‑дисплеи","text":"Чтобы обеспечить обращение к элементам таких областей, т. е. к локальным переменным процедур, необходимо воспользоваться механизмом регистров‑дисплеев, описанным ранее. Будем считать, что тело и описательная часть процедуры отображаются в оперативной памяти перед активизацией. Описательная часть — непрерывная область в стеке данных, хранящая локальные переменные. Регистры‑дисплеи будут использоваться для базирования именно описательных частей процедур."},{"tag":"прошивка описательных частей процедур","text":"Для осуществления «прошивки» описательных частей процедур в отдельные статические цепочки перед каждой описательной частью можно разместить специальное служебное слово. Минимально в таком слове должна находиться адресная ссылка на описатель"}],
[{"tag":"объединенный стек","text":"Объединенный стек. Было рассмотрено три вида стеков, которые требуется использовать при исполнении блочно-ориентированной программы. Причем можно предположить, что для исполнения каждой процедуры требуется организовать собственный стек выражений. Такое решение практически нереализуемо, так как требует произвольно большого числа регистров-атрибутов. Наиболее целесообразно и практически реализуемо произвести объединение стеков, различных по назначению, в один стек. Для этого имеются следующие предпосылки.\n\nИз приведенного описания логики работы стек данных и стекл динамических связей легко заметить, что элементы в каждый из\n\n===== Page 47 =====\n\nэтих стеков погружаются синхронно, в одном и том же порядке по мере вызова процедур. Синхронность сохраняется и при извлечении элементов из стеков. Следовательно, эти стеки можно объединить, производя при этом незначительные модификации в составе элементов каждого стека. Можно считать, что каждый элемент стека динамических связей (константа возврата) можно ввести в состав связующей информации, которая стоит в начале каждого элемента стека данных (прямодаресуемая область описательной части процедуры в область параметров процедуры). Для поддержания динамической цепочки необходимо в каждую константу возврата ввести адресный указатель по стеку на предшествующий элемент (в порядке вызова) в динамической цепочке. Тогда для управления таким объединенным стеком достаточно всего двух регистров-"}],
[{"tag":"стековая организация вычислительного процесса","text":"Простое введение стековой памяти как средства для исполнения в ней процесса не приведет к должному эффекту при исполнении программ на машинах с классической организацией обработки. Наоборот, такое введение стеков приведет к существенному замедлению всех вычислений. Эффективность исполнения программ (прежде всего по увеличению скорости исполнения, увеличению степени совмещения при исполнении отдельных программ во времени) на стеках можно достигнуть только на машинах, которые ориентированы на эту обработку. На таких машинах существует мощная аппаратная поддержка операционной системы для организации работы на дереве стеков:\\n\\nсостав команд, который ориентирован на стековую обработку; совокупность специальных программно доступных регистров, с помощью которых обеспечивается управление стеками;\\n\\nаппаратная поддержка процедурного механизма, выраженная в наличии специальных команд запуска процедур и выхода из них в стековой памяти;\\n\\nразвитые механизмы адресации с использованием дескрипторной техники, косвенного метода и метода базирования.\\n\\nПомимо названных используют и дополнительные средства. Все это, вместе взятое, позволяет существенно сократить потери на организацию управления процессами, развивающимися на стеках в оперативной гаммах машины."},{"tag":"преимущества стековых машин","text":"Назовем далее некоторые дополнительные механизмы и последствия от их проявления при стековой обработке программ. Одно из существенных положительных проявлений архитектуры стековых машин заключается в том, что трансляторы для таких машин гораздо проще и требуют меньшего расхода ресурсов по сравнению с машинами с традиционной архитектурой. Это объясняется тем, что машинные команды, из которых"}],
[
    {
        "tag": "свойства механизмов синхронизации",
        "text": "Эффективность предполагает простоту реализации в базисе средств, которые имеются в составе рассматриваемой ЭВМ. Введение механизмов синхронизации не должно приводить к чрезмерным задержкам в развитии процессов, которые их используют. Это требует установки ограничений на стратегии принятия решений при синхронизации, а также минимизации частоты включения и длительности примитивов.\n\nНадежность определяет вероятность привильной работы механизма не только в условиях, предусмотренных спецификациями пользователя согласно назначению механизма, но и в аномальных, отличных от заранее установленных.\n\nПеречисленные основные свойства взаимосвязаны и во многом противоречивы. Трудно построить механизм, удовлетворяющий всем требованиям. Наиболее часто в качестве основных выделяют требования простоты и гибкости, а также эффективности. Однако в последнее время наметился сдвиг в расстановке приоритетов среди свойств при сравнительном анализе. В настоящее время прежде всего выделяется надежность, даже в ущерб эффективности."
    },
    {
        "tag": "тестирование механизмов синхронизации",
        "text": "Для сравнения механизмов синхронизации по указанным характеристикам необходимо проводить их испытания. Наилучшим полигоном для испытания являются типовые задачи синхронизации, сформулированные выше."
    },
    {
        "tag": "возможность синхронизации без специального оборудования",
        "text": "Можно ли решать задачи синхронизации в отношении параллельных процессов на машинах, которые не имеют каких-либо специальных механиствов синхронизации? В литературе ответ на этот вопрос дается в форме показа примеров неудачных попыток решить фундаментальную задачу взаимного исключения. В конечном счете дается правильное, очень изощренное решение, найденное впервые Т. Деккером для двух параллельных процессов [29, 31]. Не приводя решения, констатируем следующее. С помощью машинных команд, либо используя средства языков программирования, принципиально можно решать задачи синхронизации. Однако есть обстоятельства, которые обесценивают практическую значимость таких решений. Нахождение правильного решения конкретной задачи — весьма трудоемкий процесс. Еще более труден процесс доказательства правильности найденного решения. В настоящее время известны только достаточно простые решения задач синхронизации. Следовательно, для реализации любого механизма синхронизации необходима специальная аппаратная поддержка."
    },
    {
        "tag": "двухэтапная схема синхронизации с прерываниями",
        "text": "Следовательно, для реализации любого механизма синхронизации необходима специальная аппаратная поддержка. В наиболее простом случае используют системы прерываний. На однопроцессорных машинах активный процесс может перейти в какое-либо промежуточное состояние только по мере возникновения прерывания в ответ на некоторое событие, происшедшее в машине. Тогда при решении задачи взаимного исключения, являющейся обязательной для решения всех задач синхронизации, можно использовать следующую схему управления системой прерывания. Если у процесса возникает необходимость использовать какой‑то критический ресурс, то при его использовании никакой другой процесс не должен иметь возможность обратиться к этому ресурсу. Обеспечить такую гарантию очень просто — процесс, которому требуется критический ресурс, должен блокировать отработку всех прерываний, поступающих на машину. Он должен блокировать систему прерываний и тем самым выйти из‑под контроля ОС. Процесс становится монопольным «хозяином» центрального процессора до тех пор, пока он сам не размаскирует систему прерываний. Поскольку на интервале между блокированием и деблокированием прерывания ни один процесс, кроме захватившего ресурс, не может развиваться, то тем самым одновременно и решается задача взаимного исключения. Один процесс исключил все другие в их стремлении использовать критический ресурс.\n\nСхема построения механизма синхронизации на основе использования системы прерываний иллюстрирует одновременно существующие негативные стороны данного решения. Данный механизм в силу своей простоты является очень негибким средством, имеет низкую эффективность (в смысле свойств, определенных в § 6.2). В самом деле использование только системы прерываний требует значительных усилий от разработчика для решения задач синхронизации, отличных от задачи взаимного исключения. Поскольку при исполнении команд критической области машина никак не реагирует на внутренние и внешние события, другие процессы в системе не могут развиваться. Следовательно, при длительных временах использования критических областей и частом обращении к ним мультипрограммный режим работы машины может быть существенным."
    },
    {
        "tag": "использование переменной состояния в синхронизации",
        "text": "Нетативных сторон приведенного решения можно избежать, если ввести еще один элемент при обращении к критическому ресурсу. В рассматриваемой простейшей схеме можно ввести переменную (переменную состояния), которая могла бы в любой момент характеризовать состояние критического ресурса. Эта переменная должна быть доступна всем процессам, которые с ее помощью хотят использовать критический ресурс. Причем в отношении этой переменной процессы должны не только осуществлять операции чтения, но и изменять ее значение. Заметим, что при таких особенностях использования переменной состояния она сама становится критическим ресурсом. Чтобы захватить основной критический ресурс, необходимо предварительно захватить вспомогательный — переменную состояния.\n\nВ самом деле, для реализации вспомогательной критической области можно, как и раньше, воспользоваться блокированием и деблокированием прерываний. Но при этом очевидно, что длительность использования вспомогательной критической области будет мала. Требуется только проверить и установить, если это допустимо, необходимое значение переменной состояния. Тогда проблема взаимного исключения может быть решена при следующем условии. Все процессы будут попадать в свою основную критическую область только через вспомогательную критическую область и при условии, что при этом вход в основную область будет проходить только тогда, когда переменная состояния указывает на незанятость основного критического ресурса.\n\nДанная упрощенная двухэтапная схема построения механизма синхронизации для решения задачи взаимного исключения показывает, что основная критическая область для достижения свойства взаимного исключения помещается в своеобразные логические скобки — вспомогательные критические области по проверке и переустановке переменной состояния. Эти скобки можно рассматривать как примитивы для обеспечения решения задачи взаимного исключения. Эти примитивы являются неделимыми (в рассмотренном ранее смысле) и взаимно исключают друг друга. При реализации рассмотренной схемы примитивы выполняют в составе ОС в форме макрокоманды, указывая в качестве параметра переменную состояния."
    },
    {
        "tag": "режимы ожидания (занятое и пассивное)",
        "text": "И еще одно обстоятельство можно отметить при более тщательном рассмотрении двухэтапной схему решения задачи взаимного исключения. Возникает вопрос: как поступать тем процессам, которые при вхождении во вспомогательную критическую область обнаруживают с помощью анализа значения переменной состояния, что основной критический ресурс в текущий момент занят каким‑то процессом? На практике используют два решения: либо организуется режим «занятого», либо «пассивного» ожидания.\n\nВ случае использования режима «занятого» ожидания процесс, обнаруживший, что критический ресурс занят, периодически организует сам или с помощью системы проверку освобождения ресурса. Процесс повторно и периодически пытается выполнить вспомогательную критическую область. Другими словами, периодически организуется попытка успешно выполнять примитив захвата ресурса.\n\nРежим пассивного ожидания предполагает, что если процесс выполняет примитив захвата ресурса и обнаруживается, что он в текущий момент времени уже занят, то такой процесс переводится из активного состояния в состояние ожидания.\n\nДля реализации режима пассивного ожидания в состав механизма синхронизации необходимо ввести новые элементы. Требуется организовать очередь процессов, которые пытались, но не смогли успешно выполнить примитив захвата критического ресурса. Как любую очередь, ее требуется формировать и обслуживать по определенным правилам. Поэтому в состав механизма синхронизации включаются средства для решения задачи упорядочения процессов в очереди, а также средства для последующего извлечения процессов из очереди при освобождении критического ресурса. Последнее средство — это основа для решения задачи реактивации процессов, которые ждут возможности монопольно использовать критический ресурс. Существует много вариантов решения данной задачи."
    },
    {
        "tag": "введение семафоров",
        "text": "Понятие семафорного механизма было введено Э. Дейкстрой [11] в 1965 г. Семафор — переменная специального типа, которая доступна параллельным процессам для проведения над ней только двух видов операций «закрытия» и «открытия», названных соответственно P- и V-операциями. Они являются примитивами в отношении семафора, который указывается в качестве параметра операций. Семафор в данном случае выполняет роль вспомогательного критического ресурса. P- и V-операции неделимы при своем выполнении и взаимно исключают друг друга. Семафорный механизм работает по двухэтапной схеме, рассмотренной в § 6.3, и использует при этом режим «населенного» ожидания. Поэтому в состав механизма включаются средства формирования и обслуживания очереди ожидающих процессов, которым не удается выполнить успешно примитив «закрытия» семафора."
    },
    {
        "tag": "виды семафоров",
        "text": "**Простые семафоры. Две модификации.** Рассмотрим семафоры, допустимыми значениями которых являются целые числа. При этом возможны два варианта построения допустимого диапазона значений.\n\nПервый вариант — допустимы только целые положительные числа, включая ноль. Особый случай в таком варианте, когда допустимые значения семафора — только 0 и 1. Такой семафор называют *двоичным*.\n\nВторой вариант — допустимы не только положительные, но и отрицательные целые числа в качестве значений семафора.\n\nКаждый из вариантов в свою очередь имеет модификации, обусловленные прежде всего особенностью построения примитивов по «закрытию» и «открытию» семафора. Обобщенный смысл операции закрытия — проверить текущее значение семафора, и если оно больше нуля, то перейти к выполнению следующей за примитивом операции, предварительно уменьшив на единицу значение семафора. Если же значение семафора равно или меньше нуля, т. е. семафор закрыт, то процесс, пытающийся выполнить примитив, должен быть переведен в состояние «населенного» ожидания. Чтобы обрисовать более наглядно эту характерную ситуацию, далее, будем говорить, что процесс «засыпает» на семафоре, если он при проверке оказался закрыт. Операция открытия связана с обязательным увеличением на единицу значения семафора и помимо этого проводится «побудка» одного или нескольких процессов, которые «спят» на семафоре. Как правило, «побудка» заключается в переводе процесса из очереди ожидания к семафору (это непременный элемент семафорного механизма, куда помещаются «засыпающие» процессы) в очередь готовности к центральному процессору."
    },
    {
        "tag": "алгоритм P и V операций семафора",
        "text": "\\[ \\text{[АЛГОРИТМ R(S)]} \\] \\[ S := S - 1; \\] \\[ IF S < 0 \\text{ THEN } < \\text{ОСТАНОВИТЬ ПРОЦЕСС И ПОМЕСТИТЬ В ОЧЕРЕДЬ ОЖИДАНИЯ К СЕМАФОРУ S} > \\] \\[ ELSE < \\text{ПРОДОЛЖИТЬ ПРОЦЕСС} >; \\] \\[ \\text{[АЛГОРИТМ V(S)]} \\] \\[ IF S<0 THEN <ПОМЕСТИТЬ ОДИН ИЗ ОЖИДАЮЩИХ} \\] \\[ ПРОЦЕССОВ ОЧЕРЕДИ СЕМАФОРА S В \\] \\[ ОЧЕРЕДЬ ГОТОВНОСТИ> ; \\] \\[ S := S+1 ; \\] Далее показано использование примитивов: ВЕСКИ S := 1; COBEGIN 1: P(S); КО; v(S); . . . . 2: P(S); КО; v(S); . . . . COEND END"
    }
]"}],
[
    {
        "tag": "использование семафора для взаимного исключения",
        "text": "Здесь изображен случай использования семафоров для решения задачи взаимного исключения. На рисунке нотация КО обозначает здесь и далее критическую область, которая строится в составе процесса для обеспечения обработки некоторого критического ресурса. Каждая критическая область в параллельных процессах, согласно постановке задачи, должна исключать друг друга. Переменная S — это семафор, которому присваивается начальное значение, равное 1. Имя семафора указывается как параметр при обращениях к \\( P \\)- и \\( V \\)-примитивам. Показаны только два параллельных процесса, обозначенных цифрами 1 и 2. Если процессы 1 и 2 попытаются одновременно выполнить примитив \\( P \\), то это удастся успешно сделать только одному из них (какому — неизвестно). Положим это сделал процесс 2, тогда он и закрывает семафор S, после чего начинается выполнение критической области в его составе. Процесс 1 в рассматриваемой ситуации (заснет) на семафоре S. Тем самым будет гарантировано взаимное исключение. Процесс 1 временно выбыл из борьбы за критический ресурс. После выполнения процессом 2 примитива \\( V \\) семафор S открывается, тем самым указывая на возможность захвата каким-либо (только одним) процессом освободившегося критического ресурса. При этом процессом 2 проводится побудка процесса 1."
    },
    {
        "tag": "решения задачи реактивации семафора",
        "text": "На реализационном уровне возможно одно из двух решений в отношении процессов, которые переводятся из очереди ожидания семафора в очередь готовности при выполнении примитива \\( V \\). Это два возможных решения задачи реактизации: процесс при его активизации (при выборке из очереди готовности) вновь пытается выполнить примитив \\( P \\), считая предыдущую попытку неуспешной; процесс при помещении его в очередь готовности отмечается как успешно выполнивший примитив \\( P \\). Тогда при его активизации (при извлечении процесса из очереди готовности) управление будет выполнено не на повторное выполнение примитив \\( P \\), а на команду, следующую за ним."
    },
    {
        "tag": "пример возникновения тупика при первом решении реактивации",
        "text": "Нетрудно заметить, что при первом решении задачи реактивации возможно возникновение тупика. Продемонстрируем этот случай на примере задачи взаимного исключения, решение которой приведено ранее.\n\nПусть процесс 2 в некоторый момент времени пытается выполнить и выполняет примитив \\( P(S) \\). Тогда S становится равным 0. Пусть далее процесс 1 пытается выполнить примитив \\( P(S) \\). Он не сможет это сделать, так как семафор закрыт, т. е. \\( S=0 \\). Процесс 1 «засыпает», т. е. помещается в очередь к семафору, а семафор становится отрицательным, т. е. \\( S=-1 \\). После выполнения критической области процесс 2 выполняет примитив \\( V(S) \\), при этом \\( S=0 \\), а процесс 1 переводится в очередь готовности. Пусть через некоторое время процесс 1 будет активизирован (выбран для исполнения из очереди готовности). Он повторно пытается выполнить примитив \\( P(S) \\), однако это ему не удается, так как \\( S=0 \\). Процесс 1 «засыпает» на семафоре, а значение семафора при этом стало \\( S=-1 \\). Если через некоторое время процесс 2 попытается выполнить примитив \\( P(S) \\), то он тоже «уснет». Будить процессы некому, попали в тупик."
    },
    {
        "tag": "пример отсутствия тупика при втором решении реактивации",
        "text": "При использовании второго решения задачи реактивации тупика в данной последовательности действий не будет. В самом деле, пусть все происходит так же до момента выдачи процессом 2 примитива \\( V(S) \\). Пусть примитив \\( V(S) \\) выполнен и \\( S=0 \\). Рассмотрим наиболее неблагоприятный случай. Процесс 2 вновь пытается войти в свою критическую область и закрыть семафор, т. е. выдает \\( P(S) \\). Войти в критическую область ему не удается (\\( S=0 \\)) и процесс «засып"}],
[{"tag":"producer-consumer single buffer","text":"При попытке процесса-потребителя выбрать сообщение из пустого буфера \\( S = 0 \\) он будет переведен в состояние ожидания при выполнении примитива \\( P'(S) \\). Процесс-потребитель будет находиться в состоянии ожидания до тех пор, пока не появится сообщение в буфере. Оповещение об этом событии осуществит процесс-производитель, который после помещения очередного сообщения в буфер производит оповещение посредством выполнения примитива \\( V'(S) \\). Аналогично, при попытке процесса-производителя послать сообщение в буфер, из которого еще не считано процессом-потребителем ранее посланное сообщение, будет осуществлен его перевод в состояние ожидания на семафоре \\( Q \\). О возможности послать сообщение оповещает процесс-потребитель после считывания сообщения (буфер освобождается) исполнением примитива \\( V'(S) \\)."},{"tag":"producer-consumer multiple buffer","text":"На практике при решении задачи «производитель-потребитель» часто используют буфер, который способен хранить не одно (как в рассмотренном примере), а несколько сообщений. Нетрудно заметить, что алгоритм примера может быть модифицирован, чтобы учесть эту возможность. Если в рассмотренном примере сообщения имеют одинаковую длину, а максимальное число сообщений, которое одновременно может быть помещено в буфер, равно \\( n \\), то достаточно установить начальное значение семафора \\( Q = n \\). При этом необходимы средства для отслеживания тех мест в буфере, которые доступны для помещения очередных сообщений в места, откуда требуется считывать очередное сообщение."},{"tag":"multiple semaphores concept","text":"Множественные семафоры. Особенностью такого механизма является возможность проверки в одном примитиве не одного, а нескольких семафоров и обработки их по определенным правилам. В отношении семафоров, как и ранее, выстраиваются очереди ожидающих процессов. Однако проблема здесь существенно сложнее, чем в случае использования простых семафоров, так как нет тривиальной связи между одним семафором и очередью ожидания. Очередь ожидания может быть связана с составным условием, которое проверяется в соответствующих примитивах. Возможности"},{"tag":"dining philosophers solution","text":"Множественных семафоров продемонстрируем на решении задачи синхронизации типа «обедающие философы». VAR FORKS: ARRAY 1..5 OF SEMAPHORE; I: INTEGER; BEGIN I:=5; REPEAT FORKS[I]:=1; I:=I-1 UNTIL I=0; COBEGIN 1: BEGIN ...<TEЛО ПРОЦЕССА>... END; ....... I: BEGIN VAR    LEFT,RIGTH:1..5; BEGIN LEFT:=(I-1) MOD 5; RIGTH:=(I+1) MOD 5; REPEAT <РАЗМЫШЛЕНИЯ>; P(FORKS[LEFT];FORKS[RIGTH]); <ИСПОЛЬЗОВАНИЕ РЕСУРСА, Т.Е. ЕДА>. V(FORKS[LEFT];FORKS[RIGTH]) FOREVER END END COEND END Здесь каждый философ — это отдельный процесс с номером \\( I = 1..5 \\). Зная свой номер, философ (процесс) в состоянии определить номер соседа слева: \\( LEFT := (I-1) MOD 5 \\) и номер соседа справа: \\( RIGTH := (I+1) MOD 5 \\). Каждой вилке (их всего пять, по числу философов) поставлен в соответствие отдельный семафор. Все семафоры составляют отдельный массив FORKS. Если \\( I \\) -я вилка в текущий момент времени занята философом, то значение семафора FORKS [I] равно 0. Каждый примитив \\( P \\) и \\( V \\) проводит обработку сразу двух семафоров из массива. Разумеется, примитивы неделимы и исключают друг друга во времени. При выполнении примитива \\( P \\) процесс может «заснуть» либо на одном семафоре, либо на другом, либо на обоих сразу. Такие блокировки развития процесса возникают, если в момент выполнения примитива \\( P \\) соответствующие проверяемые семафоры равны 0. В предложенном решении исключено активное ожидание, которое пришлось бы реализовывать, если бы для решения данной задачи синхронизация использовались бы не множественные, а простые семафоры. Реализация механизма множественных семафоров сложнее, так как требуется средство обслуживания в одном примитиве не одной, а двух очередей с учетом различных состояний семафоров. При использовании множественных семафоров получаемые решения нагляднее и естественнее, чем при использовании простых семафоров."},{"tag":"counting semaphores","text":"Счетные семафоры, тест-семафоры. В таком механизме синхронизации при каждом выполнении примитивов \\( P \\) и \\( V \\) допускается изменение значения семафора \\( S \\) не на 1, а на любое определенное число \\( R \\), что обозначается: \\( P(S, R) \\) и \\( V(S, R) \\). Если в результате выполнения примитива \\( P \\) полученное значение семафора остается положительным, то процесс продолжается. В противном случае процесс «засыпает» на семафора. Задача реактивации часто решается путем использования проверяемого пассивного ожидания. Проиллюстрируем области использования данного вида семафоров на примере решения задачи синхронизации типа «читатели-писатели», которые работают с некоторой файловой системой."},{"tag":"readers-writers problem","text":"Задача решается при следующих исходных условиях. Число процессов-писателей и процессов-читателей произвольно. С файловой системой могут одновременно работать (читать информацию) сколько угодно процессов-читателей. Но одновременная работа по записи и считыванию информации недопустима. Следовательно, с некоторым файлом одновременно не могут работать какой-либо процесс-писатель и процесс-читатель. Также недопустима одновременная работа процессов-писателей над файлами. Решение задачи приведено ниже и не требует дополнительных комментариев. Здесь семафору \\( S \\) при инициализации присваивается значение, равное \\( n \\). VAR S: SEMAPHORE; \\( Q, R \\): INTEGER; BEGIN \\( R:=1; Q:=n;\\{ИНИЦИАЛИЗАЦИЯ СЕМАФОРА И ИНКРЕМЕНТА\\} \\) COBEGIN ПОТРЕБИТЕЛЬ1: REPEAT <ПРОИЗВОЛЬНЫЕ ОПЕРАТОРЫ>; \\( P(S, R); \\) <ЧТЕНИЕ ИЗ БАЗЫ ДАННЫХ>; \\( V(S, R); \\) FOREVER; ПОТРЕБИТЕЛЬК: REPEAT <ПРОИЗВОЛЬНЫЕ ОПЕРАТОРЫ>; \\( P(S, R); \\) <ЧТЕНИЕ ИЗ БАЗЫ ДАННЫХ>; \\( V(S, R); \\) FOREVER; ПРОИЗВОДИТЕЛЬ1: REPEAT <ПРОИЗВОЛЬНЫЕ ОПЕРАТОРЫ>; \\( P(S, Q); \\) <ЗАПИСЬ В БАЗУ ДАННЫХ>; \\( V(S; Q); \\) FOREVER; ПРОИЗВОДИТЕЛЬп: REPEAT <ПРОИЗВОЛЬНЫЕ ОПЕРАТОРЫ>; \\( P(S, Q); \\) <ЗАПИСЬ В БАЗУ ДАННЫХ>; \\( V(S, Q); \\) FOREVER"},{"tag":"test semaphores","text":"При построении механизма, названного тест-семафорами, вводится более усложненная логика работы примитива \\( P \\). В качестве параметров этого примитива указываются: имя семафора \\( S \\); значение, на которое необходимо изменить \\( S \\); величина \\( Q \\), с которой следует сравнить новое значение семафора (после его модификации). Если полученное значение \\( S \\) таково, что величина \\( Q-S \\) положительна, то процесс, исполнивший примитив, продолжается. В противном случае процесс «засыпает» на семафора \\( S \\)."},{"tag":"other semaphore-like mechanisms","text":"Прочие семафороподобные механизмы. Множественность типов семафорных механизмов вызвана стремлением создать достаточно простые и одновременно эффективные децентрализованные механизмы для решения задач синхронизации. Семафоры — достаточно примитивные средства синхронизации, что в ряде случаев неудобно для использования и может привести к ошибкам при их употреблении. Имеется ряд областей, где вообще невозможно найти эффективное решение задачи синхронизации, используя приведенные примитивы \\( P \\) и \\( V \\) и их модификации. В таких случаях либо разрабатывают механизмы синхронизации более высокого уровня, либо совершенствуют (часто за счет усложнения) семафорный механизм. Один из способов совершенствования — введение дополнительных примитивов, которые можно выполнять в отношении семафора. Такой прием использован, в частности, в ОС МВК «Эльбрус» [25]. Изложим кратко суть этого приема. В отношении семафора (двоичного) с именем \\( S \\) допустимы «стандартные» примитивы ЗАКРЫТЬ (\\( S \\)) и ОТКРЫТЬ (\\( S \\)), некоторые, как следует из их нотации, являются аналогами примитивов \\( P \\) и \\( V \\) соответственно. Отличие заключается в решении задачи реактивации. Если при открытии семафора \\( S \\) с помощью примитива ОТКРЫТЬ (\\( S \\)) оказывается, что к семафору выстроена очередь «уснувших» процессов, то вся эта очередь переносится в состав очереди готовности. При повторной активации процесса из очереди готовности он вновь осуществляет попытку выполнить требуемую операцию ЗАКРЫТЬ (\\( S \\)). Помимо базовых примитивов имеется еще четыре дополнительных. Примитив ПРОПУСТИТЬ (\\( S \\)) аналогичен примитиву ОТКРЫТЬ (\\( S \\)) по назначению, но отличен по обработке значения семафора. При наличии очереди к семафору \\( S \\) производится пересылка ее в очередь готовности, как и ранее. Однако в отличие от ОТ- КРЫТЬ (–S) семафор остается закрытым после выполнения этого примитива. Здесь при активизации «спящих» процессов из очереди готовности их выполнение начнется с команды, следующей за примитивом, на котором он заснул. Такая возможность удобна для проведения безусловной реактивации некоторого число заранее остановленных (ожидающих) процессов. Примитив ЖДАТЬ (–S) при выполнении в отношении закрытого семафора (S=0) переводит процесс в очередь ожидания семафора. При открытом семафоре примитив успешно выполняется, и процесс будет продолжен. Причем в отличие от примитива ЗАКРЫТЬ (–S) в данной ситуации семафор не закрывается. Специально для нужд операционной системы введены два привилегированных примитива ЖУЖ (–S) и ОТКСЕМ (–S). Эти примитивы недоступны пользовательским процессам. Примитив ЖУЖ (–S) аналогичен примитиву ЗАКРЫТЬ (–S), но реализует режим активного ожидания в случае закрытого семафора при его выполнении. Процесс ждет открытия семафора, не отдавая процессора. В данной ситуации семафор может быть открыт каким-либо процессом, развивающимся параллельно на одном из процессоров. Такой примитив полезен для реализации системных действий, в частности для управления очередью ожидания к семафору. Эта очередь в мультипроцессорном комплексе является разделяемым критическим ресурсом. Следовательно, чтобы поместить процесс в очередь к одному семафору (при его закрытии), необходимо закрыть другой семафор. Это требует аналогичных действий в отношении очереди ожидания и т. д. Такая рекурсия может увести в бесконечность. Поэтому при постановке некоторого процесса в очередь к семафору достаточно использовать примитив ЖУЖ (–S) в отношении другого семафора, чтобы решить данную проблему. Примитив ОТКСЕМ (–S) осуществляет только открытие семафора. Очередь к семафору при этом не проверяется. Как отмечают разработчики ОС МВК «Эльбрус», перечисленный набор примитивов составляет базу для создания более сложных примитивов либо других средств синхронизации. Определенная множественность семафороподобных средств наблюдается и в составе ОС ЭВМ [9, 24, 26]. Имеется средство, которое позволяет решать задачи синхронизации, основу которых составляет взаимное оповещение процессов о некоторых событиях. В данном случае — это вырожденный случай реализации задачи синхронизации типа «производитель—потребитель», когда процессы обмениваются «пустыми» сообщениями. Это означает, что информация между процессами не передается, а фиксируется лишь факт обращения одного процесса к другому. Механизм состоит из специальной информационной структуры — блока управления событиями (ECB). Он частично выполняет функции семафора. В состав механизма входят два примитива WÄIT и SIGNAL. В качестве параметров при обращении к ним у"}],
[
    {
        "tag": "определение семафора и его роль как счетчика",
        "text": "Любой семафор — это критический ресурс. В качестве такого ресурса выступает вырожденный буфер сообщений, используемый процессом-производителем (процессом, который выдает примитив \\( V \\)) и процессом-потребителем (процессом, который выдает примитив \\( P \\)). Вырожденность буфера заключается в том, что передаваемые через него сообщения не несут конкретной информации. Это «нулевые» по длине и содержанию сообщения, которые свидетельствуют только о факте возникновения некоторого события, но конкретная информация о событии не сообщается. В данном случае буфер выступает в роли счетчика переданных процессом-производителем, но еще не принятых процессом-потребителем нулевых сообщений. Это касается случая, когда допустимы только положительные значения семаф"}],
[{"tag":"преобразование алгоритма с использованием двоичного семафора","text":"FOREVER COEND %ND\\n\\nКомпилятором этот алгоритм может быть преобразован в алгоритм с использованием, как указано, двоичного семафора. Одно из возможных решений имеет такой вид:\\n\\nTYPE T=ARRAY 1..100 OF INTEGER; VAR S:SEMAPHORE; СЧИТЫВАНИЕ:BOOLEAN; M:T; BEGIN S:=1; СЧИТЫВАНИЕ:=TRUE; COBEGIN 1: REPEAT <НЕКОТОРЫЕ ДЕЙСТВИЯ>; L1: P'(S); IF СЧИТЫВАНИЕ THEN BEGIN V'(S); GOTO L1 END ELSE BEGIN <СЧИТЫВАТЬ ИНФОРМАЦИЮ ИЗ М>; СЧИТЫВАНИЕ:=TRUE; V'(S) END\\n\\nFOREVER; 2:REPEAT <НЕКОТОРЫЕ ДЕИСТВИЯ> ; Р' (5) ; «ЗАПИСАТЬ ИНФОРМАЦИЮ В М> ; СЧИТЫВАНИЕ : =FALSE ; №: <НЕКОТОРЫЕ ДЕИСТВИЯ› ; ®' (5) ; <ЗАПИСЬ ИНФОРМАЦИИ В М>; СЧИТЫВАНИЕ : =FALSE ; V' (5) FOREVER COEND END Возможны, разумеется, и другие схемы преобразования. В приведенном примере преобразования роль событийной очереди Bhl- полняет очередь ожидания K семафору S."},{"tag":"механизм активного ожидания и модификация критической области","text":"В приведённом примере преобразования роль событийной очереди Bhl- полняет очередь ожидания K семафору S. В качестве главной выступает очередь готовности K центральному процессору. В приведённом решении после каждого выхода процесса из своей критической области к главной очереди подсоединяются не все члены событийной очереди, а только какой‑то один процесс. Особенностью данного средства синхронизации, являющегося модификацией конструкции типа «критическая область», является сокрытие механизма реактивации от пользователей, у которых нет возможности управлять порядком повторного входа в критические области процессов. Механизм по сути своей реализует режим активного ожидания. Поэтому его использование в соображениях эффективности будет оправдано в тех случаях, когда обращения к критическим ресурсам являются редкими. При интенсивном использовании критического ресурса наиболее правомочно использование другой модификации механизма «критической области». Это тоже условная критическая область. Чтобы ввести отличие модификаций, последнюю будем называть модификацией второго рода. Суть модификации заключается в TOM, что в составе конструкции REGION допустимо использование двух специфичных примитивов: AWAIT (E), CAUSE (E)."} ,{"tag":"алгоритм распределения структурированного критического ресурса","text":"Алгоритм распределения структурированного критического ресурса среди параллельных процессов. В качестве иллюстрации использования условных критических областей второго рода разберём решение конкретной задачи распределения критического ресурса. Необходимо построить соответствующую систему распределения. Распределяемый ресурс R состоит из некоторого числа N однотипных единиц ресурса. Любому процессу должна быть предоставлена возможность при каждом разовом обращении к системе получить из состава ресурса R одну единицу. Если в момент обращения нет ни одной свободной единицы (все распределены ранее среди прочих процессов), то процесс должен перейти в состояние ожидания до тех пор, пока не появится хотя бы одна свободная единица. После использования каждой единицы ресурса процесс обязан её вернуть в состав ресурса R. О таком возвращении должны быть осведомлены все процессы, ожидающие выполнения запроса на единицу ресурса.\\n\\\\n\\text{BEGIN} \\\\ \\text{TYPE RES=1..M;} \\\\ \\text{P=1..N;} \\\\ \\text{VAR INF: SHARED RECORD} \\\\ \\text{СВОБОДРЕСУРС: SEQUENCE OF RES;} \\\\ \\text{ТРЕБОВАНИЕ: QUEUE OF P;} \\\\ \\text{ОЧСОБЫТИЙ: ARRAY P OF EVENT R} \\\\ \\text{END} \\\\ \\text{PROCEDURE RESERVE (ПРОЦЕСС: P; VAR PECVPC: RES);} \\\\ \\text{REGION INF DO} \\\\ \\text{BEGIN WHILE EMPTY (СВОБОДРЕСУРС) DO} \\\\ \\text{BEGIN} \\\\ \\text{ENTER (ПРОЦЕСС, ТРЕБОВАНИЕ);} \\\\ \\text{AWAIT (ОЧСОБЫТИЙ (ПРОЦЕСС));} \\\\ \\text{END;} \\\\ \\text{GET (PECVPC, СВОБОДРЕСУРС);} \\\\ \\text{END;} \\\\ \\text{PROCEDURE RELEASE (PECVPC: RES);} \\\\ \\text{VAR ПРОЦЕСС: P;} \\\\ \\text{REGION INF DO} \\\\ \\text{BEGIN} \\\\ \\text{PUT (PECVPC, СВОБОДРЕСУРС);} \\\\ \\text{IF NOT EMPTY (ТРЕБОВАНИЕ) THEN} \\\\ \\text{BEGIN} \\\\ \\text{REMOVE (ПРОЦЕСС, ТРЕБОВАНИЕ);} \\\\ \\text{CAUSE (ОЧСОБЫТИЙ (ПРОЦЕСС));} \\\\ \\text{END} \\\\ \\text{END;}"},{"tag":"пример использования процедур RESERVE и RELEASE","text":"СОВЕСТИ 1: BEGIN VAR R1 : RES; REPEAT HEKOTOPbIE ДЕИСТВИЯ ; RESERVE (1; VAR R1) ; ИСПОЛЬЗОВАТЬ ЕДИНИЦУ РЕСУРСА ИЗ R С НОМЕРОМ ,РАВНЫМ ЗНАЧЕНИЮ R1 ; RELEASE (R1) ; FOREVER END; ...... N: BEGIN VAR RN : RES; REPEAT HEKOTOPbIE ДЕИСТВИЯ ; RESERVE (N; VAR RN) ; ИСПОЛЬЗОВАТЬ ЕДИНИЦУ РЕСУРСА ИЗ R С НОМЕРОМ ,РАВНЫМ ЗНАЧЕНИЮ RN ; RELEASE (RN) FOREVER END COEND END"},{"tag":"структура разделяемой переменной INF","text":"В приведённом решении имеются следующие особенности. В данном алгоритме под критическим ресурсом понимается не ресурс R, который даже не декларирован в алгоритме, а некоторая совокупная информация, описывающая состояние ресурса и системы процессов, выдавших заявки на получение единицы ресурса. Этот критический по смыслу ресурс декларирован как структурированная разделяемая переменная с именем INF. Тип значения переменной INF описан языковой нотацией RECORD по правилам языка Паскаль. В данном примере переменная INF состоит из трёх поименованных элементов разного типа."},{"tag":"переменная СВОБОДРЕСУРС и операции GET/PUT","text":"Элемент с именем СВОБОДРЕСУРС — это переменная типа SEQUENCE, состоящая из непоименованных элементов. Каждый составной элемент относится к типу RES и описан в начале алгоритма простым перечислением допустимых значений для переменной данного типа. Это целые числа в диапазоне от 1 до M. Функционально переменная СВОБОДРЕСУРС предназначена для хранения информации о нераспределённых в текущий момент единицах ресурса. Все единицы ресурса пронумерованы в сквозном порядке в диапазоне от 1 до M.\\nЭлемент с именем СВОБОДРЕСУРС относится к типу SEQUENCE и предполагает обработку с помощью операций GET и PUT. С помощью GET (T, Q) присваивается значение переменной с именем T одному из элементов переменной Q типа SEQUENCE по правилу FIFO. Операция PUT (T, Q) — обратная по смыслу. При её выполнении выбирается значение соответствующего элемента из переменной Q по правилу FIFO и осуществляется присвоение выбранного значения переменной T."},{"tag":"переменная ТРЕБОВАНИЕ и операции ENTER/REMOVE","text":"Элемент с именем ТРЕБОВАНИЕ — также структурированная переменная, но типа QUEUE. Она содержит непоименованные элементы одного и того же типа P. Этот тип описан в начале программы простым перечислением допустимых значений, где M — максимальное число процессов, которое может претендовать на использование ресурса R. Элемент ТРЕБОВАНИЕ служит для хранения совокупности заявок, исходящих от процессов на приобретение единиц ресурса. Заявка — это номер процесса, который выдает требование на приобретение единицы ресурса. Все конкурирующие процессы пронумерованы в пределах от 1 до N.\\nЗанесение номера процесса в очередь с именем ТРЕБОВАНИЕ и извлечение номера из этой очереди осуществляются с помощью операций ENTER (P, ТРЕБОВАНИЕ), REMOVE (P, ТРЕБОВАНИЕ), где P — это переменная, откуда или куда помещается номер. Такое внесение и извлечение номера осуществляется не обязательно по правилу FIFO, а по той дисциплине, которая будет выбрана на этапе реализации. В отношении переменной ТРЕБОВАНИЕ допустимо использовать логическую функцию EMPTY (ТРЕБОВАНИЕ)."}},{"tag":"массив событийных переменных ОЧСОБЫТИЙ","text":"Элемент ОЧСОБЫТИЙ — это массив событийных переменных. Каждая событийная переменная указывает явно на один и тот же ресурс R. Каждому процессу поставлена в соответствие собственная событийная переменная. Процессу с номером I соответствует I‑й элемент данного массива."},{"tag":"процедуры RESERVE и RELEASE","text":"Для упрощения решения задачи используются две процедуры: процедура RESERVE для выделения единицы ресурса и процедура RELEASE для освобождения использованной единицы ресурса. При обращении к процедуре RESERVE процесс передаёт в качестве параметра значение собственного номера, а также имя переменной, куда будет помещён ответ — номер выделенной для использования единицы ресурса. Обращение к процедуре RELEASE требует от процесса указания только номера той единицы ресурса, которая возвращается данным процессом в состав ресурса R. Предполагается, что процесс будет возвращать только те единицы ресурса, которые он ранее захватил с помощью RESERVE."},{"tag":"поведение процессов при запросе ресурса","text":"Алгоритмы развития любого из N параллельных циклических процессов очевидны. При необходимости получить единицу ресурса любой процесс с номером I (1 \\u2264 I \\u2264 N) обращается к процедуре RESERVE с соответствующими фактическими параметрами. Если одновременно пытаются обратиться к процедуре два или более процессов, то это удаётся сделать только одному из них. Остальные процессы по правилу взаимного исключения переводятся в состояние ожидания относительно критического ресурса INF. Если процесс, который вошёл в критическую область и начал выполнять процедуру RESERVE, обнаружил, что в текущий момент нет ни одной свободной единицы ресурса (в составе СВОБОДРЕСУРС нет ни одного элемента), то он временно покидает критическую область с помощью примитива AWAIT, т. е. засыпает на собственной событийной переменной в массиве ОЧСОБЫТИЙ. При обнаружении процессом во время нахождения в критической области хотя бы одной свободной единицы ресурса он производит её захват — узнаёт номер выделенной ему единицы ресурса. При этом корректируется содержимое СВОБОДРЕСУРС. По мере выхода процесса, получившего единицу ресурса, из процедуры RESERVE в неё может войти любой (но только один) процесс. После исполнения RESERVE процесс владеет выделенной ему единицей монопольно. При выполнении некоторым процессом процедуры RELEASE указанная им единица ресурса отмечается как свободная. Соответствующая информация заносится в СВОБОДРЕСУРС. Освободившаяся единица ресурса доступна для распределения с помощью процедуры RESERVE. Она также проверяет необходимость реактивации процессов, временно вышедших из критической области. По значению переменной ТРЕБОВАНИЕ определяется наличие очереди таких процессов. Если очередь имеется, то осуществляется перевод процессов (одного из них) из переменной ОЧСОБЫТИЙ в главную очередь. Это делается с помощью примитива CAUSE. Выполнение процедур RESERVE и CAUSE происходит при взаимном исключении друг друга."},{"tag":"введение в мониторы как средство распределения ресурсов","text":"§ 6.7. Вопросы построения мониторов как базового средства по распределению ресурсов в ОС\\n\\nМониторы, целевое назначение. Концепция монитора, как высокоуровневого языкового средства согласования процессов при разделении ресурсов, была впервые изложена Б. Хансеном [35]. Более детально проработку и развитие эта концепция получила в работах С. Хоара, именем которого чаще всего это средство и называют — «монитор Хоара» [37].\\n\\nБ. Хансен определил монитор как основное средство в структурировании ОС при их проектировании и ввёл это средство в язык Concurrent Pascal [36], ориентированный на параллельное программирование и создание операционных систем. Идеология монитора основана на логической и текстуальной концентрации в системе, т. е. локализации всех переменных, описывающих разделяемый ресурс, и действий, определяющих способы доступа к ресурсу. В первом своём определении Б. Хансен дал понятие монитора как средства для описания некоторой разделяемой переменной и некоторого набора операций над ней. Как отмечалось, основная цель любой операционной системы — обеспечивать статическое или динамическое распределение всевозможных ресурсов среди пользователей, в качестве которых выступают процессы. Поэтому основная задача при проектировании ОС — создание планировщиков ресурсов, решающих приемлемым образом задачу централизованного распределения основных ресурсов ЭВМ. Для облегчения такой задачи в отношении ресурсов, являющихся по своей природе или обозначенных в системе как критические, предлагается в отношении каждого отдельного класса таких ресурсов строить отдельный планировщик, но по одной и той же схеме. Именно такую схему и декларирует средство, названное монитором. Вместе с тем монитор — средство взаимодействия между процессами, но более высокого уровня, нежели рассмотренные ранее. Таким образом, монитор Хоара есть средство решения задач распределения ресурсов и взаимодействия процессов."},{"tag":"структура монитора и правила использования","text":"Структура и правила использования монитора. Для определения состава монитора и способов работы с ним будем использовать языковую нотацию, введённую С. Хоаром [37]. В его определении монитор — это специальная поименованная структура данных, которая декларируется следующей конструкцией:\\n\\n\\\"ИМЯ\\\": МОНТОР; ВЕСП \\\"ДЕКЛАРАЦИЯ ЛОКАЛЬНЫХ ДАННЫХ МОНИТОРА\\\"; (НАБОР ПРОЦЕДУР МОНИТОРА) PROCEDURE <ИМЯ ПРОЦЕДУРЫ> (<СПИСОК ПАРАМЕТРОВ>); ВЕСП \\\"ТЕЛО ПРОЦЕДУРЫ\\\" END; PROCEDURE <ИМЯ ПРОЦЕДУРЫ> (<СПИСОК ПАРАМЕТРОВ>); ВЕСП \\\"ТЕЛО ПРОЦЕДУРЫ\\\" END; <ИНИЦИАЛИЗАЦИЯ ЛОКАЛЬНЫХ ДАННЫХ МОНИТОРА> END\\n\\nКаждый монитор имеет собственное имя, указываемое в заголовке монитора. В теле монитора, ограниченном скобками BEGIN и END, декларируются те \\\"упрятываемые\\\" в мониторе локальные данные, которые по смыслу являются разделяемыми среди процессов с помощью процедур монитора. Значения этих локальных данных устанавливаются (инициализируются) в начальные значения в момент первого обращения к монитору по мере выполнения действий, описанных в конце тела монитора. Далее значения этих переменных могут быть изменены лишь процедурами, входящими в состав набора процедур монитора. Причём каждое предыдущее изменение некоторой процедурой значения любой из таких переменных остаётся в мониторе до того момента, пока не произойдёт следующее изменение значения такой переменной какой‑либо процедурой монитора, не обязательно той же."},{"tag":"условные переменные в мониторах","text":"В пределах монитора доступны для обработки переменные специального типа, названные С. Хоаром *условными*. Для декларации некоторой переменной с именем M данного типа введена нотация вида:\\n\\nVAR M: CONDITION;\\n\\nСодержательный смысл переменной данного типа близок к переменной событийного типа, рассмотренной ранее. Условная переменная M декларирует очередь (вначале пустую) процессов, которые ожидают в ней выполнения некоторого условия. Размещение процессов в такой очереди и их извлечение оттуда для каждой условной переменной осуществляются с помощью базовых операций"}]"}],
[{"tag":"операции SIGNAL и WAIT","text":"типа SIGNAL и WAIT. Для помещения процесса в некоторую очередь, определенную условной переменной \\( M \\) требуется при исполнении этим процессом некоторой процедуры монитора выполнить в ее составе примитив WAIT. Это задается следующей нотацией: М. WAIT. Исполнение примитива SIGNAL·в отношении некоторой условной переменной \\( M \\) задается следующей нотацией: М. SIGNAL. При исполнении некоторой процедурой примитива SIGNAL (по инициативе некоторого процесса) будет «разбужен» один из «спящих» процессов в очереди к \\( M \\), если имеется очередь. По предложению С. Хоара, выборка процессов из очереди при этом производится по правилу FIFO, что отличает эту операцию от CAUSE \\( M \\). Напом- ним, что в последнем случае выбираются все процессы из очереди. Характерной особенностью обращения к процедурам монитора является взаимное исключение ими друг друга. Если один процесс обратился к некоторой процедуре монитора, то ни один другой не может обратиться к другим процедурам в мониторе до тех пор, пока вызывающий процесс либо закончит исполнение вызванной процедуры, либо «успеть» на некоторой «условной» переменной по мере выполнения в вызванной процедуре операции WAIT. В пос- леднем случае процесс временно покидает вызванную процедуру и разрешает другим процессам (одному из них) войти в монитор — выбрать для исполнения некоторую процедуру. При исполнении в составе процедуры монитора примитива SIGNAL является обязательным выполнение следующих условий взаимодействия между сигнализирующим и возбуждаемым процес- сами. Возбуждаемый процесс входит в монитор (в свою прерван- ную процедуру) сразу после выполнения сигнализирующей операции SIGNAL. Таким образом, право обрабатывать мониторную про- цедуру переходит явно от сигнализирующего процесса только к про- буждаемому, даже если есть в текущий момент времени процессы, желающие также войти в монитор. Нетрудно заметить, что монитор реализует критическую область в отношении некоторых разделяемых переменных, являющихся ло- кальными в мониторе и обработка которых допустима только про- цедурами монитора. Для лучшего восприятия структуры и смысло- вого содержания работы монитора воспользуемся методом анало- гий."},{"tag":"аналогия семафора и монитора","text":"Двоичный семафор можно сравнить с узкой дверью, оборудованной «анг- лийским» замком. В открытую дверь \\( S=1 \\) может войти только один человек (из нескольких желающих) и при этом обязательно закрыть ее, защелкивая замок (перебросить семафор в нуль с помощью \\( P \\)-операции). Если идти в об- ратном направлении в отношении этой же двери, то ее нужно сначала открыть (открыть замок), а затем выйти из помещения, оставив дверь открытой. Не- трудно узнать при этом действия алгоритм \\( V \\)-операции. Монитор в силу своей большей мощности — это уже не дверь с замком, а многокомнатная квартира, оборудованная единственной входной узкой дверью. Поласть в такую квартиру при открытой входной двери может только один человек из всех желающих (дверь слишком узка). Попадая в квартиру, как и ранее, такой счастливчик захлопывает за собой дверь, блокируя остальных у входной двери. Квартира имеет коридорную систему, скажем, это будет гостиница) и состоит из некоторого числа изолированных комнат, запирающихся на свой ключ. Тогда из всех прочих комнат наш счастливый посетитель квартиры может попасть только в одну, если предположить, что при штурме входной двери у каждого потенциального посетителя многокомнатной квартиры уже лежит в кармане ключ от какой-либо одной из комнат."},{"tag":"аналогия процесса и процедуры в мониторе","text":"В рассматриваемой ситуации квартира — это аналог монитора, а комнаты в ее составе — процедуры монитора. Посетитель в квартире — это процесс, которому только одному среди прочих удается войти в монитор с целью завладеть в нем только одной процедурой. Поэтому посетитель может открыть только одну из комнат собственным ключом и войти в нее, с тем чтобы использовать все ее содержимое по назначению. По истечении некоторого конечного отрезка времени пребывания в комнате посетитель покидает ее, закрывая за собой дверь на ключ. Затем распахивает входную дверь квартиры и выходит из нее, давая возможность попасть в нее очередному счастливцу (только одному)."},{"tag":"условные переменные и их влияние","text":"Если не вводить в рассмотрение условные переменные и не обсуждать довольно странный порядок попадания и проживания посетителей в гостинице (в любой момент времени в ней может находиться не более одного человека), то обрисованная квартирная ситуация будет полностью аналогична ситуации работы процессов с монитором."},{"tag":"ограничения аналогии при условных переменных","text":"В случае рассмотрения условных переменных требуется быть более изощренным при построении аналогии. Поскольку аналог получается весьма искусственным, он теряет свою наглядность и поэтому далее не рассматривается."},{"tag":"схемы реализации мониторов","text":"Реализация мониторов. Любое высокоуровневое средство взаимодействия и синхронизации процессов может быть построено с помощью низкоуровневых средств. Наиболее приемлемы по эффективности и широко распространены три схемы реализации мониторов: с помощью семафорной техники; с помощью средств управления «условными» переменными, реализуемыми аппаратно; с помощью схемы управления системой прерываний в супервизорном режиме."},{"tag":"требования к реализации монитора семафорной техникой","text":"Рассмотрим реализацию монитора с помощью семафорной техники. В состав монитора входит \\( n \\) процедур, \\( m \\) условных переменных и \\( k \\) локальных переменных. Требуются: 1. Один двоичный семафор для реализации взаимного исключения параллельного исполнения \\( n \\) процедур монитора и обеспечения возможности захвата только одной из них. Начальное состояние этого семафора, который назовем ИСКЛ, должно быть равно 1. 2. Один двоичный семафор для решения задачи сигнализации. Назовем его СИГН. Процессы, ожидающие некоторого сигнала на условной переменной, должны обладать преимущественным правом входа (повторного) в монитор. Поэтому на процесс, сигнализирующий о выполнении некоторого события в отношении определенной условной переменной, накладывается ограничение. Если имеется очередь к СИГН, то сигнализирующий процесс должен «разбудить» один какой-либо процесс, находящийся в составе этой очереди, и предоставить ему право вместо себя войти в монитор. Сам же этот «процесс-джентльмен» должен «заснуть» вместо реактивно-ванного процесса. Такого рода манипуляции должны производиться на выходе из монитора. Для побудки сигнализирующий процесс должен выполнять \\( V \\)-операцию над семафором СИГН, а чтобы самому «уснуть» — выполнить \\( P \\)-операцию в отношении этого же семафора. Такой семафор в литературе называют *личьим*. Его начальное значение должно быть равно 0. При выполнении \\( P \\)- и \\( V \\)-операций над личным семафором необходима информация об очереди «процессов-джентльменов». Эти процессы уступили свое право активного пребывания в мониторе для обеспечения повторного входа в монитор какого-либо процесса, ожидающего до этого некоторого события. Удобно для отслеживания состояния данной очереди завести целую переменную ПРАВО, значение которой в начале работы равно 0. 3. Один двоичный семафор на каждую из \\( n \\) условных переменных с начальным значением каждой из них равным 0. На этом семафоре будут ожидать («спать») те процессы, которые выдают примитив WAIT в отношении соответствующей условной переменной. Имя двоичного семафора, моделирующего некоторую условную переменную с именем \\( V \\), будем обозначать в виде VCEM. Для определения числа процессов, ожидающих на условной переменной \\( V \\), вводится целая переменная с именем VCЧТ. Число таких переменных будет равно числу условных переменных. Каждая из них в начальном состоянии имеет нулевое значение. Использование перечисленных семафоров проиллюстрируем на примере построения конкретного монитора. Необходимо решить задачу упорядоченного использования совокупностью из \\( n \\) параллельных процессов некоторой информационной структуры БАЗА. В эту структуру можно записать лишь одну порцию информации \\( x \\) с помощью операции БАЗА: \\( =x \\) либо считать из нее порцию информации и присвоить ее значение переменной \\( y \\) с помощью операции вида \\( y' :=БАЗА \\). Эти операции реализованы в составе монитора средствами двух процедур — SET и TEST соответственно. В рассматриваемом примере монитор назван DATA. Обращение к процедурам SET и TEST в его составе будет выглядеть следующим образом: DATA.SET (VAR \\( x \\)); DATA.TEST (VAR \\( y \\)). В одном случае в качестве фактического параметра указывается переменная \\( x \\), откуда будет копироваться информация в структуру БАЗА. При обращении к другой процедуре переменная \\( y \\) — фактический параметр, куда будет копироваться информация из структуры БАЗА. При обращении некоторого процесса к процедуре SET монитора может оказаться, что структура БАЗА заполнена информацией от предыдущего обращения. Информация еще не считана из БАЗА. Поэтому такое обращение является невозможным до тех пор, пока хранимая в базе порция информации не будет скопирована каким-либо процессом. В данной ситуации процесс-производитель, который пытается записать в БАЗА порцию информации, должен быть переведен монитором в состояние ожидания освобождения структуры БАЗА (извлечения из нее некоторым процессом-потребителем порции информации). Перевод осуществляется в составе процедуры SET по мере выполнения примитива WAIT над условной переменной ПУСТ. Причем состояние структуры БАЗА отображается значением переменной ФЛАГ. Если порция информации содержится в структуре БАЗА, то значение ФЛАГ равно 1, в противном случае — 0. Если при выполнении процедуры SET обнаруживается, что БАЗА пуста \\( \\Phi_{\\text{ЛАГ}} = 0 \\), то процесс-производитель запишет туда порцию информации и сообщит об этом событии с помощью примитива SIGNAL в отношении условной переменной НЕПУСТ. Если какой-либо процесс-потребитель (или несколько процессов) ожидают этого события, то один из них будет немедленно введен в соответствующую процедуру TEST (после условного предложения по проверке переменной ФЛАГ). Это делается сразу после выхода сигнализирующего процесса из процедуры SET. На этом участке ни один из процессов не может помешать сигнализирующему и возбуждаемому процессам в смене права владеть монитором. При выполнении процедуры TEST в отношении опустошенной структуры БАЗА процесс, вызвавший эту процедуру, переводится в состояние ожидания с помощью операции WAIT на условной переменной НЕПУСТ. В противном случае процесс-потребитель опустошает БАЗА и сигнализирует об этом событии одному из процессов-производителей, которые, возможно, ожидают на условной переменной ПУСТ. Взаимодействие между сигнализирующим и возбуждаемым процессами происходит по тем же правилам, что описаны для случая SET."},{"tag":"пример реализации монитора семафорной техникой","text":"Ниже приведен алгоритм для произвольного числа N > 2 процессов, из которых K > 1 являются процессами-производителями порции информации и заполняют «пустую» структуру БАЗА. Оставшиеся N—K процессы (потребители) извлекают очередную порцию информации из БАЗА. Для общности процессы описаны как циклические. Сначала дана нотация алгоритма в терминах «монитора», а потом дается вариант реализации монитора. Такое преобразование может выполнить, например, компилятор: DATA: MONITOR; BEGIN VAR БАЗА: <ПОРЦИЯ ИНФОРМАЦИИ>; ФЛАГ: 0..1; НЕПУСТ, ПУСТ: CONDITION; PROCEDURE SET(VAR X: <ПОРЦИЯ ИНФОРМАЦИИ>); BEGIN IF ФЛАГ=1 THEN ПУСТ.MAIT; БАЗА:=X; ФЛАГ:=1; НЕПУСТ.SIGNAL END; PROCEDURE TEST(VAR X: <ПОРЦИЯ ИНФОРМАЦИИ>) ; BEGIN IF ФЛАГ=0 THEN HEINCT.WAIT; X:=БАЗА; ФЛАГ:=0; ПУСТ. SIGNAL END; {ИНИЦИАЛИЗАЦИЯ ЛОКАЛЬНЫХ ДАННЫХ МОНИТОРА} ФЛАГ:=0; END; COBEGIN {СОВОКУПНОСТЬ ПРОЦЕССОВ-ПРОИЗВОДИТЕЛЕЙ} 1: BEGIN VAR X: <ПОРЦИЯ ИНФОРМАЦИИ> ; REPEAT <СФОРМИРОВАТЬ ЗНАЧЕНИЕ X> ; DATA .SET(VAR X) FOREVER END; ...... X: BEGIN VAR Y: <ПОРЦИЯ ИНФОРМАЦИИ> ; REPEAT <СФОРМИРОВАТЬ ЗНАЧЕНИЕ Y> DATA .SET(VAR Y) FOREVER END; ...... {СОВОКУПНОСТЬ ПРОЦЕССОВ-ПОТРЕБИТЕЛЕЙ} N: BEGIN VAR Z: <ПОРЦИЯ ИНФОРМАЦИИ> ; REPEAT DATA .TEST(VAR Z) ; <ОБРАБОТКА ЗНАЧЕНИЯ Z-ПОРЦИИ ИНФОРМАЦИИ ИЗ БАЗА> FOREVER END COEND BEGIN VAR ИСКЛ, СИГН, ПУСТСЕМ, НЕПУСТСЕМ. SEMAPHORE ; ПРАВО: INTEGER ; ПУСТСЧТ, НЕПУСТСЧТ: INTEGER ; ФЛАГ: 0..1; БАЗА: <ПОРЦИЯ ИНФОРМАЦИИ> ; {ПРОЦЕДУРЫ МОНИТОРА} PROCEDURE SET(VAR X: <ПОРЦИЯ ИНФОРМАЦИИ> ) ; BEGIN P(ИСКЛ); IF ФЛАГ=1 THEN МОДЕЛЬ ОПЕРАЦИИ WAIT В ОТНОШЕНИИ ПЕРЕМЕННОЙ ПУСТО BEGIN ПУСТСЧТ:=ПУСТСЧТ-1; IF ПРАВО>0 THEN V(СИГН) ELBE V(ИСКЛ); P(ПУСТСЕМ); ПУСТСЧТ:=ПУСТСЧТ-1 END; БАЗА:=X; ФЛАГ:=1; {МОДЕЛЬ ОПЕРАЦИИ SIGNAL В ОТНОШЕНИИ НЕПУСТ} ПРАВО=ПРАВО+1 IF НЕПУСТСЧТ>0 THEN BEGIN V(НЕПУСТСЕМ); P(СИГН) END; ПРАВО=ПРАВО-1; {МОДЕЛЬ ВЫХОДА ИЗ ПРОЦЕДУРЫ} IF ПРАВО > 0 THEN V(СИГН) ELSE V (ИСКЛ) END; PROCEDURE TEST(VARX: <ПОРЦИЯ ИНФОРМАЦИИ>); BEGIN P (ИСКЛ); IF ФЛАГ=0 THEN {МОДЕЛЬ WALT В ОТНОШЕНИИ НЕПУСТО} BEGIN НЕПУСТСЧТ:=НЕПУСТСЧТ+1; IF ПРАВО>0 THEN V(СИГН) ELSE V (ИСКЛ); P (НЕПУСТСЕМ); НЕПУСТСЧТ:=НЕПУСТСЧТ-1 END; X:=БАЗА; ФЛАГ:=0; {МОДЕЛЬ SIGNAL В ОТНОШЕНИИ ПУСТ} ПРАВО:=ПРАВО+1; IF ПУСТСЧТ>0 THEN BEGIN V (ПУСТСЕМ); P (СИГН) END; ПРАВО:=ПРАВО-1; IF ПРАВО>0 THEN V (СИГН) ELSE V (ИСКЛ) END; {ИНИЦИАЛИЗАЦИЯ ЛОКАЛЬНЫХ ПЕРЕМЕННЫХ МОНИТОРА} ПРАВО:=0; ПУСТСЧТ:=0; НЕПУСТСЧТ:=0; ФЛАГ:=0; ИСКЛ:=1; СИГН:=0; ПУСТСЕМ:=0; НЕПУСТСЕМ:=0; COBEGIN 1: BEGIN VAR X: <ПОРЦИЯ ИНФОРМАЦИИ>; REPEAT <СФОРМИРОВАТЬ X>; SET (VAR X) FOREVER END; N: BEGIN VAR Z: <ПОРЦИЯ ИНФОРМАЦИИ>; REPEAT TEST (VAR Z); <ОБРАБОТАТЬ Z>; FOREVER END COEND END"},{"tag":"защита структуры БАЗА монитором","text":"В"}],
[
    {
        "tag": "работа монитора и семафоров",
        "text": "В момент \\( t_2 \\) процесс 2 после входа в монитор «закрывает» семафор ИСКЛ для решения проблемы взаимного исключения и обнаруживает, что запись подготовленной им порции информации в БАЗУ невозможна. БАЗА заполнена ранее \\(\\Phi ЛАГ = 1\\) и не произведено сигнальные из нее ни одним из процессов-потребителей. Поэтому процесс 2 «засыпает» в ожидании возможности занести в структуру БАЗА свою порцию информации по мере освобождения структуры. Он «засыпает» на личном семафоре ПУСТСЕМ. Предварительно инкрементируется значение счетчика ПУСТСЧТ, который определяет число процессов, «спящих» на этом семафоре. Но прежде чем «заснуть», процесс открывает семафор ИСКЛ, тем самым разрешая другим процессам обращаться далее к какой-либо процедуре монитора. Это делается в условиях, когда правом побудем еще никто не пользовался (ПРАВО = 0).\n\nВ момент \\( t_3 \\) процесс N обращается в процедуре TEST, закрывая семафор ИСКЛ. Поскольку в структуре БАЗА содержится информация \\(\\Phi ЛАГ = 1\\), процесс считывает порцию информации и устанавливает ФЛАГ в 0. Далее процесс пытается воспользоваться своим правом побудки какого-либо «спящего» процесса-производителя. ПРАВО устанавливается в 1. В текущий момент времени имеется один «спящий» процесс (ПУСТСЧТ = 1). Поэтому процесс N выполняет свой «джентльменский долг». Он будит процесс 2, спящий на семафоре ПУСТСЕМ с помощью V-операции, а сам «засыпает» на семафоре СИГН.\n\nЗаметим, что в данный момент развития событий семафор ИСКЛ остался в закрытом состоянии. Следовательно, ни один из оставшихся N—2 процессов не сможет обратиться к монитору и помешать «уснуть» процессу N и «возбудиться» процессу 2. Процесс 2 возвращается в процедуру SET и начинает ее исполнять сразу за операцией \\( P \\) (ПУСТСЕМ). Для отметки того факта, что один из процессов вышел из очереди «спящих» процессов производится декремент счетчика ПУСТСЧТ. Далее процесс 2 записывает, наконец, в структуру БАЗА свою порцию информации. ФЛАГ при этом устанавливается в 1.\n\nПроцесс 2 не в меньшей степени «джентльмен», чем процессы-потребители. Поэтому он сначала пытается воспользоваться правом помочь «заснувшим» ранее процессам-потребителям, если таковые есть. Наличие таких процессов фиксируется значением счетчика НЕПУСТСЧТ. В рассматриваемый момент времени значение этого счетчика равно нулю. Поэтому процессу 2 не представляется возможность доказать свое право быть джентльменом. Производится декремент переменной ПРАВО. В результате значение переменной ПРАВО становится равным 1. Это указывает на то, что имеется один процесс, который уже успел воспользоваться правом быть «джентльменом». Таковым был процесс N, который «спит» в настоящий момент на семафоре СИГН.\n\nПроцесс 2 выполняет V-операцию над семафором СИГН, т. е. «будят» процесс N, а сам выходит из процедуры SET. Причем опять этот выход происходит при закрытом семафоре ИСКЛ.\n\nПроцесс N по мере побудки возвращается в прерванное место исполнения процедуры TEST — начинает выполнять декремент переменной ПРАВО. Тем самым отмечается, что процесс N своим правом разбудить другой процесс воспользовался. Поскольку после этого действия значение переменной ПРАВО становится равным нулю, происходит открытие семафора ИСКЛ и выход процесса N из процедуры TEST.\n\nАналогичные рассмотрения можно было бы провести и в отношении других вариантов работы с монитором и тем самым убедиться в правильности его работы. Оставляем это читателям для упражнения."
    },
    {
        "tag": "заключение и цели учебного пособия",
        "text": "Цель, которая стояла перед авторами данного учебного посо- бия, — изложение основ проблематики современных ОС, типичных для большинства существующих и перспективных ОС. Изучив материал, читатель не должен односторонне толковать практическую значимость некоторых вопросов, изложенных в посо- бин. Так, после изучения вопросов, относящихся к виртуальной памяти у читателя не должно сложиться мнение, что виртуальная оперативная память строится только на больших машинах типа ЕС ЭВМ или МВК «Эльбрус». Виртуальная память в настоящее время широко распространена. Она используется даже в архитектуре микропроцессоров, например в 32-разрядном трехкристалльном микропроцессоре 432 фирмы Intel в системе i APX [39]. В нем реализована виртуальная оперативная память объемом в $2^{0}$ байт на основе сегментной организации. Из множества методов синхронизации параллельных процессов при рассмотрении ядра ОС были представлены только те из них, которые основаны на использовании разделяемых переменных при синхронизации процессов. Хотя с помощью такой семафорс- и монитороподобной техники принципиально возможно решить любую задачу синхронизации, следует иметь в виду, что существует целый класс других средств, ориентированных на информационное взаимодействие между процессами. К их числу относят прежде всего почтовые ящики, порты, сообщения, рандеву. Ограниченный объем не позволил рассмотреть в пособии ряд механизмов и средств, входящих в состав ОС. Для их изучения необходимо обратиться к специальной литературе."
    },
    {
        "tag": "литература",
        "text": "**ЛИТЕРАТУРА**\n\n1. *Алферова З. В., Лиханьев Г. Н., Шураков В. В.* Математическое обеспечение ЭВМ. — М.: Статистика, 1974.\n2. Архитектура многопроцессорных вычислительных систем/Под ред. В. И. Тимохина. — Л.: Изд-во ЛГУ, 1981.\n3. *Бабаян Б. А., Сахин Ю. Х.* Система «Эльбрус». Программирование, 1980. № 6.\n4. *Бабаян Б. А.* Основные принципы программного обеспечения МВК «Эльбрус». — М.: Препринт ИТМ и ВТ, 1977, № 5.\n5. Большая Советская Энциклопедия. — М.: Советская энциклопедия, 1975, Т 22.\n6. *Бурцев В. С.* Тенденции развития высокопроизводительных систем и многопроцессорных вычислительных комплексов. — М.: Препринт ИТМ и ВТ, 1977.\n7. *Валикова Л. И.* и др. Операционная система СМ ЭВМ РАФОС. — М.: Финансы и статистика, 1984.\n8. *Голые Р.* Руководство по операционной системе UNIX. — М.: Финансы и статистика, 1985.\n9. *Данилович В. П.* и др. Операционная система ОС ЕС: Справочное пособие. — М.: Статистика, 1980.\n10. *Денис У.* Операционные системы. — М.: Мир, 1980.\n11. *Дийскопра Э.* Взаимодействие последовательных процессов. Языки программирования. — М.: Мир, 1972.\n12. *Донова Дж.* Системное программирование. — М.: Мир, 1975.\n13. *Иванов А. П., Семенцкий С. В.* Операционная система МВК «Эльбрус-1». — М.: Препринт ИТМ и ВТ, 1977, № 2.\n14. *Жиров В. Ф.* Математическое обеспечение и проектирование структур ЭВМ. — М.: Наука, 1979.\n15. *Зелкович М., Шоу А., Гэйлон Д.* Принципы разработки программного обеспечения. — М.: Мир, 1982.\n16. *Кадан Б. М.* Электронные вычислительные машины и системы. — М.: Энергия, 1979.\n17. *Капитан Г.* Операционные системы. — М.: Мир, 1976.\n18. *Кейлингерт П.* Элементы операционных систем. — М.: Мир, 1985.\n19. *Колин А.* Введение в операционные системы. — М.: Мир, 1975.\n20. *Кристина К.* Введение в операционную систему UNIX. — М.: Финансы и статистика, 1985.\n21. *Лорин Г., Дейтел Х. М.* Операционные системы. — М.: Финансы и статистика, 1984.\n22. *Майерс Г.* Надежность программного обеспечения. — М.: Мир, 1980.\n23. *Мэбинкс С., Донова Дж.* Операционные системы. — М.: Мир, 1978.\n24. *Пеледов Г. В., Райков Л. Д.* Введение в ОС ЕС ЭВМ. — М.: Статистика, 1977.\n25. *Пентковский В. М.* Автокод «Эльбрус». — М.: Наука, 1982.\n26. Система математического обеспечения ЕС ЭВМ. — М.: Статистика, 1974.\n27. *Соловьев Г. Н., Никитин В. Д.* Операционные системы цифровых вычислительных машин. — М.: Машиностроение, 1977.\n28. *Тимошин В. И.* Операционная система ОС ЕС. Основы функционирования. — М.: Финансы и статистика, 1983.\n\n29. Цикрипзис Д., Бернстайн Ф. Операционные системы.— М.: Мир, 1977.\n30. Шишмарев А. И., Заморин А. П. Англо-русско-немецко-французский толковый словарь по вычислительной технике и обработке данных.— М.: Русский язык, 1981.\n31. Шоу А. Логическое проектирование операционных систем.— М.: Мир, 1981.\n32. Dahl. O. J., Hoare C. A. R. Hierarchical Program Structure. Structured Programming, Academic Press, Inc., New York, 1972.\n33. Dijkstra E. W. The Structure of the T. H. E. Multiprogramming System, CACM, 1968, V. 11, No. 5 (May), p. 341—346.\n34. Dijkstra E. W. Hierarchical ordering of sequential processes. Acta Informatica, 1971, V. 1, No. 2, p. 115—138.\n35. Hansen P. B. Operating system principles. Prentice Hall, 1973.\n36. Hansen P. B. The Programming Language Concurrent Pascal. IEEE Transaction and software engineering, vol. SE — 1, No. 2, 1975.\n37. Hoare C. A. R. Monitors: An operating System Structuring Concept. Communications of ACM, 1974. V. 17, No. 10, pp. 549—557.\n38. Holt R. C. Some deadlock properties of computer systems. ACM Computing Surveys, 1972, V. 4, No. 3, pp. 179—196.\n39. Introduction to the t APX 432 architecture Intel Corporation, 1981."
    },
    {
        "tag": "",
        "text": "Издательство «Энергия», 113114, Москва, М-114, Шлюзовая наб., 10\n\nЛенинградская типография № 4 «Союзполиграфическая» при Государственном комитете Совета Министров СССР по делам издательств, полиграфии и книжной торговли. Ленинград, Ф-126, ул. Социалистическая, д. 14.\n\n© Издательство «Энергия», 1978 г."
    },
    {
        "tag": "структура книги",
        "text": "Предисловие Введение Глава 1. Тлава 2. Глава 3. ОГЛАВЛЕНИЕ ЧАСТЬ I ВВЕДЕНИЕ В ОПЕРАЦИОННЫЕ СИСТЕМЫ Назначение, основиые принципы построения ОС ЭВМ . § 1L §1.2 Одиопрограммные и мультнпрограммные системы 06- работки даиных. Развитие операциониых систем . Основные принципы — построения я Концептуальные основы операционных снстем юююю 1 2. 3. 4. Py 25. $ 26, Процесс . . . . . . . . . . . .. Pecypc . . e e e e e Концепция ниртуализщии . . Средства взаимодействия пользователя ¢ ЭВМ . Дисциплины распределения ресурсов используеиые в операционных системах . . НЕ Концепция прерывания . . . . . . . . Средства, механизмы, подсистемы OC . . . . . . Система управления процессами Средства `распределеиия ресурса . . Система распределения оперативной памяти . . Подсистема управления BBOAOM — выводом . . . CHCTeMa управления данными . . . РИ ЧАСТЬ Н ПОСТРОЕНИЕ ПОДСИСТЕМ ЯДРА МУЛЬТИПРОГРАММНЫХ 0С (механизмы управления ресурсами и процессами) Глава 4. Организация внртуальной оперативной памяти . . . . 254 4.1, oo o е е ее> Структура виртуальной — памяти Основиые поиятия и прииципы виртуаиизнции памяти Схемы структуризации адресных — пространств Основы логической оргаиизации виртуальной опера- тивной памяти . . Схемы Фуикпиоиировяиия внртуялыюй оперпивной памяти . .. Четыре задачи упрнления виртуальиой памятью | Задача размещения . . ВА 7 ‚ 107 : 145\n\n4.8. Задача перемещения . 153 4.9. Задача преобразования адресов . 158 4.10. Задача замещения . 175 4.11. Сравнение страничной и сегментной организации виртуальной памяти . 179 § 4.12. Виртуальная оперативная память в ЕС ЭВМ . 181\n\nГ л а в а 5. Механизм стековой памяти как средство организации вычислительного процесса . 185\n\n§ 5.1. Модель стека. Стек выражений . 185 § 5.2. Стек как средство обработки структурированных программ . 187 § 5.3. Стек как отображение процесса в оперативной памяти 198 § 5.4. Дерево стеков как отображение процесса операционной системы . 201 § 5.5. Стек как средство эффективной организации вычислительного процесса . 202\n\nГ л а в а 6. Механизмы управления процессами. Средства взаимодействия параллельных процессов . 205\n\n§ 6.1. Задачи синхронизации . 205 § 6.2. Свойства механизмов синхронизации . 209 § 6.3. Архитектура и основные вопросы построения механизмов синхронизации . 211 § 6.4. Семафорная техника синхронизации и упорядочения процессов . 215 § 6.5. Вопросы реализации и использования семафорных механизмов в составе ОС . 229 § 6.6. Монитороподобные средства синхронизации . 232 § 6.7. Вопросы построения мониторов как базового средства по распределению ресурсов в ОС . 241\n\nЗаключение . 251 Литература . 252\n\nУчебное издание\n\nСоловьев Георгий Николаевич Никитин Виктор Дмитриевич\n\nОперационные системы ЭВМ\n\nЗав. редакцией Н. И. Хрусталева Редактор Н. Г. Волкова Мл. редактор Г. Г. Бучина, Е. В. Субъектова Художник А. М. Шлеенков Художественный редактор В. Н. Мешалкин Технический редактор Е. В. Фельдман Корректор Р. К. Косинова ИБ № 8000\n\nИзд. № СТД—607. Сдано в набор 26.10.88. Подп. в печать 17.03.89. Т-05082. Формат 60×88/1. Бум. офсет. № 2. Гарнитура литературная. Печать офсетная. Объем 15,68 усл. печ. л. 15,68 усл. кр.-отт. 17,67 уч. изд. л. Тираж 50 000 экз. Зак. № 1671. Цена 90 коп. Издательство «Высшая школа», 101430, Москва, ГСП-4, Неглинная ул. д. 29/14.\n\nМосковская типография № 4 Союзподпрафирова при Государственном комитете СССР по делам издательств, подпграфии и книжной торговли. 129041, Москва, Б. Переяславская, 46"
    }
]"}]]
